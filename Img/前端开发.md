# 浏览器端

## 浏览器原理

```
参考词汇：
	performance:性能
	parse:解析，编译
	Recalculate Style: 重新计算样式
	layout: 布局
	Update Layer Tree: 更新图层树
	paint: 绘制
	Composite layers: 合成图层
	domain: 域
	render: 渲染
	evaluate script: 执行脚本
```

### 浏览器的功能

#### 1、网络

> 浏览器通过网络模块来下载各式各样的资源，例如html文本；javascript代码；样式表；图片；音视频文件等。
>
> 网络部分本质上十分重要，因为它耗时长，而且需要安全访问互联网上的资源。

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210131141103418.png" alt="image-20210131141103418" style="zoom: 50%;" />

#### 2、资源管理

> 从网络下载，或者本地获取到的资源需要有高效的机制来管理他们。
>
> 例如：如何避免重复下载，资源如何缓存等

#### 3、网页浏览

> 这是浏览器的核心也是最基本的功能，最重要的功能。
>
> 如何将资源转变为可视化的结果。

浏览器的主要功能总结起来就是一句话：将用户输入的url转变成可视化的图像。

1、从url到DOM树

2、从DOM树到可视化图像

这两个过程之间的关系没有那么明确，我们可以统称这两个过程为页面的渲染。

### 浏览器的组成

<img src="https://images2018.cnblogs.com/blog/1426829/201806/1426829-20180626200818008-861865339.png" alt="img" style="zoom:80%;" /> 

简单来说浏览器可以分为两部分，`shell+内核`。其中shell的种类相对比较多，内核则比较少。

Shell是指浏览器的外壳：包括User Interface（用户界面）、Browser engine（浏览器引擎）、Networking（网络）、UI Backend（UI 后端）、Date Persistence（数据持久化存储）。它是调用内核来实现各种功能的。

内核才是浏览器的核心。内核是基于标记语言显示内容的程序或模块。也有一些浏览器并不区分外壳和内核。 从Mozilla将Gecko独立出来后，才有了外壳和内核的明确划分。目前主流的浏览器有IE6、IE8、Mozilla、FireFox、Opera、Safari、Chrome、Netscape等。

`浏览器内核又可以分成两部分：渲染引擎(layout engineer或者Rendering Engine)和JS引擎`。它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至 显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内 容的应用程序都需要内核。

JS引擎则是解析Javascript语言，执行javascript语言来实现网页的动态效果。最开始渲染引 擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，`内核就倾向于只指渲染引擎`。有一个网页标准计划小组制作了一个ACID来测试引擎的兼容性和性 能。内核的种类很多，如加上没什么人使用的非商业的免费内核，可能会有10多种，但是常见的浏览器内核可以分这四种：`Trident、Gecko、 Presto、Webkit。`

![img](https://images2018.cnblogs.com/blog/1426829/201806/1426829-20180626201250293-2058239882.png)

**相互工作：**

![img](https://images2018.cnblogs.com/blog/1426829/201806/1426829-20180626200955053-2003337809.png)

- 用户界面 －包括地址栏、后退/前进按钮、书签目录等，也就是你-所看到的除了页面显示窗口之外的其他部分
- 浏览器引擎 －可以在用户界面和渲染引擎之间传送指令或在客户端本地缓存中读写数据等，是浏览器中各个部分之间相互通信的核心
- 渲染引擎 －解析DOM文档和CSS规则并将内容排版到浏览器中显示有样式的界面，也有人称之为排版引擎，我们常说的浏览器内核主要指的就是渲染引擎
- 网络 －用来完成网络调用或资源下载的模块
- UI 后端 －用来绘制基本的浏览器窗口内控件，如输入框、按钮、单选按钮等，根据浏览器不同绘制的视觉效果也不同，但功能都是一样的。
- JS引擎 －用来解释执行JS脚本的模块，如 V8 引擎、JavaScriptCore
- 数据存储持久层 - 浏览器需要把所有数据存到硬盘上，如cookies、localStorage、sessionStorage。新的HTML5规范规定了一个完整（虽然轻量级）的浏览器中的数据库 web database

`注意：chrome浏览器与其他浏览器不同，chrome使用多个渲染引擎实例，每个Tab页一个，即每个Tab都是一个独立进程。`

### 浏览器中的进程与线程

Chrome浏览器使用多个进程来隔离不同的网页，在Chrome中打开一个网页相当于起了一个进程，每个tab网页都有由其独立的渲染引擎实例。因为如果非多进程的话，如果浏览器中的一个tab网页崩溃，将会导致其他被打开的网页应用。另外相对于线程，进程之间是不共享资源和地址空间的，所以不会存在太多的安全问题，而由于多个线程共享着相同的地址空间和资源，所以会存在线程之间有可能会恶意修改或者获取非授权数据等复杂的安全问题。

`同一个网站打开多个网页使用一个进程。`

在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：

**1. GUI 渲染线程**

GUI渲染线程负责渲染浏览器界面HTML元素,当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时，该线程就会执行。在Javascript引擎运行脚本期间,GUI渲染线程都是处于挂起状态的，也就是说被冻结了.

**2. JavaScript引擎线程**

JS为处理页面中用户的交互，以及操作DOM树、CSS样式树来给用户呈现一份动态而丰富的交互体验和服务器逻辑的交互处理。如果JS是多线程的方式来操作这些UI DOM，则可能出现UI操作的冲突；如果JS是多线程的话，在多线程的交互下，处于UI中的DOM节点就可能成为一个临界资源，假设存在两个线程同时操作一个DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果，当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，JS在最初就选择了单线程执行。

`GUI渲染线程与JS引擎线程互斥的，是由于JavaScript是可操纵DOM的`，如果在修改这些元素属性同时渲染界面（即JavaScript线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致。当JavaScript引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到引擎线程空闲时立即被执行。由于GUI渲染线程与JS执行线程是互斥的关系，当浏览器在执行JS程序的时候，GUI渲染线程会被保存在一个队列中，直到JS程序执行完成，才会接着执行。因此如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

**3. 定时触发器线程**

浏览器定时计数器并不是由JS引擎计数的, 因为JS引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。

**4. 事件触发线程**

当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等，但由于JS的单线程关系所有这些事件都得排队等待JS引擎处理。

**5. 异步http请求线程**

在XMLHttpRequest在连接后是通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到JS引擎的处理队列中等待处理。

### 前端页面渲染流程       

用户请求的HTML文本(text/html)通过浏览器的网络层到达渲染引擎后，渲染工作开始。每次通常渲染不会超过8K的数据块，其中基础的渲染流程

图：

![640?wx_fmt=png](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/XP4dRIhZqqV6B9SNRbyQflzvDFfqbdftQpnTDP7u7ic6kxy3kJCsQH0lZvUOhvjyvIXpRjhicywaYMIhCk0DyZCg/640?wx_fmt=png)		

webkit引擎渲染的详细流程，其他引擎渲染流程稍有不同：

![img](https://image.fundebug.com/2019-01-03-1.png)

浏览器工作流程大体分为如下三部分：

**1）浏览器会解析三个东西：**

- 一个是HTML/SVG/XHTML，事实上，Webkit有三个C++的类对应这三类文档。解析这三种文件会产生一个DOM Tree。
- CSS，解析CSS会产生CSS规则树。
- Javascript，脚本，主要是通过DOM API和CSSOM API来操作DOM Tree和CSS Rule Tree.

**2）解析完成后，浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。**

- Rendering Tree 渲染树并不等同于DOM树，因为一些像Header或display:none的东西就没必要放在渲染树中了。
- CSS 的 Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个Element。也就是DOM结点。也就是所谓的Frame。
- 然后，计算每个Frame（也就是每个Element）的位置，这又叫`layout`和`paint`过程。

**3）最后通过调用操作系统Native GUI的API绘制。**

> 接下来我们针对这其中所经历的重要步骤，一一详细阐述。

渲染过程:

浏览器渲染页面的整个过程：浏览器会从上到下解析文档。

1、遇见HTML标记，调用HTML解析器解析为对应的token（一个token就是一个标签文本的序列化）并构建DOM树（就是一块内存，保存

​	 着他们tokens，建立他们之间的关系）

2、遇见tyle/link标记调用解析器处理css标记并构建css样式树（CSSOM)，就算没有写css样式，也会有默认的样式，也会生成CSS树(CSSOM)。

3、遇见script标记调用javascript解析器处理script标记，绑定事件、修改DOM树/CSS树

4、将DOM树与CSS树合并成一个渲染树(这个过程并不需要等全部DOM和CSSOM生成，而是一点一点渲染，也不一定是遇到一个标签就渲染一次）

5、根据渲染树来渲染，以计算每个节点的几何信息（这一过程需要依赖图形库）

6、将各个节点绘制到屏幕上。

注：网页默认会有css样式，会生成默认的CSSOM，遇到html标签就会解析，一点一点解析，并渲染，但是现代浏览器为了优化性能，会解析到一定程度

才会渲染（重排和重绘），比如遇到<style><link><script>标签，

css样式一般建议放在头部，这是为了解析到html的时候就有加载完成的CSSOM了，如果放在底部，html标签会根据默认的CSSOM来进行渲染，但是遇	  到最后的CSS又会重新渲染，这样就可能导致一些闪屏或者性能问题。

js代码一般建议放在底部，如果放在头部(代码不做处理，比如：不加window.onload函数），js解析会阻塞html渲染，这样就会导致页面显示延迟，造	  成体验效果不好，而且也无法获取到DOM.放在底部就可以避免这个问题

详细流程是，

**1、只存在html**(style标签中的样式由html解析器进行解析，浏览器加载资源是异步的，页面style标签写的内部样式是异步解析的)

​	 URL->DNS->ip->send Request(html)->Receive Response->Receive Date -> Finsish Loading -> Parse HTML

​	 ->Recalculate Style(重新计算样式)->Layout->Update Layer Tree->Paint->Composite Layers(合成图层)

注：`浏览器渲染页面一般不会一点一点渲染，而是渲染好全部才会渲染处理，但是遇到图片，script标签，link标签等会渲染一次`

#### **构建DOM**

浏览器会遵守一套步骤将HTML 文件转换为 DOM 树。宏观上，可以分为几个步骤：

![img](https://image.fundebug.com/2019-01-03-2.png)

- 浏览器从磁盘或网络读取HTML的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成字符串。

  在网络中传输的内容其实都是 0 和 1 这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。

- 将字符串转换成Token，例如：`<html>`、`<body>`等。**Token中会标识出当前Token是“开始标签”或是“结束标签”亦或是“文本”等信息**。

这时候你一定会有疑问，节点与节点之间的关系如何维护？

事实上，这就是Token要标识“起始标签”和“结束标签”等标识的作用。例如“title”Token的起始标签和结束标签之间的节点肯定是属			  	  于“head”的子节点。

![img](https://image.fundebug.com/2019-01-03-3.png)

上图给出了节点之间的关系，例如：“Hello”Token位于“title”开始标签与“title”结束标签之间，表明“Hello”Token是“title”Token的子	   节点。同理“title”Token是“head”Token的子节点。

- 生成节点对象并构建DOM

  事实上，构建DOM的过程中，不是等所有Token都转换完成后再去生成节点对象，而是一边生成Token一边消耗Token来生成节点对象。换句话说，每个Token被生成后，会立刻消耗这个Token创建出节点对象。**注意：带有结束标签标识的Token不会创建节点对象。**

接下来我们举个例子，假设有段HTML文本：

```html
     <html>
     <head>
         <title>Web page parsing</title>
     </head>
     <body>
         <div>
             <h1>Web page parsing</h1>
             <p>This is an example Web page.</p>
         </div>
     </body>
     </html>
```

上面这段HTML会解析成这样：

![img](https://image.fundebug.com/2019-01-03-4.png)

#### **构建CSSOM**

DOM会捕获页面的内容，但浏览器还需要知道页面如何展示，所以需要构建CSSOM。

构建CSSOM的过程与构建DOM的过程非常相似，当浏览器接收到一段CSS，浏览器首先要做的是识别出Token，然后构建节点并生成CSSOM。

![img](https://image.fundebug.com/2019-01-03-5.png)

在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归 CSSOM 树，然后确定具体的元素到底是什么样式。

**注意：CSS匹配HTML元素是一个相当复杂和有性能问题的事情。所以，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去**。

#### **构建渲染树**

当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。

![img](https://image.fundebug.com/2019-01-03-6.png)

在这一过程中，不是简单的将两者合并就行了。**渲染树只会包括需要显示的节点和这些节点的样式信息**，如果某个节点是 `display: none` 的，那么就不会在渲染树中显示。

#### **布局与绘制**

当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。

布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸，所有相对测量值都将转换为屏幕上的绝对像素。

布局完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素。

> 以上我们详细介绍了浏览器工作流程中的重要步骤，接下来我们讨论几个相关的问题：

#### CSS图层

 浏览器在渲染一个页面时，会将页面分为很多个图层，图层有大有小，每个图层上有一个或多个节点。

在渲染DOM的时候，浏览器所做的工作实际上是：

​	1、获取DOM后分割为多个图层

​	2、对每个图层的节点计算样式结果		(Recalculate style -- 样式重计算)

​	3、为每个节点生成图形和位置			 （Layout -- 重排（回流））

​	4、将每个节点绘制填充到图层位图中	(paint -- 重绘)

​	5、图层作为纹理上传至GPU

​	6、组合多个图层到页面上生成最终屏幕图像	（Composite Layers -- 图层重组）

**图层创建的条件**

​	Chrome浏览器满足以下任意情况就会创建图层：
​			1、拥有具有3D变换的CSS属性(最常用)

​		例：

	          div{
	               transform:translateZ(0)
	          }
​	 2、使用加速视频解码的<video>节点

​	 3、<canvas>节点

​	 4、CSS3动画的节点

​	 5、拥有CSS加速属性的元素（will-change)

#### 问题一：渲染过程中遇到JS文件怎么处理？

JavaScript的加载、解析与执行会阻塞DOM的构建，也就是说，在构建DOM时，HTML解析器若遇到了JavaScript，那么它会暂停构建DOM，将控制权移交给JavaScript引擎，等JavaScript引擎运行完毕，浏览器再从中断的地方恢复DOM构建。

由于JavaScript有可能操作DOM和CSSOM，所以这时候DOM和CSSOM不会解析和合并

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <h3 id="test">test</h3>
  <h3>test</h3>
  <h3>test</h3>
  <script src="./external.js">
  </script>
</body>
</html>
```

external.js

```
alert('test')
```

结果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210104094806625.png" alt="image-20210104094806625" style="zoom:80%;" />

发生了阻塞，我们可以在script标签后面加上defer或者async或者把所有js代码放进load事情触发后执行，因为window.onload是异步事件就可以避免这种情况了

```
     <script src="./external.js" defer>
       </script>
```

![image-20210104095039347](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210104095039347.png)

注意：所有浏览器在下载JS的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。
			    直到JS下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。
				`为了提高用户体验，新一代浏览器都支持并行下载JS`，但是JS下载仍然会阻塞其它资源的下载（例如.图片，css文件等）。

​		  也就是说如果js是外部链接，那么不需要等待js全部接收和解析完毕才渲染html,而是一遍接收一遍渲染html

​		 由于浏览器为了防止出现JS修改DOM树，需要重新构建DOM树的情况，所以就会阻塞其他的下载和呈现。

​		 **JS只会阻塞其后内容的显示（已测试），****

​		2种方式都会阻塞其后资源的下载。也就是说外部样式不会阻塞外部脚本的加载，但会阻塞外部脚本的执行。

#### 问题二：为什么dom操作会影响性能？

在浏览器当中，dom的实现和ECMAScript的实现是分离的。

例如，在IE中，ECMAScrit的实现在jscript.dll中，而DOM的实现在mshtml.dll中；在Chrome中使用WebKit中的 WebCore处理DOM和渲染，但ECMAScript是在V8引擎中实现的，其他浏览器的情况类似。

因此，操作dom，就是通过js代码调用dom的接口，就相当于两个相互独立的模块发生了交互。这样，相比于在同一个模块当中互相调用，这种跨模块的调用它的性能损耗是非常高的。

把DOM和JavaScript（这里指ECMScript）各自想象为一个岛屿，它们之间用收费桥梁连接，ECMAScript每次访问DOM，都要途径这座桥，并交纳“过桥费”,访问DOM的次数越多，费用也就越高。因此，推荐的做法是尽量减少过桥的次数，努力待ECMAScript岛上。

然而，`dom操作影响性能最主要是因为它导致了浏览器的重绘（repaint）和重排（reflow）`。

但是：`现代浏览器中会有优化方法，就是把dom操作积累起来，做批量处理。`但是在有些情况下，浏览器会立即重排或重绘。比如请求如下的DOM元素布局信息：offsetTop/Left/Width/Height、scrollTop/Left/Width/Height、clientTop/Left/Width/Height、getComputedStyle()或 currentStyle。因为这些值都是动态计算的，所以浏览器需要尽快完成页面的绘制，然后计算返回值，从而打乱了重排或重绘的优化。

#### 问题三：CSS加载会造成阻塞吗？

为了完成本次测试，先来科普一下，如何利用chrome来设置下载速度

1. 打开chrome控制台(按下F12),可以看到下图，重点在我画红圈的地方

   ![img](https://pic1.zhimg.com/80/v2-00bec3ea167ad4320a7e60fa0e405978_720w.jpg)

2. 点击我画红圈的地方(No throttling),会看到下图,我们选择GPRS这个选项

   ![img](https://pic2.zhimg.com/80/v2-3b76909c0db211e6def82107ddaaabc9_720w.jpg)

3. 这样，我们对资源的下载速度上限就会被限制成20kb/s，好，那接下来就进入我们的正题

**css加载会阻塞DOM树的解析渲染吗？**

用代码说话：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>css阻塞</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      h1 {
        color: red !important
      }
    </style>
    <script>
      function h () {
        console.log(document.querySelectorAll('h1'))
      }
      setTimeout(h, 0)
    </script>
    <link href="https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css" rel="stylesheet">
  </head>
  <body>
    <h1>这是红色的</h1>
  </body>
</html>
```

假设： css加载会阻塞DOM树解析和渲染

假设下的结果: 在bootstrap.css还没加载完之前，下面的内容不会被解析渲染。那么我们一开始看到的应该是白屏，h1不会显示出来。并且此时console.log的结果应该是一个空数组。

实际结果:如下图

![img](https://pic2.zhimg.com/v2-d27c590e677526132cc102b967cb06b9_b.jpg)



**css会阻塞DOM树解析？**

由上图我们可以看到，当bootstrap.css还没加载完成的时候，h1并没有显示，但是此时控制台输出如下

![img](https://pic1.zhimg.com/80/v2-655b4eabed2a09aaa75662cd971cb7fc_720w.jpg)



可以得知，此时DOM树至少已经解析完成到了h1那里，而此时css还没加载完成，也就说明，css并不会阻塞DOM树的解析。

**css加载会阻塞DOM树渲染？**

由上图，我们也可以看到，当css还没加载出来的时候，页面显示白屏，直到css加载完成之后，红色字体才显示出来，也就是说，下面的内容虽然解析了，但是并没有被渲染出来。所以，css加载会阻塞DOM树渲染。

**个人对这种机制的评价**

其实我觉得，这可能也是浏览器的一种优化机制。因为你加载css的时候，可能会修改下面DOM节点的样式，如果css加载不阻塞DOM树渲染的话，那么当css加载完之后，DOM树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，在根据最终的样式来渲染DOM树，这种做法性能方面确实会比较好一点。

**css加载会阻塞js运行吗？**

 由上面的推论，我们可以得出，css加载不会阻塞DOM树解析，但是会阻塞DOM树渲染。那么，css加载会不会阻塞js执行呢?

同样，通过代码来验证.

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>css阻塞</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script>
      console.log('before css')
      var startDate = new Date()
    </script>
    <link href="https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css" rel="stylesheet">
  </head>
  <body>
    <h1>这是红色的</h1>
    <script>
      var endDate = new Date()
      console.log('after css')
      console.log('经过了' + (endDate -startDate) + 'ms')
    </script>
  </body>
</html>
```

假设: css加载会阻塞后面的js运行

预期结果: 在link后面的js代码，应该要在css加载完成后才会运行

实际结果:

![img](https://pic1.zhimg.com/v2-08c57cc17672558749803febff606468_b.jpg)



由上图我们可以看出，位于css加载语句前的那个js代码先执行了，但是位于css加载语句后面的代码迟迟没有执行，直到css加载完成后，它才执行。这也就说明了，css加载会阻塞后面的js语句的执行。详细结果看下图(css加载用了5600+ms):



![img](https://pic3.zhimg.com/80/v2-00254fb0bd3edd4f25fcc093681a2006_720w.jpg)

**结论**

由上所述，我们可以得出以下结论:

声明：只有link引入的外部css才能够产生阻塞。

1、style标签中的样式

​	（1）由html解析器进行解析

​	（2）不阻塞浏览器渲染(可能会产生“闪屏现象”)，因为这时会多开一个html解析器，所以并不需要等style标签里面的css渲染完成才往下解析

​	（3）不阻塞DOM解析

2、link引入的外部css样式（推荐使用的方式）：

​	（1）由css解析器进行解析

​	（2）阻塞浏览器渲染（可以利用这种阻塞避免“闪屏现象”）

​	（3）阻塞其后面的js语句的执行

​			原因：如果后面js的内容是获取元素的样式，例如宽高等CSS控制的属性，

​					  如果不等样式解析完毕，后面的js就获得了错误的信息

​					  由于浏览器也不知道后续js的具体内容，所以只好等前面的所有样式解析完毕后，再执行js

​					  例如：Firefox在样式表加载和解析的过程中，会禁止掉所有的脚本

​			注意：现代浏览器越发注重用户体验，对于webkit内核的浏览器而言，

​					  仅当脚本尝试访问的样式属性、或可能受尚未加载的样式表影响时，它才会禁止该脚本

​	（4）不阻塞DOM的解析：

​			原因:DOM解析和CSS解析是两个并行的线程，浏览器解析DOM生成DOM TREE，

​					解析CSS生成CSS TREE,最终组成render Tree,再渲染也页面。

​					即：DOM的解析，和CSS的解析是并行执行的，即:不阻塞DOM的解析

1. `css加载不会阻塞DOM树的解析`

2. `css加载会阻塞DOM树的渲染`

3. `css加载会阻塞后面js语句的执行`

   加载也就是在请求css文件的过程

因此，为了避免让用户看到长时间的白屏时间，我们应该尽可能的提高css加载速度，比如可以使用以下几种方法:

1. 使用CDN(因为CDN会根据你的网络状况，替你挑选最近的一个具有缓存内容的节点为你提供资源，因此可以减少加载时间)
2. 对css进行压缩(可以用很多打包工具，比如webpack,gulp等，也可以通过开启gzip压缩)
3. 合理的使用缓存(设置cache-control,expires,以及E-tag都是不错的，不过要注意一个问题，就是文件更新后，你要避免缓存而带来的影响。其中一个解决防范是在文件名字后面加一个版本号)
4. 减少http请求数，将多个css文件合并，或者是干脆直接写成内联样式(内联样式的一个缺点就是不能缓存)

**更新**

**原理解析**

那么为什么会出现上面的现象呢？我们从浏览器的渲染过程来解析下。

不用浏览器使用的内核不同，所以他们的渲染过程也是不一样的。目前主要有两个：

**webkit渲染过程**



![img](https://pic3.zhimg.com/80/v2-ddbb3012429ae454a92da09c816948de_720w.jpg)



**Gecko渲染过程**



![img](https://pic2.zhimg.com/80/v2-5030ffa6e418a4aab8f4bc5fce21fccd_720w.jpg)



从上面两个流程图我们可以看出来，浏览器渲染的流程如下：

1. HTML解析文件，生成DOM Tree，解析CSS文件生成CSSOM Tree
2. 将Dom Tree和CSSOM Tree结合，生成Render Tree(渲染树)
3. 根据Render Tree渲染绘制，将像素渲染到屏幕上。

从流程我们可以看出来

1. `DOM解析和CSS解析是两个并行的进程，所以这也解释了为什么CSS加载不会阻塞DOM的解析`。
2. `然而，由于Render Tree是依赖于DOM Tree和CSSOM Tree的，所以他必须等待到CSSOM Tree构建完成，也就是CSS资源加载完成(或者CSS资源加载失败)后，才能开始渲染。因此，CSS加载是会阻塞Dom的渲染的`。
3. `由于js可能会操作之前的Dom节点和css样式，因此浏览器会维持html中css和js的顺序。因此，样式表会在后面的js执行前先加载执行完毕。所以css会阻塞后面js的执行。`

**补充**

**DOMContentLoaded**

对于浏览器来说，页面加载主要有两个事件，一个是DOMContentLoaded，另一个是onLoad。而onLoad没什么好说的，就是等待页面的所有资源都加载完成才会触发，这些资源包括css、js、图片视频等。

而DOMContentLoaded，顾名思义，就是当页面的内容解析完成后，则触发该事件。那么，正如我们上面讨论过的，css会阻塞Dom渲染和js执行，而js会阻塞Dom解析。那么我们可以做出这样的假设

1. 当页面只存在css，或者js都在css前面，那么DomContentLoaded不需要等到css加载完毕。
2. 当页面里同时存在css和js，并且js在css后面的时候，DomContentLoaded必须等到css和js都加载完毕才触发。

我们先对第一种情况做测试：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>css阻塞</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        console.log('DOMContentLoaded');
      })
    </script>
    <link href="https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css" rel="stylesheet">
  </head>
  <body>
  </body>
</html>
```

实验结果如下图：

![img](https://pic4.zhimg.com/v2-1e38a6bf92f702978c2ebb4aed4c403f_b.jpg)



从动图我们可以看出来，css还未加载完，就已经触发了DOMContentLoaded事件了。因为css后面没有任何js代码。

接下来我们对第二种情况做测试，很简单，就在css后面加一行代码就行了

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>css阻塞</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        console.log('DOMContentLoaded');
      })
    </script>
    <link href="https://cdn.bootcss.com/bootstrap/4.0.0-alpha.6/css/bootstrap.css" rel="stylesheet">

    <script>
      console.log('到我了没');
    </script>
  </head>
  <body>
  </body>
</html>
```

实验结果如下图：

![img](https://pic4.zhimg.com/v2-98b79021bbe1d0a3f2d3c2aef089278f_b.jpg)

我们可以看到，只有在css加载完成后，才会触发DOMContentLoaded事件。因此，我们可以得出结论：

1. 如果页面中同时存在css和js，并且存在js在css后面，则DOMContentLoaded事件会在css加载完后才执行。
2. 其他情况下，DOMContentLoaded都不会等待css加载，并且DOMContentLoaded事件也不会等待图片、视频等其他资源加载。

`CSS本来是可以并行下载的，在什么情况下会出现阻塞加载了(在测试观察中，IE6下CSS都是阻塞加载）`

`当CSS后面跟着嵌入的JS的时候，该CSS就会出现阻塞后面资源下载的情况。而当把嵌入JS放到CSS前面，就不会出现阻塞的情况了。`

`根本原因：因为浏览器会维持html中css和js的顺序，样式表必须在嵌入的JS执行前先加载、解析完。而嵌入的JS会阻塞后面的资源加载，所以就会出现上面CSS阻塞下载的情况`。

#### 问题四：为什么把 Script 标签放在 body 结束标签之后 html 结束标签之前？

由上面我们可以得知：js代码会阻塞后续的html渲染，这有可能会导致不好的用户体验。

所以我们必须采取措施：

**之前推荐的方法：**

之前解决这个问题的方法是把`<script>` 标签放到`<body>`标签之后 ，这确保了解析到</body>之前都不会被script终端。

这个方法是有问题的: 浏览器在整个文档解析完成之前都不能下载script文件，如果文档很大的话，解析完HTML，用户依然要等待script文件下载并	  执行完成之后，才能操作这个网站。（主要是串行，先解析HTML完，再下载并执行script，速度肯定没有并行块，那么怎么并行呢？我们假设能在解析HTML一开始，就开始下载script，并且不阻断HTML的解析，是不是就并行了呢）如果你的网站在2秒之内没有响应，用户就会跑掉；

**推荐的解决方案：**

现在浏览器script标签支持 `async` 和 `defer` 属性. 应用这些属性当script被下载时，浏览器更安全而且可以并行下载（下载script并不阻断HTML解析）。

**async**

```text
<script type="text/javascript" src="path/to/script1.js" async></script>
<script type="text/javascript" src="path/to/script2.js" async></script>
```

async标记的Script异步执行下载，并执行。这意味着script下载时并不阻塞HTML的解析，并且下载结束script马上执行。
异步意味着，上述代码script2可能比script1先下载完并执行完。

根据 [http://caniuse.com/#feat=script-async](https://link.zhihu.com/?target=http%3A//caniuse.com/%23feat%3Dscript-async), 90% 的浏览器支持async属性.

**defer**

```text
<script type="text/javascript" src="path/to/script1.js" defer></script>
<script type="text/javascript" src="path/to/script2.js" defer></script>
```

defer标签的script顺序执行。这种方式也不会阻断浏览器解析HTML。

跟 async不同, defer scripts在整个文档里的script都被下载完才**顺序执行**。

根据 [http://caniuse.com/#feat=script-defer](https://link.zhihu.com/?target=http%3A//caniuse.com/%23feat%3Dscript-defer), 90% 的浏览器支持这个属性. 92% 至少部分支持此属性。

**defer与async的区别**

![img](https://img2018.cnblogs.com/blog/1237064/201902/1237064-20190225103543934-1114218399.png)

当浏览器碰到 `script` 脚本的时候：

1. <script src="script.js"></script>

`没有 defer 或 async`，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。

2. <script async src="script.js"></script>

`有 async`，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。

3. <script defer src="myscript.js"></script>

`有 defer`，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，`DOMContentLoaded` 事件触发之前完成。

> Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。

**实用角度**

然后从实用角度来说呢，首先把`所有脚本都丢到 </body> 之前`是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。

接着，我们来看一张图:
![img](https://img2018.cnblogs.com/blog/1237064/201902/1237064-20190225103106193-1835436522.jpg)

- 蓝色线代表网络读取，
- 红色线代表执行时间，这俩都是针对脚本的；
- 绿色线代表 HTML 解析。

此图告诉我们以下几个要点：

- `defer 和 async` 在`网络读取`（下载）这块儿是一样的，都是`异步的`（相较于 HTML 解析）
- `defer 和 async的差别在于脚本下载完之后何时执行`，显然 defer 是最接近我们对于应用脚本加载和执行的要求的
- `关于 defer，此图未尽之处在于它是按照加载顺序执行脚本的`，这一点要善加利用
- `async 则是一个乱序执行`的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，`只要它加载完了就会立刻执行`
- 仔细想想，`async` 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以`不依赖任何脚本或不被任何脚本依赖的脚本`来说却是非常合适的，最典型的例子：`Google Analytics`

**总结**

 **1、放在底部，虽然放在底部照样会阻塞所有呈现，但不会阻塞资源下载。**
		**2、如果嵌入JS放在head中，请把嵌入JS放在CSS头部。**
		**3、使用defer（只支持IE）anysc W3C**
		**4、不要在嵌入的JS中调用运行时间较长的函数，如果一定要用，可以用`setTimeout`来调用**

- 动态脚本元素：文档对象模型（DOM）允许你使用js动态创建HTML的几乎全部文档内容。

- async : 并行加载js，`下载完毕立即解释执行代码`，不会按照页面上的script顺序执行。
- defer : 并行下载js，在页面解析完毕之后，会按照页面上的script标签的顺序执行,同时会在document的DOMContentLoaded之前执行。
  - 注： HTML5规范要求脚本执行应该按照脚本出现的先后顺序执行，但实际情况下，延迟脚本不一定按照先后顺序执行

![img](https://image.fundebug.com/2019-01-03-7.png)

我们知道，当网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断重新渲染。重新渲染会重复上图中的第四步(回流)+第五步(重绘)或者只有第五个步(重绘)。

- 重绘:当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，而不会影响布局的，比如background-color。
- 回流:当render tree中的一部分(或全部)因为元素的规模尺寸、布局、隐藏等改变而需要重新构建

**回流必定会发生重绘，重绘不一定会引发回流**。重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。

#### 1）常见引起回流属性和方法

任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发回流，

- 添加或者删除可见的DOM元素；
- 元素尺寸改变——边距、填充、边框、宽度和高度
- 内容变化，比如用户在input框中输入文字
- 浏览器窗口尺寸改变——resize事件发生时
- 计算 offsetWidth 和 offsetHeight 属性
- 设置 style 属性的值

DOM的重绘和回流Repaint&Reflow

顺序：先回流在重绘

**重绘：**元素样式的改变（但宽度、大小、位置等不变）

​		**如outline,visiblity,color,background-color等**

**回流（重排）：**元素的大小或者位置发生了变化（当页面布局和几何信息发生变化的时候），触发了重新布局，导致渲染树重新计算布局和渲染

​		如添加或删除可见的DOM元素；元素的位置发生变化；元素的尺寸发生变化；内容发生变化(比如文本变化或图片被另一个不同尺寸的图片所替代)；页面一开始渲染的时候（这个无法避免）；因为回流是根据视口大小来计算元素的位置和大小的，所以浏览器的窗口尺寸变化也会引发回流...

注意：回流一定触发重绘，而重绘不一定会回流

​		  网页默认会有css样式，会生成默认的CSSOM，遇到html标签就会解析，一点一点解析，并渲染，但是现代浏览器为了优化性能，会解析到一定				 程度才会渲染（重排和重绘），比如遇到<style><link><script>标签，

### 性能优化

#### **一、PC端优化策略**

   主要包括网络加载类、页面渲染类、CSS优化类、JavaScript执行类、缓存类、图片类、架构协议类等几类；

##### **1、网络加载类**

（1）减少HTTP资源请求次数：

   在前端页面中，通常建议尽可能合并静态资源图片、JavaScript或CSS代码，减少页面请求数和资源请求消耗，这样可以缩短首屏加载时间，通过构建工具合并雪碧图、CSS、JavaScript文件等都是为了减少HTTP资源请求次数，另外也要尽量避免重复的资源，防止增加多余请求；

（2）减少HTTP请求大小：

   除了减少HTTP资源请求次数，也要尽量减少每个HTTP请求的大小，如减少没必要的图片、JavaScript、CSS 及 HTML 代码，对文件进行压缩优化，或者使用gzip压缩传输内容等都可以用来减少文件大小，缩短网络传输等待时延，使用构建工具来压缩静态图片资源以及移除代码中的注释并压缩，目的都是为了减少HTTP请求的大小；

（3）将CSS或JavaScript放到外部文件中，避免使用style或script标签直接引入：

   在HTML文件上引用外部资源可以有效利用浏览器的静态资源缓存，但有时候在移动端页面CSS或JavaScript比较简单的情况下为了减少请求，也会将CSS或JavaScript直接写到HTML里面，具体要根据CSS或JavaScript文件的大小和业务的场景来分析，如果CSS或JavaScript文件内容较多，业务逻辑较复杂，建议放到外部文件引入；

```xml
     <link rel="stylesheet" href="/css/master.css">
     <script type="text/javascript" src="//cdn.domain.com/path/main.js"></script>
```

（4）避免页面中空的href和src：

   当<link>标签的href属性为空，或<script>、<img>、<iframe>标签的src属性为空时，浏览器在渲染过程中仍会将href属性或者src属性中的空内容进行加载，直至加载失败，这样就阻塞了页面中其他资源的下载进程，而且最终加载到的内容是无效的，因此要尽量避免；

```xml
       <!--不推荐-->
       <img src="" alt="photo" >
       <a href="">点击链接</a>
```

（5）为HTML指定Cache-Control或Expires：

   为HTML内容设置Cache-Control 或 Expires可以将HTML内容缓存起来，避免频繁向服务器端发送请求，在页面中的Cache-Control 或 Expires头部有效时，浏览器将直接从缓存中读取内容，不再向服务器端发送请求；

```xml
       <meta http-equiv="Cache-Control" content="max-age=7200">
       <meta http-equiv="Expires" content="Mon,20Jul201623:00:00GMT">
```

（6）合理设置Etag和Last-Modified：

   合理设置Etag 和 Last-Modified使用浏览器缓存，对于未修改的文件，静态资源服务器会向浏览器端返回304，让浏览器从缓存中读取文件，减少Web资源下载的带宽消耗并降低服务器负载；

```xml
	<meta http-equiv="last-modified" content="Sun,05 Nov 2017 13:45:57 GMT">
```

（7）减少页面重定向：

   页面每次重定向都会延长页面内容返回的等待延时，一次重定向大约需要200毫秒不等的时间开销（无缓存），为了保证用户尽快看到页面内容，要尽量避免页面重定向；

（8）使用静态资源分域存放来增加下载并行数：

   浏览器在同一时刻向同一域名请求文件的并行下载数是有限的，因此可以利用多个域名的主机来存放不同的静态资源，增大页面加载时资源的并行下载数，缩短页面资源加载的时间，通常根据多个域名来分别存储JavaScript、CSS和图片文件；

```xml
     <link rel="stylesheet" href="//cdn1.domain.com/path/main.css" >
     <script src="//cdn2.domain.com/path/main.js"></script>
```

（9）使用静态资源CDN来存储文件：
    如果条件允许，可以利用CDN网络加快同一个地理区域内重复静态资源文件的响应下载速度，缩短资源请求时间；

（10）使用CDN Combo下载传输内容：

   CDN Combo是在CDN服务器端将多个文件请求打包成一个文件的形式来返回的技术，这样可以实现HTTP连接传输的一次性复用，减少浏览器的HTTP请求数，加快资源下载速度，例如同一个域名CDN服务器上的a.js，b.js，c.js就可以按如下方式在一个请求中下载：



```xml
<script src="//cdn.domain.com/path/a.js,b.js,c.js"></script>
```

（11）使用可缓存的AJAX：

   对于返回内容相同的请求，没必要每次都直接从服务端拉取，合理使用AJAX缓存能加快AJAX响应速度并减轻服务器压力；



```tsx
$.ajax({
     url: url,
     type: 'get',
     cache: true, //推荐使用缓存
     data: {},
     success() {},
     error() {}
    });
```

（12）使用GET来完成AJAX请求：

   使用XMLHttpRequest时,浏览器中的POST方法会发起两次TCP数据包传输，首先会发送文件头，然后发送HTTP正文数据，而使用GET时只发送头部，所以在拉取服务端数据时使用GET请求效率更高；



```tsx
$.ajax({
  url: url,
  type: 'get', //推荐使用get完成请求
  data: {},
  success() {},
  error() {}
});
```

（13）减少Cookie的大小并进行Cookie隔离：

   HTTP请求通常默认带上浏览器端的Cookie一起发送给服务器，所以在非必要的情况下，要尽量减少Cookie来减少HTTP请求的大小，对于静态资源，尽量使用不同的域名来存放，因为Cookie默认是不能跨域的，这样就做到了不同域名下静态资源请求的Cookie隔离；

（14）缩小favicon.ico并缓存：

   有利favicon.ico的重复加载，因为一般一个Web应用的favicon.ico是很少改变的；

（15）推荐使用异步JavaScript资源：

   异步的JavaScript资源不会阻塞文档解析，所以允许在浏览器中优先渲染页面，延后加载脚本执行，例如JavaScript的引用可以如下设置，也可以使用模块化加载机制来实现；其中使用async时，加载和渲染后续文档元素的过程和main.js的加载与执行是并行的；使用defer时，加载后续文档元素的过程和main.js的加载是并行的，但是main.js的执行要在页面所有元素解析完成之后才开始执行；



```xml
<script src="main.js" defer></script>
<script src="main.js" async></script>
```

（16）消除阻塞渲染的CSS及JavaScript：

   对于页面中加载时间过长的CSS或JavaScript文件，需要进行合理拆分或延后加载，保证关键路径的资源能快速加载完成；

（17）避免使用CSS import引用加载CSS：

   CSS中的@import可以从另一个样式文件中引入样式，但应该避免这种用法，因为这样会增加CSS资源加载的关键路径长度，带有＠import的CSS样式需要在CSS文件串行解析到＠import时才会加载另外的CSS文件，大大延后CSS渲染完成的时间；

```xml
<!--不推荐-->
<style>
@import "path/main.css";
</style>

<!--推荐-->
<link rel="stylesheet" href="//cdn1.domain.com/path/main.css" >
```

##### **2、页面渲染类**

（1）把CSS资源引用放到HTML文件顶部：

   一般推荐将所有CSS资源指定在HTML文档<head>中，这样浏览器可以优先下载CSS并尽早完成页面渲染；

（2）JavaScript资源引用放到HTML文件底部：

   JavaScript资源放到HTML文档底部可以防止JavaScript的加载和解析执行对页面渲染造成阻塞，由于JavaScript资源默认是解析阻塞的，除非被标记为异步或者通过其他的异步方式加载，否则会阻塞HTML DOM解析和CSS渲染过程；

（3）尽量预先设定图片等大小：

   在加载大量的图片元素时，尽量预先限定图片的尺寸大小，否则在图片加载过程中会更新图片的排版信息，产生大量的重排；

（4）不要在HTML中直接缩放图片：

   在HTML中直接缩放图片会导致页面内容的重排重绘，此时可能会使页面中的其他操作产生卡顿，因此要尽量减少在页面中直接进行图片缩放；

（5）减少DOM元素数量和深度：

   HTML中标签元素越多，标签的层级越深，浏览器解析DOM并绘制到浏览器中所花的时间就越长，所以应尽可能保持DOM元素简洁和层级较少；

```xml
     <!--不推荐-->
     <div>
       <span>
           <a href="javascript:void(0);">
               <img src="./path/photo.jpg" alt="图片">
           </a>
        </span>
     </div>
     <!--推荐-->
     <img src="./path/photo.jpg" alt="图片" >
```

（6）尽量避免在选择器末尾添加通配符：

   CSS解析匹配到渲染树的过程是从右到左的逆向匹配，在选择器末尾添加通配符至少会增加一倍多计算量；

（7）减少使用关系型样式表的写法：

   直接使用唯一的类名即可最大限度的提升渲染引擎绘制渲染树的效率；

（8）尽量减少使用JS动画：

   JS直接操作DOM极容易引起页面的重排；

（9）CSS动画使用translate、scale代替top、height：

   尽量使用CSS3的translate、scale属性代替top、left和height、width，避免大量的重排计算；

（10）尽量避免使用<table>、<iframe>：

     <table>内容的渲染是将table的DOM渲染树全部生成完并一次性绘制到页面上的，所以在长表格渲染时很耗性能，应该尽量避免使用它，可以考虑使用列表元素<ul>代替；尽量	 使用异步的方式动态添加iframe，因为iframe内资源的下载进程会阻塞父页面静态资源的下载与CSS及HTML DOM的解析；

（11）避免运行耗时的JavaScript：

   长时间运行的JavaScript会阻塞浏览器构建DOM树、DOM渲染树、渲染页面，所以任何与页面初次渲染无关的逻辑功能都应该延迟加载执行，这和JavaScript资源的异步加载思路是一致的；

（12）避免使用CSS表达式或CSS滤镜：

   CSS表达式或CSS滤镜的解析渲染速度是比较慢的，在有其他解决方案的情况下应该尽量避免使用；

```swift
     //不推荐
     .opacity{
         filter : progid : DXImageTransform.Microsoft.Alpha( opacity = 50 );
     }
```

（13）减少 DOM的回流

​		1、放弃传统操作dom的时代，基于vue/react开始数据影响视图模式

​				mvvc/mvc/virtual dom/dom diff...

​		2、分离读写操作（现代的浏览器都有渲染队列的机制，`如果操作dom代码的下一行还是操作dom,那么只会引发一次回流`）

​				offsetTop、offsetLeft...

​		3、样式集中改变

​				div.style.cssText = 'width:20px;height:20px'

​				div.className = 'box'

​				不要一条一条地修改DOM的样式，预先定义好class，然后修改DOM的className

​		4、缓存布局信息

​			<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210103202306210.png" alt="image-20210103202306210" style="zoom:80%;" />

​		5、文档碎片（documentFragment) ----- vue使用了该种方式提升性能			

```
		//1、创建文档碎片
		let frg = document.createDocumentFragment()
		for(let i = 0;i<5;i++){
			let nweLi = document.createElement('li');
			newLi.innerHTML = i;
			//创建的li放到文档碎片中，这样不会引发回流，文档碎片只是一个临时的容器
			frg.appendChild(newLi)
		}
		//一次性把内容放到容器中，这样只会引发一次回流
		box.appendChild(frg)
		//销毁文档碎片容器
		frg = null
```

​		6、字符串拼接		

```
		let str = ``;
		for(let i = 0;i<5;i++){
			str+=`<li>${i}</li>
		}
		box.innerHTML = str
```

​		7、动画效果应用到position属性为absolute或fixed的元素上（脱离文档流）

​		8、CSS3硬件加速（GPU加速）

​			transform:translateZ(0)

​			比起考虑如何减少回流重绘，我们更期待的是，根本不要回流重绘；transform\opacity\filters...这些属性会触发硬件加速，不会

​			引发回流和重绘......

​			可能引发的坑：过多使用会占用大量内存，性能消耗严重、有时候会导致字体模糊等

```
		//这样会引发回流
		//box.style.left = '100px'
		//这样会触发赢家加速，不会引发回流
		box.style.transform = 'translateX(100px)'
```

​		9、避免table布局和使用css的javascript表达式

​		10、将DOM离线后再修改

​				由于display属性为name的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。

​				如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发两次

##### 3、函数防抖

> 概念：延迟要执行的动作，若在延时的这段时间内，再次触发了，则取消之前开启的动作，重新计时
>
> 举例：电脑无操作一分钟后会进入休眠，当第40秒鼠标被移动了以下，重新计时1分子
>
> 实现：定时器
>
> 应用：搜索时等用户完整输入内容后再发送查询请求

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <input type="text" id="user_input">
  <button id="btn">搜索</button>
  <script>
    let input = document.getElementById("user_input")
    let id
    input.addEventListener('keyup',()=>{
      // 1、获取用户的输入
      let data = input.value
      clearTimeout(id)
      id = setTimeout(() => {
          mockAjax(data)
      }, 300);
    })
    function mockAjax(data) {
      console.log(`sendAjax------${data}`);
    }
  </script>
</body>
</html>
```

##### 4、函数节流

> 概念：设定一个特定的时间，让函数在特定的时间内只执行一次，不会频繁切换
>
> 举例：fps游戏，鼠标按住不松手，子弹也不会连成一条线
>
> 实现：定时器、标识
>
> 需求：在鼠标滚轮滚动的时候，每隔2秒钟，打印一次

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    body{
      height: 4000px;
    }
  </style>
</head>
<body>
  <div></div>
  <script>
    let flag = true
    document.onscroll = function () {
      if(flag){
        console.log(1);
        flag = false
        setTimeout(() => {
          flag = true
        }, 2000);
      }
    }
  </script>
</body>
</html>
```

防抖和节流的主要区别是：

​		**防抖是两个动作之间的时间间隔有限制，节流是在一定时间内执行次数的限制**

##### 5、请求动画帧

> window.requestAnimationFrame()

1、window.requestAnimationFrame()

​		说明：该方法会告诉浏览器在重绘之前调用你所指定的函数

​		1、参数：该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用

​						回调函数会被自动传入一个参数，DOMHighResTimeStamp,标识requestAnimationFrame()开始触发回调函数的当前时间

​		2、返回值：

​						一个long整数，也成为请求ID,是个非零值，是回调列表中唯一的标识，没别的意义。

2、window.cancelAnimationFrame(requestId)

​		取消一个先前通过调用window.requestAnimationFrame()方法添加到计划中的动画帧请求。

​		requestID是先前通过调用window.requestAnimationFrame()方法时返回的ID

#### **二、移动端优化策略**

**1、网络加载类**

（1）首屏数据请求提前，避免JavaScript文件加载后才请求数据：

   为了进一步提升页面加载速度，可以考虑将页面的数据请求尽可能提前，避免在JavaScript加载完成后才去请求数据，通常数据请求是页面内容渲染中关键路径最长的部分，而且不能并行，所以如果能将数据请求提前，可以极大程度缩短页面内容的渲染完成时间；

（2）首屏加载和按需加载，非首屏内容滚屏加载，保证首屏内容最小化：

   由于移动端网络速度相对较慢，网络资源有限，因此为了尽快完成页面内容的加载，需要保证首屏加载资源最小化，非首屏内容使用滚动的方式异步加载，一般推荐移动端页面首屏数据展示延时最长不超过3秒，目前中国联通3G的网络速度为338KB/s (2.71Mb/s)，所以推荐首屏所有资源大小不超过1014KB，即大约不超过1MB；

（3）模块化资源并行下载：

   在移动端资源加载中，尽量保证JavaScript资源并行加载，主要指的是模块化JavaScript资源的异步加载，例如AMD的异步模块，使用并行的加载方式能够缩短多个文件资源的加载时间；

（4）inline首屏必备的CSS和JavaScript：

   通常为了在HTML加载完成时能使浏览器中有基本的样式，需要将页面渲染时必备的CSS和JavaScript通过<script>或<style>内联到页面中，避免页面HTML载入完成到页面内容展示这段过程中页面出现空白；



```xml
<!DOCTYPE html>

<head>
  <meta charset="UTF-8">
  <title>样例</title>
  <meta>
  <style>
    /*必备的首屏CSS*/
    html,
    body {
      margin: 0;
      padding: 0;
      background-color: #ccc;
    }
  </style>
</head>

<body>
</body>

</html>
```

（5）meta dns prefetch设置DNS预解析：

   设置文件资源的DNS预解析，让浏览器提前解析获取静态资源的主机IP，避免等到请求时才发起DNS解析请求，通常在移动端HTML中可以采用如下方式完成：

```xml
<!--cdn域名预解析-->
<meta http-equiv="x-dns-prefetch-control" content="on" >
<link rel="dns-prefetch" href="//cdn.domain.com" >
```

（6）资源预加载：

   对于移动端首屏加载后可能会被使用的资源，需要在首屏完成加载后尽快进行加载，保证在用户需要浏览时已经加载完成，这时候如果再去异步请求就显得很慢；

（7）合理利用MTU策略：

   通常情况下，我们认为TCP网络传输的最大传输单元（Maximum Transmission Unit，MTU）为 1500B，即一个 RTT（Round-Trip Time，网络请求往返时间）内可以传输的数据量最大为1500字节，因此在前后端分离的开发模式中，尽量保证页面的HTML内容在1KB以内，这样整个HTML的内容请求就可以在一个RTT内请求完成，最大限度地提高HTML载入速度；

##### 2、缓存类

（1）合理利用浏览器缓存：

   除了上面所说的Cache-Control、Expires、Etag 和 Last-Modified来设置HTTP缓存外，在移动端还可以使用localStorage等来保存AJAX返回的数据，或者使用localStorage保存CSS或JavaScript静态资源内容，实现移动端的离线应用，尽可能减少网络请求，保证静态资源内容的快速加载；

（2）静态资源离线方案：

   对于移动端或Hybrid应用，可以设置离线文件或离线包机制让静态资源请求从本地读取，加快资源载入速度，并实现离线更新；

（3）尝试使用AMP HTML

   AMP HTML可以作为优化前端页面性能的一个解决方案，使用AMP Component中的元素来代替原始的页面元素进行直接渲染；



```xml
<!--不推荐-->
<video width="400" height="300" src="//www.domain.com/videos/myvideo.mp4"
poster="path/poster.jpg">
<div fallback>
    <p>Your browser doesn’t support HTML5 video</p>
</div>
<source type="video/mp4" src="foo.mp4">
<source type="video/webm" src="foo.webm">
</video>

<!--推荐-->
<amp-video width="400" height="300" src="//www.domain.com/videos/myvideo.mp4" poster="path/poster.jpg">
<div fallback>
   <p>Your browser doesn’t support HTML5 video</p>
</div>
<source type="video/mp4" src="foo.mp4">
<source type="video/webm" src="foo.webm">
</amp-video>
```

（4）尝试使用PWA模式：

   PWA（Progressive Web Apps）是 Google 提出的用前沿的 Web 技术为网页提供 App 般使用体验的一系列方案；

##### 3、图片类

（1）图片压缩处理：

   在移动端，通常要保证页面中一切用到的图片都是经过压缩优化处理的，而不是以原图的形式直接使用的，因为那样很消耗流量，而且加载时间更长；

（2）使用较小的图片，合理使用base64内嵌图片：

   在页面使用的背景图片不多且较小的情况下，可以将图片转化成base64编码嵌入到HTML页面或CSS文件中，这样可以减少页面的HTTP请求数，需要注意的是，要保证图片较小，一般图片大小超过2KB就不推荐使用base64嵌入显示了；



```css
.class-name{
    background-image : url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAALCAMAAABxsOwqAAAAYFBMVEWnxwusyQukxQudwQyZvgyhxAyfwgyxzAsUHQGOuA0aJAERGAFIXwSTugyEqgtqhghQZgUwQQIpOQKbuguVtQuKrAuCowp2kQlheghTbQZHWQU7SwVAVgQ6TgQlLwMeKwFOemyQAAAAVElEQVQI1y3JVRaAIAAF0UconXbvf5ei8HfPDIQQhBAAFE10iKig3SLRNN4SP/p+N08VC0YnfIlNWtqIkhg/TPYbCvhqdHAWRXPZSp3g3CWZvVLXC6OJA3ukv0AaAAAAAElFTkSuQmCC');
}
```

（3）使用更高压缩比格式的图片：

   使用具有较高压缩比格式的图片，如webp（需要设计降级兼容方案）等，在同等图片画质的情况下，高压缩比格式的图片体积更小，能够更快完成文件传输，节省网络流量；



```xml
<img src="//cdn.domain.com/path/photo.webp" alt="webp格式图片" >
```

（4）图片懒加载：

   为了保证页面内容的最小化，加速页面的渲染，尽可能节省移动端网络流量，页面中的图片资源推荐使用懒加载实现，在页面滚动时动态载入图片；



```kotlin
<img data-src="//cdn.domain.com/path/photo.jpg" alt="懒加载图片" >
```

（5）使用MediaQuery 或 srcset根据不同屏幕加载不同大小图片：

   针对不同的移动端屏幕尺寸和分辨率，输出不同大小的图片或背景图能保证在用户体验不降低的前提下节省网络流量，加快部分机型的图片加载速度，这在移动端非常值得推荐；

（6）使用iconfont代替图片图标：

   在页面中尽可能使用iconfont来代替图片图标，这样做的好处有：使用iconfont体积较小，而且是矢量图，因此缩放时不会失真；可以方便地修改图片大小尺寸和呈现颜色；但是需要注意的是，iconfont引用不同webfont格式时的兼容性写法，根据经验推荐尽量按照以下顺序书写，否则不容易兼容到所有的浏览器上；

```css
@font-face{
   font-family:iconfont;
   src:url("./iconfont.eot");
   src:url("./iconfont.eot?#iefix") format("eot"),
   url("./iconfont.woff") format("woff"),
   url("./iconfont.ttf") format("truetype");
}
```

（7）定义图片大小限制：

   加载的单张图片一般建议不超过30KB，避免大图片加载时间长而阻塞页面其他资源的下载，因此推荐10KB以内，如果用户上传的图片过大，建议设置告警系统，帮助我们观察了解整个网站的图片流量情况，做出进一步的改善；

（8）强缓存策略：

   对于一些永远不会变的图片可以使用强缓存的方式缓存在用户的浏览器上；

##### 4、脚本类

（1）尽量使用id：

   选择器选择页面DOM元素时尽量使用id选择器，因为id选择器速度最快；

（2）合理缓存DOM对象：

   对于需要重复使用的DOM对象，要优先设置缓存变量，避免每次使用时都要从整个DOM树中重新查找；

```jsx
//不推荐
$('#mod.active').remove('active');
$('#mod.not-active').addClass('active');

//推荐
let $mod=$('#mod');
$mod.find('.active').remove('active');
$mod.find('.not-active').addClass('active');
```

（3）页面元素尽量使用事件代理，避免直接事件绑定：

   使用事件代理可以避免对每个元素都进行绑定，并且可以避免出现内存泄露及需要动态添加元素的事件绑定问题，所以尽量不要直接使用事件绑定；

```jsx
//不推荐
$('.btn').on('click',function(e){
   console.log(this);
});

//推荐
$('body').on('click','.btn',function(e){
   console.log(this);
});
```

（4）使用touchstart代替click：

   由于移动端屏幕的设计，touchstart事件和click事件触发时间之间存在300毫秒的延时，所以在页面中没有实现touchmove滚动处理的情况下，可以使用touchstart事件来代替元素的click事件，加快页面点击的响应速度，提高用户体验，但同时我们也要注意页面重叠元素touch动作的点击穿透问题；



```jsx
//不推荐
$('body').on('click','.btn',function(e){
    console.log(this);
});

//推荐
$('body').on('touchstart','.btn',function(e){
    console.log(this);
});
```

（5）避免touchmove、scroll连续事件处理：

   需要对touchmove、scroll这类可能连续触发回调的事件设置事件节流，例如设置每隔16ms（60帧的帧间隔为16.7ms，因此可以合理地设置为16ms）才进行一次事件处理，避免频繁的事件调用导致移动端页面卡顿；

```jsx
//不推荐
$('.scroller').on('touchmove','.btn',function(e){
  console.log(this);
});

//推荐
$('.scroller').on('touchmove','.btn',function(e){
  let self=this;
  setTimeout(function(){
    console.log(self);
  },16);
});
```

（6）避免使用eval、with，使用join代替连接符+，推荐使用ECMAScript6的字符串模板，这些都是一些基础的安全脚本编写问题，尽可能使用较高效率的特性来完成这些操作，避免不规范或不安全的写法；

（7）尽量使用ECMAScript6+的特性来编程：

   ECMAScript6+一定程序上更加安全高效，而且部分特性执行速度更快，也是未来规范的需要，所以推荐使用ECMAScript6+的新特性来完成后面的开发；

##### 5、渲染类

（1）使用Viewport固定屏幕渲染，可以加速页面渲染内容：

   一般认为，在移动端设置Viewport可以加速页面的渲染，同时可以避免缩放导致页面重排重绘；

（2）避免各种形式重排重绘：

   页面的重排重绘很耗性能，所以一定要尽可能减少页面的重排重绘，例如页面图片大小变化，元素位置变化等这些情况都会导致重排重绘；

（3）使用CSS3动画，开启GPU加速：

   使用CSS3动画时可以设置transform:translateZ(0) 来开启移动设备浏览器的GPU图形处理加速，让动画过程更加流畅，但需要注意的是，在Native WebView 下 GPU 加速有几率产生 App Crash；



```css
-webkit-transform:translateZ(0);
-ms-transform:translateZ(0);
-o-transform:translateZ(0);
transform:translateZ(0);
```

（4）合理使用Canvas 和 requestAnimationFrame：

   选择Canvas 或requestAnimationFrame等更高效的动画实现方式，尽量避免使用setTimeout、setInterval等方式来直接处理连续动画；

（5）SVG 代替图片：

   部分情况下可以考虑使用SVG 代替图片实现动画，因为使用SVG格式内容更小，而且SVG  DOM结构方便调整；

（6）不滥用float：

   在DOM渲染树生成后的布局渲染阶段，使用float的元素布局计算比较耗性能，所以尽量减少float的使用，推荐使用固定布局或flex-box弹性布局的方式来实现页面元素布局；

（7）不滥用web字体或过多font-size声明：

   过多的font-size声明会增加字体的大小计算，而且也没有必要；

（8）做好脚本容错：

   脚本容错可以避免非正常环境的执行错误影响页面的加载和不相关功能的使用；

##### 6、架构协议类

（1）尝试使用 SPDY 和 HTTP2：

   在条件允许的情况下可以考虑使用 SPDY 协议来进行文件资源传输，利用连接复用加快传输过程，缩短资源加载时间，HTTP2 在未来也是可以考虑尝试的；

（2）使用后端数据渲染：

   使用后端数据渲染的方式可以加快页面内容的渲染展示，避免空白页面的出现，同时可以解决移动端页面 SEO 的问题，如果条件允许，后端数据渲染是一个很不错的实践思路；

（3）使用 NativeView 代替 DOM 的性能劣势：

   可以尝试使用 NativeView 的 MNV＊ 开发模式来避免 HTML DOM 性能慢的问题，目前使用 MNV＊ 的开发模式已经可以将页面内容渲染体验做到接近客户端 Native 应用的体验了，但需要避免 js Framework 和 native Framework 的频繁交互；

## 	基础知识

### 开发环境

#### 编译器：

##### VSCode:

​	插件：	

##### HBuilder

### 				HTML

#### HTML简介

1. **什么是HTML？**

   超文本标记语言(Hypertext Markup Language)"超文本"指的就是页面内可以包含图片，链接，甚至音乐，程序等非文本元素。

2. **HTML发展历史**

   超文本标记语言（第一版）–在1993年6月作文互联网工程工作小组（IETF）工作草案发布（并非标准）。
   HTML2.0 --1995年11月作为RFC 1866发布，在RFC2854于2000年6月发布之后被宣布已经过时。
   HTML3.0 --1997年1月14日，W3C推荐标准。
   HTML4.0 --1997年12月18日，W3C推荐标准。
   HTML4.01（微小改进） --1999年12月24日，W3C推荐标准。
   HTML5.0 --2014年10月28日，W3C推荐标准。

   本文简要介绍HTML中的各种元素及其相关属性，读者需要有一个概念: HTML页面都是由基本元素及属性组成的。HTML页面的结构如下。

   ```
   <!DOCTYPE html>         //浏览器得知自己需要处理的内容是html
   <html lang="en">     //文档中html开始的部分，lang ="en“ 表示内容为英文， 可以省略写为 <html> 
       <head>                    //提供有关内档内容和标注信息的内容
       </head>
       <body>                //内部的内容即为网页中显示的内容
       </body>
   </html>
   ```

   HTML 文档主要分为 Head 部分 和 Body 部分 两个部分

#### HTML语法规范

1. HTML中不区分大小写，但是我们一般都使用小写

2. HTML中的注释不能嵌套

   比如：

   ```
   <！--
   这是注释
   <!--注释中的注释-->
   -->
   ```

3. HTML标签必须结构完整，要么成对出现要么是自结束标签

4. HTML标签可以嵌套，但是不能交叉嵌套

   比如：

   ```
   正确：<p> test <font> test </font> </p>      
   错误：<p> test <font> test  </p> </font> 
   ```

5、HTML标签中的属性必须有值，且值必须加引号（虽然你不写浏览器也会帮你加上，但是这不规范）

6、自结束标签加不加/都可以

#### 设置网站的图标（标题栏和收藏栏）

![img](https://img2020.cnblogs.com/blog/2029744/202009/2029744-20200920235428178-2102817218.png)

1.  在网站域名后面加上favicon.ico就可以获取网站logo了

   然后把favicon.ico文件放在网站根目录

![image-20201016152718782](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201016152718782.png)

再用

```
<link rel="icon" href="./favicon.ico">
```

引入就行了

![img](https://img2020.cnblogs.com/blog/2029744/202009/2029744-20200920235606848-391138220.png)

之后图标就有了

 要是想把普通图片转化为.ioc文件类型可以点击下面链接转换

http://www.bitbug.net/

#### HTML头部结构详解

HTML head 头部分的标签、元素有很多，涉及到浏览器对网页的渲染，SEO等等，而各个浏览器内核以及各个国内浏览器厂商都有些自己的标签元素,这就造成了很多差异性。移动互联网时代，head 头部结构，移动端的meta 元素，显得更为重要。了解每个标签的意义，写出满足自己需求的head 头标签，是本文的目的。本篇以[一丝的文章](https://github.com/yisibl/blog/issues/1)为基础，进行扩展总结介绍常用的head中各个标签、元素的意义以及使用场景。

1. **DOCTYPE**

   DOCTYPE(Document Type)，该声明位于文档中最前面的位置，处于html 标签之前，此标签告知浏览器文档使用哪种HTML 或者XHTML 规范。

   DTD(Document Type Definition) 声明以<!DOCTYPE> 开始，不区分大小写，前面没有任何内容，如果有其他内容(空格除外)会使浏览器在IE下开启怪异模式(quirks mode)渲染网页。公共DTD，名称格式为注册//组织//类型 标签//语言,注册指组织是否由国际标准化组织(ISO)注册，+表示是，-表示不是。组织即组织名称，如：W3C。类型一般是DTD。标签是指定公开文本描述，即对所引用的公开文本的唯一描述性名称，后面可附带版本号。最后语言是DTD语言的ISO 639语言标识符，如：EN 表示英文，ZH 表示中文。XHTML 1.0可声明三种DTD 类型。分别表示严格版本，过渡版本，以及基于框架的HTML 文档。

   - HTML 4.01 strict

     ```
     <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
     ```

   - HTML 4.01 Transitional

     ```
     <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
     ```

   - HTML 4.01 Frameset

     ```
     <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">
     ```

   - 最新HTML5 推出更加简洁的书写，它向前向后兼容，推荐使用。

     ```
     <!doctype html>
     ```

   在HTML中 `doctype` 有两个主要目的。

   - 对文档进行有效性验证。

     它告诉用户代理和校验器这个文档是按照什么DTD 写的。这个动作是被动的，每次页面加载时，浏览器并不会下载DTD 并检查合法性，只有当手动校验页面时才启用。

   - 决定浏览器的呈现模式

     对于实际操作，通知浏览器读取文档时用哪种解析算法。如果没有写，则浏览器则根据自身的规则对代码进行解析，可能会严重影响html 排版布局。浏览器有三种方式解析HTML文档。

     - 非怪异（标准）模式
     - 怪异模式
     - 部分怪异（近乎标准）模式
       关于IE浏览器的文档模式，浏览器模式，严格模式，怪异模式，DOCTYPE标签，可详细阅读[模式？标准！](http://padding.me/blog/2014/07/04/mode-or-standard/)的内容。

2. **charset**

   声明文档使用的字符编码，

   ```
   <meta charset="utf-8">
   ```

   html5 之前网页中会这样写：

   ```
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   ```

   这两个是等效的，具体可移步阅读http://stackoverflow.com/questions/4696499/meta-charset-utf-8-vs-meta-http-equiv-content-type，所以建议使用较短的，易于记忆。

3. **lang属性**

   简体中文

   ```
   <html lang="zh-cmn-Hans">
   ```

   繁体中文

   ```
   <html lang="zh-cmn-Hant">
   ```

4. **http-equiv**

   **优先使用 IE 最新版本和 Chrome**

   ```
   <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
   ```

   **360 使用Google Chrome Frame**

   ```
   <meta name="renderer" content="webkit">
   ```

   360浏览器就会在读取到这个标签后，立即切换对应的极速核。
   另外为了保险起见再加入

   ```
   <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
   ```

   这样写可以达到的效果是如果安装了Google Chrome Frame，则使用GCF来渲染页面，如果没有安装GCF，则使用最高版本的IE内核进行渲染。

5. **百度禁止转码**

   通过百度手机打开网页时，百度可能会对你的网页进行转码，脱下你的衣服，往你的身上贴狗皮膏药的广告，为此可在head内添加

   ```
   <meta http-equiv="Cache-Control" content="no-siteapp" />
   ```

6. **SEO优化部分**

   页面标题`<title>`标签(head头部必须)

   ```
   <title>your title</title>
   ```

   页面关键词keywords

   ```
   <meta name="keywords" content="your keywords">
   ```

   页面描述内容description

   ```
   <meta name="description" content="your description">
   ```

   定义网页作者author

   ```
   <meta name="author" content="author,email address">
   ```

   定义网页搜索引擎索引方式,robotterms是一组使用英文逗号「,」分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。

   ```
   <meta name="robots" content="index,follow">
   ```

7. **viewport**

   `viewport` 可以让布局在移动浏览器上显示的更好。
   通常会写

   ```
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   ```

   `width=device-width` 会导致 iPhone 5 添加到主屏后以 WebApp 全屏模式打开页面时出现黑边(http://bigc.at/ios-webapp-viewport-meta.orz)

   content 参数：

   1、width viewport 宽度(数值/device-width)

   2、height viewport 高度(数值/device-height)

   3、initial-scale 初始缩放比例

   4、maximum-scale 最大缩放比例

   5、minimum-scale 最小缩放比例

   6、user-scalable 是否允许用户缩放(yes/no)

   7、minimal-ui iOS 7.1 beta 2 中新增属性，可以在页面加载时最小化上下状态栏。这是一个布尔值，可以直接这样写：

   ```
   <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">
   ```

   而如果你的网站不是响应式的，请不要使用initial-scale或者禁用缩放。

   ```
   <meta name="viewport" content="width=device-width,user-scalable=yes">
   ```

   相关链接：[非响应式设计的viewport](http://www.qianduan.net/non-responsive-design-viewport.html)

   适配iPhone 6 和iPhone 6plus 则需要写：

   ```
   <meta name="viewport" content="width=375">
   <meta name="viewport" content="width=414">
   ```

   大部分4.7~5寸的安卓设备的viewport宽设为360px，iPhone 6上却是375px，大部分5.5寸安卓机器（比如说三星Note）的viewport宽为400，iPhone 6 plus 上是414px。

8. **favicon icon**

   ```
   <link rel="shortcut icon" type="image/ico" href="/favicon.ico" /> <!-- 添加 favicon icon -->
   ```

9. **移动端的meta**

   ```
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
     <meta name="apple-mobile-web-app-capable" content="yes" />
     <meta name="apple-mobile-web-app-status-bar-style" content="black" />
     <meta name="format-detection"content="telephone=no, email=no" />
     <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
     <meta name="apple-mobile-web-app-capable" content="yes" /><!-- 删除苹果默认的工具栏和菜单栏 -->
     <meta name="apple-mobile-web-app-status-bar-style" content="black" /><!-- 设置苹果工具栏颜色 -->
     <meta name="format-detection" content="telphone=no, email=no" /><!-- 忽略页面中的数字识别为电话，忽略email识别 -->
     <!-- 启用360浏览器的极速模式(webkit) -->
     <meta name="renderer" content="webkit">
     <!-- 避免IE使用兼容模式 -->
     <meta http-equiv="X-UA-Compatible" content="IE=edge">
     <!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 -->
     <meta name="HandheldFriendly" content="true">
     <!-- 微软的老式浏览器 -->
     <meta name="MobileOptimized" content="320">
     <!-- uc强制竖屏 -->
     <meta name="screen-orientation" content="portrait">
     <!-- QQ强制竖屏 -->
     <meta name="x5-orientation" content="portrait">
     <!-- UC强制全屏 -->
     <meta name="full-screen" content="yes">
     <!-- QQ强制全屏 -->
     <meta name="x5-fullscreen" content="true">
     <!-- UC应用模式 -->
     <meta name="browsermode" content="application">
     <!-- QQ应用模式 -->
     <meta name="x5-page-mode" content="app">
     <!-- windows phone 点击无高光 -->
     <meta name="msapplication-tap-highlight" content="no">
     <!-- 适应移动端end -->
   ```

#### 可替换元素

请问什么是可替换元素和非可替换元素，它们的差异是什么？并举例说明

　　前端面试中HTML的题目本来就最少，而且并不难，翻来覆去也就那几样。我们之前已经谈到过最经典的HTML语义化，今天就借此机会来谈谈可替换元素。

　　释义

　　什么是可替换元素？顾名思义，就是会被替换的元素。（尬笑……

　　比如一个典型的可替换元素img：

　　<img src=xxx.jpg>

　　我们并没有在img标签中写入任何内容，那它的内容从哪里来的呢？

　　是浏览器去下载src属性给到的图片，并用该图片资源替换掉img标签，而且浏览器在下载前并不知道图片的宽高。所以，可替换元素比较特殊，它的宽高是由其加载的内容决定的。（当然CSS可以覆盖其样式）

　　示例

　　还是用img标签举几个例子：

　　imgsrc="https://avatars2.githubusercontent.com/u/17703242?s=460&v=4"

　　该图片在页面中展现出来的话，就是图片本身本身的宽高。

　　img元素也支持width和height属性：

　　imgwidth="80"height="80"src="https://avatars2.githubusercontent.com/u/17703242?s=460&v=4"

　　此时该元素展现出来就是宽高为80像素。

　　如果我们再用CSS去覆盖其样式：

　　img{

　　width:60px;

　　height:60px;

　　}

　　该元素的展现即为60像素。

　　MDN的释义

　　看过上面的例子之后我们再来理解概念性的知识就比较容易了。

　　可替换元素（replacedelement）的展现效果不是由CSS来控制的。这些元素是一种外部对象，它们外观的渲染，是独立于CSS的。

　　简单来说，它们的内容不受当前文档的样式的影响。CSS可以影响可替换元素的位置，但不会影响到可替换元素自身的内容。

　　典型的可替换元素有<iframe><video><embed><img>，还有一些元素仅在特定情况下被作为可替换元素处理，比如<input>。

![img](https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=288940854,3852752120&fm=26&gp=0.jpg)![img](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2941711175,155850835&fm=26&gp=0.jpg)

#### HTML5

##### 音视频标签详解

**一、发展历：**

**早期：****<embed>+<object>+****文件**

 　问题：不是所有浏览器都支持，而且embed不是标准。

**现状：****Realplay****、****window media****、****Quick Time** **、****Flash**

　　问题：每个厂商每个标准，网站编码和格式也都不相同，flash的出现解决了面的问题，但是apple在07年决定任何设备将不再支持flash。

HTML5认为浏览器应该原生支持音视频，因为他们现在也是web中的一等公民了！

**二、视频格式的简单介绍**

1、**常见的视频格式**

视频的组成部分：画面、音频、编码格式

视频编码：H.264、Theora、VP8(google开源)

**常见的音频格式**

**音频**编码：ACC、MP3、Vorbis

2、HTML5支持的格式

HTML5能在完全脱离插件的情况下播放音视频但是不是所有格式都支持。HTML5支持的视频格式：

　　**Ogg** =带有Theora视频编码+Vorbis音频编码的Ogg文件    支持的浏览器:F、C、O  

　　**MEPG4**=带有H.264视频编码+AAC音频编码的MPEG4文件   支持的浏览器: S、C　　　　

　　**WebM**=带有VP8视频编码+Vorbis音频编码的WebM格式    支持的浏览器: I、F、C、O

**三、<Video>**

1.**标签的使用：**

```
	<video src="文件地址" controls="controls"></video>
```

IE9以上才支持HTML5，对于不支持的浏览器应该有友好的提示：

```
     <video src="文件地址" controls="controls">
             您的浏览器暂不支持video标签。播放视频
     </ video >
```

再优化：让video标签载入多种不同的音频格式，让浏览器选择他支持的格式，第一个找到了播放第一条，没找到找第二条，以此类推，最后还没找到给出提示不支持

```
    <video  controls="controls"  width="600">
        <source src="movie.ogg" type="video/ogg" >
        <source src="move.mp4" type="video/mp4" >
        您的浏览器暂不支持video标签。播放视频
    </ video >
```

2.**Video标签的常见属性**

![img](https://images0.cnblogs.com/i/591234/201403/291118416728898.png)

```
     <video src="movie.ogg" controls="controls" Loop="Loop" poster="PLMM.jpg" id="video">
                 您的破浏览器都是古董早该换了，不然休想看我们的激情小电影。
     </video>
```

3.**Video的API方法**

![img](https://images0.cnblogs.com/i/591234/201403/291138373121025.png)

4.**Video的API属性**

![img](https://images0.cnblogs.com/i/591234/201403/291150419375014.png)![img](https://images0.cnblogs.com/i/591234/201403/291200432347279.png)

![img](https://images0.cnblogs.com/i/591234/201403/291248234223811.png)

```
<body>
    <video src="movie.webm" controls="controls" id="video">
            您的破浏览器都是古董早该换了，不然休想看我们的激情小电影。
    </video>
    <br />
    <button onClick="bofang()">播放</button>
    <button onClick="zanting()">暂停</button>
     <button onClick="kuaijin()">快进</button>
     <button onClick="kuaitui()">快退</button>
     <button onClick="jingyin(this)">静音</button>
     <button onClick="jiansu()">减速</button>
     <button onClick="jiasu()">加速</button>
     <button onClick="normal()">正常播放</button>
      <button onClick="up()">增大音量</button>
       <button onClick="down()">减小音量</button>
    <script>
        //获取对应的video标签
        var video = document.getElementById('video');
        //播放方法
        function bofang(){
            video.play();
        }
        //暂停方法
        function zanting(){
            video.pause();
        }
        //快进按钮
        function kuaijin(){
            video.currentTime+=10;//currentTime该属性是获取当前播放的时间，加加上10就快进10秒
        }
        //快退
        function kuaitui(){
            video.currentTime-=10;
        }
        //静音
        function jingyin(obj){
            if(video.muted){
                obj.innerHTML='静音';
                video.muted=false;
            }else{
                obj.innerHTML='关闭静音';
                video.muted=true;
            }
        }
        //加速播放(快3倍) //要想慢3倍，应该是3分之1，因为当前是1
        function jiansu(){
            video.playbackRate = 1/3; 
        }
        //减速播放(慢3倍)
        function jiasu(){
            video.playbackRate=3;
        }
        //正常播放
        function normal(){
            video.playbackRate=1;
        }
        //调大音量,音量值的范围是0到1
        function up(){
            video.volume+=0.2;
        }
        //调小声音
        function down(){
            video.volume-=0.2;
        }
    </script>
</body>
</html>
```

5.**Video的常用事件**

![img](https://images0.cnblogs.com/i/591234/201403/291330210008109.png)

![img](https://images0.cnblogs.com/i/591234/201403/291330472971076.png)

 **1、获取视频时间长度**

当视频载入video后，使用 onloadedmetadata 事件获取视频的时间长度。

```
video.onloadedmetadata = function () { 
var vLength = video.duration; 
console.log(vLength); 
} 
```

**2、当前视频的播放进度**

当视频开始播放时，可以使用 ontimeupdate 事件获取视频当前播放的进度。当video对象的 currentTime 属性发生改变时触发 ontimeupdate 事件。currentTime 属性是浮点小数，可取到 12 位数的小数位数。

```
 video.ontimeupdate = function () { 
var vTime = video.currentTime; 
console.log(vTime); 
}; 
```

**四、HTML5支持的音频格式**

HTML5在不使用插件的情况下也可以原生的支持音频格式文件的播放，当然支持格式是有限的

HTML5支持的音频格式：

　　Ogg   免费 支持的浏览器:C、F、O

　　MP3   收费 支持的浏览器: I、C、S

　　Wav   收费 支持的浏览器: F、O、S

 **五、<audio>**

1.标签的使用

```
	<audio  src="文件地址" controls="controls"></audio>
```

IE9以上才支持HTML5，对于不支持的浏览器应该有友好的提示：

```
     <audio src="文件地址" controls="controls">
         您的浏览器暂不支持audio标签。播放视频
     </ audio >
```

再优化：让video标签载入多种不同的音频格式，让浏览器选择他支持的格式，第一个找到了播放第一条，没找到找第二天，以此类推，最后还没找到给出提示不支持

```
     < audio controls="controls"  >
         <source src="happy.MP3" type="video/mp3" >
         <source src="happy.ogg" type="video/ogg" >
         您的浏览器暂不支持audio标签。播放视频
     </ audio>
```

audio的常见属性

![img](https://images0.cnblogs.com/i/591234/201403/291346200006996.png)

该标签除了一些属性不同外，其他API方法都是一样

### 		CSS

### 		Javascript

#### 简介

> JavaScript 是一门`跨平台、面向对象的脚本语言`，它能使网页可交互（例如拥有复杂的动画，可点击的按钮，通俗的菜单等）。另外还有高级的服务端Javascript版本，例如Node.js，它可以让你在网页上添加更多功能，不仅仅是下载文件（例如在多台电脑之间的协同合作）。在宿主环境（例如 web 浏览器）中， JavaScript 能够通过其所连接的环境提供的编程接口进行控制。
>
> JavaScript 和 Java 有一些共性但是在另一些方面有着根本性区别。JavaScript语言类似 Java 但是并`没有 Java 的静态类型和强类型检查特性`。JavaScript 遵循了 Java 的表达式语法，命名规范以及基础流程控制，这也是 JavaScript 比 LiveScript 更名的原因。
>
> 与 Java 通过声明的方式构建类的编译时系统不同，JavaScript 采用基于少量的数据类型如数字、布尔、字符串值的运行时系统。`JavaScript 是一种基于原型而不是基于类的基于对象(object-based)语言`；也就是说，独立对象的继承是可以改变的。 JavaScript 支持匿名函数。 函数也可以作为对象的属性被当做宽松的类型方式执行。
>
> 与 Java 相比，Javascript 是一门形式自由的语言。你不必声明所有的变量，类和方法。你不必关心方法是否是公有、私有或者受保护的，也不需要实现接口。无需显式指定变量、参数、方法返回值的数据类型。
>
> Java 是基于类的编程语言，设计的初衷就是为了确保快速执行和类型安全。类型安全，举个例子，你不能将一个 Java 整数变量转化为一个对象引用，或者由Java字节码访问专有存储器。Java基于类的模型，意味着程序包含专有的类及其方法。Java的类继承和强类型要求紧耦合的对象层级结构。这些要求使得Java编程比JavaScript要复杂的多。
>
> 相比之下，JavaScript 传承了 HyperTalk 和 dBASE 语句精简、动态类型等精髓，这些脚本语言为更多开发者提供了一种语法简单、内置功能强大以及用最小需求创建对象的编程工具。
>

`注：`强类型：偏向于不容忍隐式类型转换。譬如说haskell的int就不能变成double

​	   弱类型：偏向于容忍隐式类型转换。譬如说C语言的int可以变成double

​	   静态类型：编译的时候就知道每一个变量的类型，因为类型错误而不能做的事情是语法错误。

​	   动态类型：编译的时候不知道每一个变量的类型，因为类型错误而不能做的事情是运行时错误。譬如说你不能对一个数字a写a[10]当数组用。

##### JavaScript是单线程

JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。

JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，`假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？`

`所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变`。

`为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。`

##### 任务队列

单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。

如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。

JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。

于是，`所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）`。`同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行（不会直接进入，而是按队列的顺序遍历，如果符合执行条件就把异步任务的回调函数添加到主线程执行，否则继续在任务队列等待）。`

具体来说，异步执行的运行机制如下。（同步执行也是如此，因为它可以被视为没有异步任务的异步执行。）

```
（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。

（2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。

（3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。

（4）主线程不断重复上面的第三步。
```

下图就是主线程和任务队列的示意图。

![任务队列](http://www.ruanyifeng.com/blogimg/asset/2014/bg2014100801.jpg)

只要主线程空了，就会去读取"任务队列"，这就是JavaScript的运行机制。这个过程会不断重复。

##### 事件和回调函数

"任务队列"是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在"任务队列"中添加一个事件，表示相关的异步任务可以进入"执行栈"了。主线程读取"任务队列"，就是读取里面有哪些事件。

"任务队列"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入"任务队列"，等待主线程读取。

`所谓"回调函数"（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。`

`"任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，"任务队列"上第一位的事件就自动进入主线程。但是，由于存在后文提到的"定时器"功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。`

##### Event Loop

主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。

为了更好地理解Event Loop，请看下图（转引自Philip Roberts的演讲[《Help, I'm stuck in an event-loop》](http://vimeo.com/96425312)）。

![Event Loop](http://www.ruanyifeng.com/blogimg/asset/2014/bg2014100802.png)

上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在"任务队列"中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取"任务队列"，依次执行那些事件所对应的回调函数。

执行栈中的代码（同步任务），总是在读取"任务队列"（异步任务）之前执行。请看下面这个例子。

```javascript
    var req = new XMLHttpRequest();
    req.open('GET', url);    
    req.onload = function (){};    
    req.onerror = function (){};    
    req.send();
```

上面代码中的req.send方法是Ajax操作向服务器发送数据，它是一个异步任务，意味着只有当前脚本的所有代码执行完，系统才会去读取"任务队列"。所以，它与下面的写法等价。

```javascript
    var req = new XMLHttpRequest();
    req.open('GET', url);
    req.send();
    req.onload = function (){};    
    req.onerror = function (){};   
```

也就是说，指定回调函数的部分（onload和onerror），在send()方法的前面或后面无关紧要，因为它们属于执行栈的一部分，系统总是执行完它们，才会去读取"任务队列"。

##### 定时器

除了放置异步任务的事件，"任务队列"还可以放置定时事件，即指定某些代码在多少时间之后执行。这叫做"定时器"（timer）功能，也就是定时执行的代码。

定时器功能主要由setTimeout()和setInterval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。以下主要讨论setTimeout()。

setTimeout()接受两个参数，第一个是回调函数，第二个是推迟执行的毫秒数。

```javascript
console.log(1);
setTimeout(function(){console.log(2);},1000);
console.log(3);
```

上面代码的执行结果是1，3，2，因为setTimeout()将第二行推迟到1000毫秒之后执行。

如果将setTimeout()的第二个参数设为0，就表示当前代码执行完（执行栈清空）以后，立即执行（0毫秒间隔）指定的回调函数。

```javascript
setTimeout(function(){console.log(1);}, 0);
console.log(2);
```

上面代码的执行结果总是2，1，因为只有在执行完第二行以后，系统才会去执行"任务队列"中的回调函数。

总之，setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在"任务队列"的尾部添加一个事件，因此要等到同步任务和"任务队列"现有的事件都处理完，才会得到执行。

HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。另外，对于那些DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout()。

需要注意的是，setTimeout()只是将事件插入了"任务队列"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。

#### 基本语法

##### JS中的基本类型和引用类型

###### 基本数据类型

> Undefined、Null、Boolean、Number、String、Symbol

（1）基本类型的访问是按值访问的，就是说你可以操作保存在变量中的实际的值

（2）我们不能给基本类型添加属性和方法

（3）**基本类型的变量是存放在栈区的（栈区指内存里的栈内存），**栈区包括了 **变量的标识符**和**变量的值。**

![img](https://pic3.zhimg.com/80/v2-bd008aa41a32aa00e12dfbcae6fadf7e_720w.jpg)

**基本类型值传递** 

在函数接收基本类型值时，会在该函数内部栈中创建一个一模一样的变量,且两个参数互不影响，为了验证这一正确性，如下

```
	function fun(a) {
        a = 666
        console.log(a) //666
    }
    var num = 555
    fun(num)
    console.log(num) //555
```



###### 引用数据类型

> Object、Array、RegExp、Date、Function

（1）引用类型的值是按引用访问的。

（2）引用类型可以拥有属性和方法，并且是可以动态改变的。

（3）**引用类型的存储需要内存的栈区和堆区（堆区是指内存里的堆内存）共同完成，栈区内存保存 变量标识符 和 指向堆内存中该对象的指针**

![img](https://pic2.zhimg.com/80/v2-e74aa0ddeb46d7ca059920b720739621_720w.jpg)

**`引用类型值传递`** 

`当引用类型作为参数传递时，传递到函数内部的不是该参数的值，而是该参数在内存中的引用地址，这和引用类型的定义完全吻合。` 

`所以当引用类型作为参数传递被改变时，另一个值也会发生了改变`。如下

```
 function fun1(obj) {
        obj.name = '王二'
        obj.age = 20
        console.log(obj) //{name:'王二',age:20}
    }
    var o = {
        name: '张三',
        age: 18
    }
    fun1(o)
    console.log(o) //{name:'王二',age:20}
```

由于函数也是引用类型，所以利用这个特性我们可以形成回调函数：

```
 function afun(are, callback) { //目标函数
        are++
        callback(are)
    }
    var d = 2
    afun(d, function(res) {
        console.log(res) //3
    })
```



##### 类型转换

> JavaScript 是一种动态类型的语言，在执行运算操作的过程中，有时需要转换操作数的类型。在 JavaScript 中，数据类型的转换有：隐式类型转换和强制类型转换（也叫显式类型转换）两种方式。

###### 隐式类型转换

> 隐式类型转换会自动根据运算符进行类型转换。隐式类型转换的情况主要有以下几种。

1) 如果表达式中同时存在字符串类型和非数字类型和数字类型的操作数，而运算符使用加号`+`，此时 JavaScript 会自动将数字转换成字符串。例如：

```
     alert("姑娘今年" + 18);   //结果：姑娘今年18
     alert("15"+5);   //结果：155
```

​	如果`+ -`只有一边有操作数时，字符串会自动转换成数字。如果变量不能转换，它仍然会是一个数字，但值为 NaN (不是一个数字):例如：

```
     let str = '1'
     console.log(typeof str); //String
     console.log(+str);       // 1
     console.log(typeof +str);//Number
     console.log(-str);       //-1
     console.log(typeof -str);//Number
     console.log(-'a')        //NaN
     console.log(typeof -'a') //Number
```

2) 如果表达式运算符为`-、*、/、%`中的任意一个，此时 JavaScript 会自动将字符串转换成数字，对无法转换为数字的则转换为 NaN。例如：

```
     alert("30"/5);   //除运算，结果为：6
     alert("15"-5);   //减运算，结果为：10
     alert("20"*"a"); //乘运算，结果为：NaN
     alert("20"%"3"); //取模运算，结果为：2
```

3) 运算符为`++`或`--`时，JavaScript 会自动将字符串转换成数字，对无法转换为数字的则转换为 NaN。例如：

```
     var num1 = "6";
     var num2 = "6";
     var num3 = "a";
     alert(++num1);  //将字符串转换为数字再进行++运算，结果为：7
     alert(--num2);  //将字符串转换为数字再进行--运算，结果为：5
     alert(++num3);  //字符串无法转换为数字，结果为：NaN
```

4) 运算符为`>`或`<`时，当两个操作数一个为字符串，一个为数字时，JavaScript 会自动将字符串转换成数字。例如：

```
     alert('10'>9);  //将字符串转换为数字，按值进行比较，结果为：true
     alert('10'<9);  //将字符串转换为数字，按值进行比较，结果为：false
```

​	如果两个操作数均为字符串时，JavaScript会根据字符串的字符集序号来进行比较的，例如：

```
	 console.log('10'>'9'); //false
	 console.log('b'>'a');  //true
```

5) `!`运算符将其操作数转换为布尔值并取反。例如：

```
     alert(！0);    //对0取反，结果为：true
     alert(！100); //对非0数字取反，结果为：false
     alert(!"ok"); //对非空字符串取反，结果为：false
     alert(!"");  //对空字符串取反，结果为：true
```

6) 运算符为`==`时，当表达式同时包含字符串和数字时，JavaScript 会自动将字符串转换成数字。例如：

```
     var a = '2';
     var b = 2;
     alert(a == b); //按值比较，结果为：true
```

7) 当你尝试输出一个对象或一个变量时 JavaScript 会自动调用变量的 toString() 方法,下面方法是使用console.log(）输出才会调用toString()方			法：

```
     document.getElementById("demo").innerHTML = myVar;
     myVar = {name:"Fjohn"}  // toString 转换为 "[object Object]"
     myVar = [1,2,3,4]       // toString 转换为 "1,2,3,4"
     myVar = new Date()      // toString 转换为 "Fri Jul 18 2014 09:08:55 GMT+0200"
```

数字和布尔值也经常相互转换：

```
     console.log(typeof [1].toString());  //String
     console.log(typeof true.toString()); //String
     let a =123
     console.log(typeof a.toString());    //String
```

![image-20210128184901868](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210128184901868.png)

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201230160220960.png" alt="image-20201230160220960" style="zoom:150%;" />



###### 强制类型转换

> 从上面的介绍我们可以看到，JavaScript 可以自动根据运算的需要进行类型的转换。强制类型转换主要针对功能的需要或为了使代码变得清晰易读，人为地进行类型的转换。在 JavaScript 中，强制类型转换主要是通过调用全局函数 Number()、parseInt() 和 parseFloat() 来实现。

**1) 使用Number()函数将参数转换为一个数字**

使用格式如下：

```
	Number(value)	
```

**Number() 对参数 value 进行整体转换，当参数值中任何地方包含了无法转换为数字的符号时，转换失败，此时将返回 NaN，否则返回转换后的数字。**

Number() 对参数进行数字转换时，遵循以下一些规则：

- 如果参数中只包含数字时，将转换为十进制数字，忽略前导 0 以及前导空格；如果数字前面为`-`，`-`会保留在转换结果中；如果数字前面为`+`，转换后将删掉`+`号；

- 如果参数中包含有效浮点数字，将转换为对应的浮点数字，忽略前导 0 以及前导空格；如果数字前面为`-`，`-`会保留在转换结果中；如果数字前面为`+`，转换后将删掉`+`号；

- 如果参数中包含有效的十六进制数字，将转换为对应大小的十进制数字；

- 如果参数为空字符串，将转换为 0；

- 如果参数为布尔值，则将 true 转换为 1，将 false 转换为 0；

- 如果参数为 null，将转换为 0；

- `如果参数为 undefined，将转换为 NaN；`

- `如果参数为 Date 对象，将转换为从 1970 年 1 月 1 日到执行转换时的毫秒数；`

- `如果参数为函数、包含两个元素以上的数组对象以及除 Date 对象以外的其他对象，将转换为 NaN；`

- 如果在参数前面包含了除空格、`+`和`-`以外的其他特殊符号或非数字字符，或在参数中间包含了包括空格、`+`和`-`的特殊符号或非数字字符，将转换为 NaN。

  **转换示例：**

  ```
  alert(Number("0010"));  //去掉两个前导0，结果为：10
  alert(Number("+010"));  //去掉前导0和+，结果为：10
  alert(Number("-10"));  //转换后保留“-”号，结果为：-10
  alert(Number(''));      //空字符串的转换结果为：0
  alert(Number(true));   //布尔值true的转换结果为：1
  alert(Number(null));   //null值的转换结果为：0
  var d = new Date();      //创建一个Date对象
  alert(Number(d));     //转换Date对象，结果为1970.1.1至执行转换时的毫秒数：1511351635179
  alert(Number("100px"));   //参数中包含了不能转换为数字的字符px，结果为：NaN
  alert(Number("100 01"));  //参数中包含了空格，导致整个参数不能转换，结果为：NaN
  alert(Number("100-123")); //参数中包含了“-”，导致整个参数不能转换，结果为：NaN
  var a;                   //声明变量
  alert(Number(a));     //变量a没有赋值，因而a的值为undefined,转换undefined的结果为：NaN
  var fn = function (){alert(1);}; //创建一个函数对象
  alert(Number(fn));     //转换函数，结果为:NaN
  alert(Number(window)); //转换window对象，结果为:NaN
  ```

  从上述示例中，我们也可以看到，Number() 是从整体上进行转换的，任何一个地方含有非法字符，都将导致转换无法成功。接下来将介绍的两个函数与 Number() 不同的是，转换是从左到右逐位进行转换，任何一位无法转换时立即停止转换，同时返回已成功转换的值。

**2) 使用parseInt()函数将参数转换为一个整数**

使用格式如下：

```
	parseInt(stringNum,[radix])
```

stringNum 参数为需要转换为整数的字符串；radix 参数为 2～36 之间的数字，表示 stringNum 参数的进制数，取值为 10 时可省略。

parseInt() 的作用是将以 radix 为基数的 stringNum 字符串参数解析成十进制数。若 stringNum 字符串不是以合法的字符开头，则返回 NaN；`解析过程中如果遇到不合法的字符，将马上停止解析，并返回已经解析的值`。

parseInt() 在解析字符串为整数时，遵循以下规则：

- 解析字符串时，会忽略字符串前后的空格；如果字符串前面为`-`，`-`会保留在转换结果中；如果数字前面为`+`，转换后将删掉`+`号；

- 如果字符串前面为除空格、`+`和`-`以外的特殊符号或除 a～f（或 A～F）之外的非数字字符（`并且第二个参数需要标注为什么进制，否则一样返回NAN`)，，字符串将不会被解析，返回结果为 NaN；

- 在字符串中包含了空格、`+`、`-`和小数点“。”`等特殊符号或非数字的字符时，解析将在遇到这些字符时停止，并返回已解析的结果`；

- `如果字符串是空字符串，返回结果为 NaN。`

  **转换示例：**

  ```
  alert(parseInt("1101",2));  //以2为基数的1101字符串解析后的结果为：13
  alert(parseInt("a37f",16)); //以16为基数的a37f字符串解析后的结果为：41855
  alert(parseInt("123"));     //以10为基数的123字符串解析后的结果为：123
  alert(parseInt("  123"));   //字符串前面的空格会被忽略，结果为：123
  alert(parseInt("12 3"));    //字符串中包含了空格，解析到空格时停止，结果为12
  alert(parseInt("12.345")); //字符串中包含了小数点，解析到小数点时停止，结果为12
  alert(parseInt("xy123"));  //字符串前面包含了非数字字符“x”，无法解析，返回结果为：NaN
  alert(parseInt("123xy4")); //字符串中包含了非数字字符“xy”，解析到“x”时停止，结果为：123
  ```

  从上述示例我们可以看到，`parseInt() 解析浮点数时，小数部分数据会被截掉`，此时需要使用下面将介绍的 parseFloat()，而不能使用 parseInt()。

**3) 使用parseFloat()函数将参数转换为一个浮点数**

使用格式如下：

```
	parseFloat(stringNum)
```

stringNum 参数为需要解析为浮点型的字符串。

parseFloat() 的作用是将首位为数字的字符串转解析成浮点型数。若 stringNum 字符串不是以合法的字符开头，则返回 NaN；解析过程中如果遇到不合法的字符，将马上停止解析，并返回已经解析的值。

parseFloat() 在解析字符串为整数时，遵循以下规则：

- 解析字符串时，会忽略字符串前后的空格；如果字符串前面为`-`，`-`会保留在转换结果中；如果数字前面为`+`，转换后将删掉`+`号；如果字符串前面为小数点`.`转换结果会在小数点前面添加 0；

- 如果字符串前面为除空格、`+`、`-`和`。`以外的特殊符号，字符串将不会被解析，返回结果为 NaN；

- 在字符串中包含了空格、`+`和`-`等特殊符号或非数字的字符时，解析将在遇到这些字符时停止，并返回已解析的结果；

- 在字符串中包含两个以上为小数点时，`解析到第二个小数点时将停止解析，并返回已解析的结果；`

- `如果字符串是空字符串，返回结果为 NaN。`

  转换示例：

  ```
  alert(parseFloat("312.456"));//结果为：312.456
  alert(parseFloat("-3.12"));//字符串前面的“-”将保留，结果为：-3.12
  alert(parseFloat("+3.12"));//字符串前面的“-”将保留，结果为：3.12
  alert(parseFloat(".12"));//在小数点前面添加0，结果为：0.12
  alert(parseFloat("  3.12"));//截掉字符串前面的空格，结果为：3.12
  alert(parseFloat("312.4A56"));//字符串中包含非数字字符A，解析到A时停止，结果为：312.4
  alert(parseFloat("31 2.4A56"));//字符串中包含空格，解析到空格时停止，结果为：31
  alert(parseFloat("31.2.5"));//字符串中包含两个小数点，解析到第二个小数点时停止，结果为：31.2
  alert(parseFloat("a312.456"));//字符串前面为非数字字符a，解析无法进行，结果为：NaN
  ```

**4）Number对象的toFixed()方法把数字转换为字符串，结果的小数点后有指定位数的数字：**

​	toFixed() 方法可把 Number 四舍五入为指定小数位数的数字。

```
     var num = 5.56789;
     var n=num.toFixed(2);
     console.log(n)  //5.57
     console.log(typeof n)  //String
```

​	`注：toFixed()方法会按四舍五入处理最后一位数`

**5）使用String()把任何类型的数字、字母、变量、表达式转换为字符串**

​	转换示例：

```
     var test1 = new Boolean(1);
     var test2 = new Boolean(0);
     var test3 = new Boolean(true);
     var test4 = new Boolean(false);
     var test5 = new Date();
     var test6 = new String("999 888");
     var test7 = 12345;
     document.write(String(test1)+ "<br>");  //true
     document.write(String(test2)+ "<br>");	//false
     document.write(String(test3)+ "<br>");	//true
     document.write(String(test4)+ "<br>");	//false
     document.write(String(test5)+ "<br>");	//Wed Dec 30 2020 16:16:20 GMT+0800 (中国标准时间)
     document.write(String(test6)+ "<br>");	//999 888
     document.write(String(test7)+ "<br>");	//12345
```



##### 字符串

String 对象用于处理文本（字符串）。

String 对象创建方法： **new String()**。

**语法**

```
var txt = new String("string");
或者更简单方式：
var txt = "string";
```

**你可以使用索引位置来访问字符串中的每个字符：**

**你也可以在字符串添加转义字符来使用引号：**

```
     var x = 'It\'s alright';//It's alright
     var y = "He is called \"Johnny\"";//He is called "Johnny"
```

**特殊字符**

在 JavaScript 中，字符串写在单引号或双引号中。

因为这样，以下实例 JavaScript 无法解析：

 "We are the so-called "Vikings" from the north."

字符串 "We are the so-called " 被截断。

如何解决以上的问题呢？可以使用反斜杠 (\) 来转义 "Vikings" 字符串中的双引号，如下:

 "We are the so-called \"Vikings\" from the north."

 反斜杠是一个**转义字符**。 转义字符将特殊字符转换为字符串字符：

转义字符 (\) 可以用于转义撇号，换行，引号，等其他特殊字符。

下表中列举了在字符串中可以使用转义字符转义的特殊字符：

| 代码 | 输出        |
| :--- | :---------- |
| \'   | 单引号      |
| \"   | 双引号      |
| \\   | 反斜杠      |
| \n   | 换行        |
| \r   | 回车        |
| \t   | tab(制表符) |
| \b   | 退格符      |
| \f   | 换页符      |

**String 对象属性**

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201108094540133.png" alt="image-20201108094540133" style="zoom:80%;" />

String常用的对象方法

1. **charAt()**	返回在指定位置的字符

   返回字符串中的第三个字符:

   ```
   var str = "HELLO WORLD";
   var n = str.charAt(2)
   ```

   *n*输出结果:

   L

2. **concat()**   返回两个或更多字符串，并返回新的字符串

   连接两个字符串:

   ```
   var str1 = "Hello ";
   var str2 = "world!";
   var n = str1.concat(str2);
   ```

   *n* 输出结果:

   Hello world!

   更多用法请前往：https://www.runoob.com/jsref/jsref-concat-string.html

3. **repeat()**   复制字符串指定次数，并将它们连接在一起返回。

4. 复制字符串 "Runoob" 两次:

   ```
   var str = "Runoob"; 
   str.repeat(2);
   ```

   *n* 输出结果:

   RunoobRunoob

5. includes()  查找字符串中是否包含指定的子字符串。

   查找字符串是否包含 "Runoob":

   ```
   var str = "Hello world, welcome to the Runoob。";
   
    var n = str.includes("world");
   ```

   *n* 输出结果:

   true

   includes() 方法用于判断字符串是否包含指定的子字符串。

   如果找到匹配的字符串则返回 true，否则返回 false。

   **注意：** `includes() 方法区分大小写。`

   更多用法请前往：https://www.runoob.com/jsref/jsref-string-includes.html

6. **spilt()**       把字符串分割为字符串数组

   ```
   var str="How are you doing today?";
   var n=str.split(" ");
   console.log(n)//["How", "are", "you", "doing", "today?"]
   ```

   更多用法请前往：https://www.runoob.com/jsref/jsref-split.html

7. **substr()**    从起始索引号提取字符串中指定数目的字符。

   抽取指定数目的字符：

   ```
   var str="Hello world!";
   var n=str.substr(2,3)
   ```

   *n* 输出结果:

   llo

   **语法**

   *string*.substr(*start*,*length*)

   **参数值**

   | 参数     | 描述                                                         |
   | :------- | :----------------------------------------------------------- |
   | *start*  | 必需。要抽取的子串的起始下标。必须是数值。如果是负数，那么该参数声明从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。 |
   | *length* | 可选。子串中的字符数。必须是数值。如果省略了该参数，那么返回从 stringObject 的开始位置到结尾的字串。 |

8. **trim()**       去除字符串两边的空白

   去除字符串的头尾空格:

   var str = "       Runoob        "; alert(str.trim());

   输出结果:

   Runoob

9. **toString()**  返回一个字符串。

   返回一个 String 对象的值:

   var str = "Runoob"; var res = str.toString();

   *res* 输出结果:

   Runoob

10.**slice()** 提取某个字符串的一部分，并返回一个新的字符串，且不会改动原字符串

​	语法：str.slice(beginIndex[, endIndex])

​			beginIndex:从该索引（以 0 为基数）处开始提取原字符串中的字符。如果值为负数，会被当做 `strLength + beginIndex` 看待，这里									  的`strLength` 是字符串的长度（例如， 如果 `beginIndex` 是 -3 则看作是：`strLength - 3`）

​			endIndex:可选。在该索引（以 0 为基数）处结束提取字符串。如果省略该参数，`slice()` 会一直提取到字符串末尾。如果该参数为负								  数，则被看作是 strLength + endIndex，这里的 strLength 就是字符串的长度(例如，如果 endIndex 是 -3，则是, strLength 								  - 3)。

​			返回值：返回一个从原字符串中提取出来的新字符串

```
     const str = 'The quick brown fox jumps over the lazy dog.';

     console.log(str.slice(31));
     // expected output: "the lazy dog."

     console.log(str.slice(4, 19));
     // expected output: "quick brown fox"

     console.log(str.slice(-4));
     // expected output: "dog."

     console.log(str.slice(-9, -5));
     // expected output: "lazy"
```



##### 数组

###### 数组的基本使用

**为什么使用数组?**

- 假如有这样一个需求：保存自己多个朋友的名字。可以这么做：

  ```javascript
  // 保存班级中所有学生的名字
  var name1 = "Tom"
  var name2 = "Lily"
  var name3 = "Lucy"
  var name4 = "Lilei"
  var name5 = "Coderwhy"
  ```

- 这不是一个好的解决方案

  - 因为假如班级有100个学生, 那么我们就需要有100个变量.
  - 100个变量的是非常不方便管理的, 而且当我们需要找到某一个学生时, 从100个变量中去搜索也是一个问题.

- 很明显, 这种情况下, 我们通常会使用数组来解决:

  ```javascript
  // 使用数组来保存学生名字
  var names = ["Tom", "Lily", "Lucy", "Lilei", "Coderwhy"]
  ```

**创建和初始化数组**

- 用JavaScript声明、创建和初始化数组很简单，就像下面这样：

  ```javascript
  // 创建和初始化数组
  var daysOfWeek = new Array()
  var daysOfWeek = new Array(7)
  var daysOfWeek = new Array('Sunday', 'Monday', 'Tuesday', 'Wednesday',
      'Thursday', 'Friday', 'Saturday')
  ```

- 代码解析:

  - 使用`new`关键字，就能简单地声明并初始化一个数组
  - 用这种方式，还可以创建一个指定长度的数组.
  - 另外，也可以直接将数组元素作为参数传递给它的构造器
  - 用`new`创建数组并不是最好的方式。如果你想在JavaScript中创建一个数组，只用中括号（`[]`）的形式就行了

- 使用中括号（`[]`）创建数组

  ```javascript
  var daysOfWeek = ['Sunday', 'Monday', 'Tuesday', 'Wednesday',
      'Thursday', 'Friday', 'Saturday'];
  ```

**数组长度和遍历数组**

- 如果我们希望获取数组的长度, 有一个length属性

  ```javascript
  // 获取数组的长度
  alert(daysOfWeek.length)
  ```

- 也可以通过下标值来遍历数组:

  ```javascript
  // 普通for方式遍历数组
  for (var i = 0; i < daysOfWeek.length; i++) {
      alert(daysOfWeek[i])
  }
  
  // 通过foreach遍历数组
  daysOfWeek.forEach(function (value) {
      alert(value)
  })
  ```

###### 数组的常见操作

> 数组中常见的操作有: 添加元素、删除元素、修改元素、获取元素.

**添加元素**

- JavaScript中, 进行我们上述的操作都比较简单: 因为语言本身都已经封装好了这些特性.

- 假如我们有一个数组: numbers, 初始化0~9

  ```javascript
  // 初始化一个数组
  var numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  ```

- 添加一个元素到数组的最后位置:

  ```javascript
  // 添加一个元素到数组的最后位置
  // 方式一:
  numbers[numbers.length] = 10
  
  // 方式二:
  numbers.push(11)
  numbers.push(12, 13)
  
  alert(numbers)
  ```

- 在数组首位插入一个元素:

  ```javascript
  // 在数组首位插入一个元素
  for (var i = numbers.length; i > 0; i--) {
      numbers[i] = numbers[i-1]
  }
  numbers[0] = -1
  alert(numbers) // -1,0,1,2,3,4,5,6,7,8,9,10,11,12,13
  ```

- 上面代码实现的原理是怎样的呢?

  <img src="https:////upload-images.jianshu.io/upload_images/1102036-8fb6621c6dca7e05?imageMogr2/auto-orient/strip|imageView2/2/w/1024/format/webp" alt="img" style="zoom:80%;" />

- 考虑上面代码实现的性能怎么呢?

  - 性能并不算非常高
  - 这也是数组和链表(后面我们会学习到)相对比的一个劣势: 在中间位置插入元素的效率比链表低.

- 当然, 我们在数组首位插入数据可以直接使用unshift方法

  ```javascript
  // 通过unshift在首位插入数据
  numbers.unshift(-2)
  numbers.unshift(-4, -3)
  alert(numbers) // -4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13
  ```

**删除元素**

- 如果希望删除数组最后的元素, 可以使用pop()方法

  ```javascript
  // 删除最后的元素
  numbers.pop()
  alert(numbers) // -4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10,11,12
  ```

- 如果我们希望移除的首位元素, 自己实现代码:

  ```javascript
  // 删除首位的元素
  for (var i = 0; i < numbers.length; i++) {
      numbers[i] = numbers[i+1]
  }
  numbers.pop()
  alert(numbers)
  ```

- 当然, 我们可以直接使用shift方法来实现:

  ```javascript
  numbers.shift()
  alert(numbers)
  ```

**任意位置**

- 任意位置?

  - 前面我们学习的主要是在数组的开头和结尾处添加和删除数据.
  - 那如果我们希望在数组的中间位置进行一些操作应该怎么办呢?

- 一方面, 我们可以自己封装这样的函数, 但JS已经给我们提供了一个splice方法

- 通过splice删除数据

  ```javascript
  // 删除指定位置的几个元素
  numbers.splice(5, 3)
  alert(numbers) // -4,-3,-2,-1,0,4,5,6,7,8,9,10,11,12,13
  ```

- 代码解析:

  - 上面的代码会删除索引为5, 6, 7位置的元素.
  - 第一个参数表示索引起始的位置为5(其实是第6个元素, 因为索引从0开始的), 删除3个元素.

- 如果我们希望使用splice来插入数据呢?

  ```javascript
  // 插入指定位置元素
  numbers.splice(5, 0, 3, 2, 1)
  alert(numbers) // -4,-3,-2,-1,0,3,2,1,4,5,6,7,8,9,10,11,12,13
  ```

- 代码解析:

  - 上面的代码会从索引为5的位置开始插入数据. 其他数据依次向后位移.
  - 第一个参数依然是索引值为5(第六个位置)
  - 第二个参数为0时表示不是删除数据, 而是插入数据.
  - 后面紧跟的是在这个位置要插入的数据, 可以是其他类型, 比如"a", "b", "c".

- 如果我们希望使用splice来修改数据呢?

  ```javascript
  // 修改指定位置的元素
  numbers.splice(5, 3, "a", "b", "c")
  alert(numbers) // -4,-3,-2,-1,0,a,b,c,4,5,6,7,8,9,10,11,12,13
  ```

- 代码解析:

  - 上面的代码会从索引5的位置开始修改数据, 修改多少个呢? 第二个参数来决定的.
  - 第一个参数依然是索引的位置为5(第六个位置)
  - 第二个参数是要将数组中多少个元素给替换掉, 我们这里是3个(也可以使用3个元素来替换2个, 可以自己尝试一下)
  - 后面跟着的就是要替换的元素.

###### 数组的其他操作

> 上面学习的是对数组的一些基本操作.
>
> JavaScript中添加了很多方便操作数据的方法, 我们一些来简单回顾一下.

**常见方法**

- 我们先对常见的方法简单来看一下

  | 方法名        | 方法描述                                                     |
  | ------------- | ------------------------------------------------------------ |
  | `concat`      | 连接2个或更多数组，并返回结果                                |
  | `every`       | 对数组中的每一项运行给定函数，如果该函数对每一项都返回 `true`，则返回`true`, 否则返回`false` |
  | `filter`      | 对数组中的每一项运行给定函数，返回该函数会返回 `true`的项组成的数组 |
  | `forEach`     | 对数组中的每一项运行给定函数。这个方法没有返回值             |
  | `join`        | 将所有的数组元素连接成一个字符串                             |
  | `indexOf`     | 返回第一个与给定参数相等的数组元素的索引，没有找到则返回-1   |
  | `lastIndexOf` | 返回在数组中搜索到的与给定参数相等的元素的索引里最大的值     |
  | `map`         | 对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组 |
  | `reverse`     | 颠倒数组中元素的顺序，原先第一个元素现在变成最后一个，同样原先的最后一个元素变成了现在的第一个 |
  | `slice`       | 传入索引值，将数组里对应索引范围内的元素作为新数组返回       |
  | `some`        | 对数组中的每一项运行给定函数，如果任一项返回 `true`，则结果为`true`, 并且迭代结束 |
  | `sort`        | 按照字母顺序对数组排序，支持传入指定排序方法的函数作为参数   |
  | `toString`    | 将数组作为字符串返回                                         |
  | `valueOf`     | 和 `toString`类似，将数组作为字符串返回                      |

**数组合并**

- 数组的合并非常简单, 使用concat即可(也可以直接+进行合并)

  ```javascript
  // 数组的合并
  var nums1 = [1, 2, 3]
  var nums2 = [100, 200, 300]
  var newNums = nums1.concat(nums2)
  console.log(newNums) // 1,2,3,100,200,300
  
  newNums2 = nums1 + nums2
  console.log(newNums2) // 1,2,3,100,200,300
  ```

**迭代方法**

- 为了方便操作数组, JS提供了很多迭代器方法, 我们来回顾一下

- every()方法

  MDN文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every

  - `callback`

    用来测试每个元素的函数，它可以接收三个参数：`element`用于测试的当前值。`index`可选用于测试的当前值的索引。`array`可选调用 `every` 的当前数组。

  - `thisArg`

    执行 `callback` 时使用的 `this` 值。

  [返回值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every#返回值)

  如果回调函数的每一次返回都为 boolean值，返回 `**true**` ，否则返回 `**false**`。

  - every()方法是将数组中每一个元素传入到一个函数中, 该函数返回true/false.
  - 如果函数中每一个元素都返回true, 那么结果为true, 有一个为false, 那么结果为false

- every()练习:

  - 判断一组元素中是否都包含某一个字符

  ```javascript
  const isBelowThreshold = (currentValue) => currentValue < 40;
  const array1 = [1, 30, 39, 29, 10, 13];
  console.log(array1.every(isBelowThreshold));   //true
  ```

- some()方法

  MDN文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some

  - some()方法是将数组中每一个元素传入到一个函数中, 该函数返回true/false
  - 但是和every不同的是, 一旦有一次函数返回了true, 那么迭代就会结束. 并且结果为true

- some()练习

  ```javascript
  const isBelowThreshold = (currentValue) => currentValue < 30;
  const array1 = [1, 30, 39, 29, 10, 13];
  console.log(array1.some(isBelowThreshold));   //true
  ```

- **forEach()方法**

  - forEach()方法仅仅是一种快速迭代数组的方式而已.
  - 该方法不需要返回值

- forEach的使用

  ```javascript
  // 定义数组
  var names = ["abc", "cb", "mba", "dna"]
  // forEach的使用
  names.forEach(function (t) {
      console.log(t)
  })
  ```

- **filter()方法**

  MDN文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter

  filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。

  **注意：** filter() 不会对空数组进行检测。

  **注意：** filter() 不会改变原始数组。

  实例：

  ```
  var ages = [32, 33, 16, 40];
  ages.filter(item=>{
  	return item>=18
  })   //[32,33,40]
  ```

  **sort（）方法**

  MDN文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort

  sort()方法在适当的位置对数组进行排序，并且返回数组。

  实例：

  ```
        var arr=[1,3,10,4,2,5];
        function compare(value1,value2) {
              console.log(value1,value2,arr);
              if(value1<value2){return -1;}
              else if(value1>value2){return 1;}
              else {return 0}
          }
          arr.sort(compare);
          alert(arr);   //1,2,3,4,5,10
  ```

  我们定义的数组是这样的 arr=[1,3,10,4,2,5]
  第一行：传入的是value1=1，value2=3，比较大小返回-1，数组的位置不变。
  第二行：传入的是value1=3，value2=10，比较大小返回-1，数组的位置不变。
  第三行：传入的是value1=10，value2=4，比较大小返回1，两项交换位置，现在的数组是arr=[1,3,4,10,2,5]
  第四行：现在不是继续往后面比较，由于返回值为1（这是升序，1的时候往前面比较），则在第三行操作交换位置后，这传入的参数是value1=3，value2=4，比较大小，返回-1，位置不变，数组还是arr=[1,3,4,10,2,5]
  第五行：这才继续向后比较，传入value1=10，value2=2，比较大小，返回1，交换位置，数组为arr=[1,3,4,2,10,5]
  第六行：前面的返回值又是1，则又比较前面的，value1=4，value2=2，比较大小，返回1，数组变为arr=[1,3,2,4,10,5]
  第七行：第六行结果返回值是1，所以这个地方也不能往后面比较，value1=3，value2=2；比较大小，返回1，数组为arr=[1,2,3,4,10,5]
  第八行：同理，value1=1，value2=2，比较大小返回-1，数组不变。
  第九行：继续往后面比较，value1=10，value2=5，比较大小，返回1，改变位置，数组是arr=[1,2,3,4,5,10]
  最后一行：前面返回值是1，则向前比较，value1=4，value2=5，比较大小，返回-1，数组不变，（因为前面4前面的数是排好序的，只要5>4，就会比前面都大，则前面不用比较。）

  如果想升序排行的话，可以使用：

  ```
     var arr=[1,3,10,4,2,5];
          arr.sort((a,b)=>{
          	return a-b
          });
  ```

  降序则：

  ```
     
     var arr=[1,3,10,4,2,5];
          arr.sort((a,b)=>{
          	return b-a
          });
  ```

  `而且这个函数是直接改变原数组的排列，而不是返回一个新数组`

- **map()方法**

  MDN文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map

  map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。

  map() 方法按照原始数组元素顺序依次处理元素。

  `**注意：** map() 不会对空数组进行检测。`

  `**注意：** map() 不会改变原始数组。`

  使用实例：

  ```
  var numbers = [4, 9, 16, 25];
  var result=numbers.map(Math.sqrt);//2,3,4,5
  ```

  ```
  语法：array.map(function(currentValue,index,arr))
  ```

  使用实例：

  ```
  var arr=[1,2,3]
  var result =arr.map((item)=>{
  	return item*2
  })
  console.log(result)//2，4，6
  ```

  map的作用是用来筛选和处理数组的

**reduce方法**

MDN文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce

- 我们单独拿出reduce方法, 因为这个方法相对来说难理解一点

- 首先, 我们来看这个方法需要的参数:

  ```javascript
  arr.reduce(callback[, initialValue])
  ```

- 参数

  - callback（一个在数组中每一项上调用的函数，接受四个函数：）
    - previousValue（上一次调用回调函数时的返回值，或者初始值）
    - currentValue（当前正在处理的数组元素）
    - currentIndex（当前正在处理的数组元素下标）
    - array（调用reduce()方法的数组）
  - initialValue（可选的初始值。作为第一次调用回调函数时传给previousValue的值）

- 有些晦涩难懂, 我们直接看例子

  - 求一个数字中数字的累加和

- 使用for实现:

  ```javascript
  // 1.定义数组
  var numbers = [1, 2, 3, 4]
  
  // 2.for实现累加
  var total = 0
  for (var i = 0; i < numbers.length; i++) {
      total += numbers[i]
      return total
  }
  alert(total) // 10
  ```

- 使用forEach简化for循环

  - 相对于for循环, forEach更符合我们的思维(遍历数组中的元素)

  ```javascript
  // 3.使用forEach
  var total = 0
  numbers.forEach(function (t) {
      total += t
  })
  alert(total)
  ```

- 使用reduce方法实现

  ```javascript
  // 4.使用reduce方法
  var total = numbers.reduce(function (pre, cur) {
      return pre + cur
  })
  alert(total)
  ```

- 代码解析:

  - pre中每次传入的参数是不固定的, 而是上次执行函数时的结果保存在了pre中
  - 第一次执行时, pre为0, cur为1
  - 第二次执行时, pre为1 (0+1, 上次函数执行的结果), cur为2
  - 第三次执行时, pre为3 (1+2, 上次函数执行的结果), cur为3
  - 第四次执行时, pre为6 (3+3, 上次函数执行的结果), cur为4
  - 当cur为4时, 数组中的元素遍历完了, 就直接将第四次的结果, 作为reduce函数的返回值进行返回.

- 似乎和forEach比较没有太大的优势呢?

  - 通过这个代码你会发现, 你不需要在调用函数前先定义一个变量, 只需要一个变量来接收方法最终的参数即可.
  - 但是这就是优势吗? 不是, 优势在于reduce方法有返回值, 而forEach没有.
  - 这算什么优势? 如果reduce方法有返回值, 那么reduce方法本身就可以作为参数直接传递给另外一个需要reduce返回值的作为参数的函数. 而forEach中你只能先将每次函数的结果保存在一个变量, 最后再将变量传入到参数中.
  - 没错, 这就是最近非常流行的函数式编程. 也是为了几乎每个可以使用函数式编程的语言都有reduce这个方法的原因.
  - 关于函数式编程, 不再本次课程的讨论之中, 只是看到了这个函数, 给大家延伸了一下而已.(后面有机会和大家分享函数式编程)

- initialValue还需要讲吗?

  - 其实就是第一次执行reduce中的函数时, pre的值.
  - 因为默认pre第一次执行时为0.

###### **JS数组遍历**

> 基本就是for,forin,foreach,forof,map等等一些方法

**第一种:普通for循环**

代码如下:

```
for(j = 0; j < arr.length; j++) {
} 
```

简要说明: 最简单的一种，也是使用频率最高的一种，虽然性能不弱，但仍有优化空间

**第二种:优化版for循环**

代码如下:****

```
for(j = 0,len=arr.length; j < len; j++) {
}
```

简要说明: 使用临时变量，将长度缓存起来，避免重复获取数组长度，当数组较大时优化效果才会比较明显。

**这种方法基本上是所有循环遍历方法中性能最高的一种**

**第三种:foreach循环**

代码如下:

```
arr.forEach(function(e){  
});
```

简要说明: 数组自带的foreach循环，使用频率较高，实际上性能比普通for循环弱

**第四种:forin循环**

代码如下:

```
for(j in arr) {
}
```

简要说明: 这个循环很多人爱用，但实际上，经分析测试，在众多的循环遍历方式中

`它的效率是最低的`

**第五种:map遍历**

代码如下:

```
arr.map(function(n){  
});
```

简要说明: 这种方式也是用的比较广泛的，虽然用起来比较优雅，但实际效率还比不上foreach

**第六种:forof遍历(需要ES6支持)**

代码如下:

```
for(let value of arr) {  
});
```

简要说明: 这种方式是es6里面用到的，性能要好于forin，但仍然比不上普通for循环

##### 对象

1. 内建对象

   - 由ES标准中定义的对象，在任何的ES的实现中都可以实现

   - 比如：Math String Number Boolean Function Object....

2. 宿主对象

   - 由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象

   - 比如 BOM DOM

     例：console.log()——BOM、document.write()——DOM

3.  自定义对象

   - 由开发人员自己创建的对象

###### 基本使用

**创建对象**

​	使用new 关键字调用构造函数constructor，构造函数是专门用来创建对象的函数，使用typeof检查一个对象时，会返回object

**方式一：**

```
	var obj = new Object()
	//在对象中保存的值称为属性
	//向对象添加属性
		//语法: 对象.属性名 = 属性值；
	obj.name = "孙悟空"
	console.log(obj) //{name: '孙悟空'}
	//删除对象的属性
		//语法： delete 对象.属性名
	delete obj.name
	console.log(obj) //{}
```

如果要使用特殊的属性名，不能采用.的方式来操作

​	需要使用另一种方式：

​			`语法：对象["属性名"] = 属性值`

obj["123"] = 'hello'

使用[ ]这种方式去操作属性，更加的灵活，

​	在[ ]中可以直接传递一个变量，这样变量值是多少就会读取多少

​			`语法：对象[变量] = 属性值`

**方式二**（推荐使用）

> ​	使用对象字面量，可以在创建对象时，直接指定对象中的属性

```
	var obj = {
			name: "猪八戒",
			age: 28,
			weight: '200kg',
			sonObj: {
				name: 'son'
			}
		}
```



######  对象遍历

1.for … in 循环遍历对象自身的和继承的可枚举属性(循环遍历对象自身的和继承的可枚举属性(不含Symbol属性).).

![img](https://img2018.cnblogs.com/blog/1543474/201908/1543474-20190819160618071-1699607505.png)

2、使用Object.keys()遍历 (返回一个数组,包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性).).

![img](https://img2018.cnblogs.com/blog/1543474/201908/1543474-20190819160801372-293238672.png)

 

<img src="https://img2018.cnblogs.com/blog/1543474/201908/1543474-20190819161346978-1979945848.png" alt="img" style="zoom: 67%;" />

ES6允许对象的属性直接写变量，这时候属性名是变量名，属性值是变量值。

```
     const age = 12;
     const name = "Amy";
     const person = {age, name};
     person   //{age: 12, name: "Amy"}
     //等同于
     const person = {age: age, name: name}
```

方法名也可以简写

```
     const person = {
       sayHi(){
         console.log("Hi");
       }
     }
     person.sayHi();  //"Hi"
     //等同于
     const person = {
       sayHi:function(){
         console.log("Hi");
       }
     }
     person.sayHi();//"Hi"
```

ES6允许用表达式作为属性名，但是一定要将表达式放在方括号内。

```
     const obj = {
      ["he"+"llo"](){
        return "Hi";
       }
     }
     obj.hello();  //"Hi"
```

注意点：属性的简洁表示法和属性名表达式不能同时使用，否则会报错。

```
     const hello = "Hello";
     const obj = {
      [hello]
     };
     obj  //SyntaxError: Unexpected token }

     const hello = "Hello";
     const obj = {
      [hello+"2"]:"world"
     };
     obj  //{Hello2: "world"}
```

###### Date对象

> Date 对象用于处理日期和时间。

###### 对象访问属性

> 对象中有get和set方法，在读取和设定值的时候触发。vue中的数据绑定就是通过这个来实现的

**1. 直接在对象内使用**

- **get用法**

```jsx
     var user = {
         info: {
             name: "张三"
         },
         get name(){
             return this.info.name;
         }
     }
    console.log(user.info.name) // '张三'
    console.log(user.name) // '张三'
```

*作用：*
 (1). 在对象内属性嵌套层级过多时，可以直接在对象下读取到对应属性，简化调用；
 (2). 在get时可以任意设置属性名，可以不暴露组件内部属性名。



- **set用法**

```jsx
     var user = {
         info: {
             name: "张三"
         },
         set name(val){
             console.log('我改名了');
             this.info.name = val;
         }
     }
    console.log(user.name) // '张三'

    user.set = '李四'; // '我改名了'
    console.log(user.name) // '李四'
```

*作用：*
 (1). 在对象内属性嵌套层级过多时，可以直接在对象下设置到对应属性，简化层级；
 (2). set方法内的逻辑在赋值时会自动执行，可以监听属性值的改变

2. **使用Object.defineProperty()**

```jsx
var user = {
    name: '张三'
}
Object.defineProperty(user, ’name‘, {
    get(){
        return user.name
    },
    set(val){
        console.log('我改名了');
        user.name = val
    }

})
console.log(user.name) // '张三'
user.name = '王二'; // '我改名了'
console.log(user.name) // '王二'
```

*作用：*
 set方法可以监听对应属性值的改变，vue的数据动态绑定就是通过这个方法实现的，监听到vue实例中的data属性发生改变时，在set方法中触发模版重新渲染逻辑。

**3. 使用Object.defineProperties()**

```jsx
     var user = {
         name: '张三'
     }
     Object.defineProperties(user, {
         nameGet: {
             value: function() {
                 console.log('读取');
                 return this.name;
             }
         },
         nameSet: {
             value: function(name) {
                 console.log('设置');
                 this.name = name;
             }
         }
     })
     console.log(user.nameGet) // '读取'  '张三'
     user.nameSet = '王二'; // '设置'
     console.log(user.nameSet) // '王二'
```

*作用：*
 和方法1直接在对象中设置效果和原理相似

###### Object.assign（）对象去重合并

> Object.assign(target, source_1, ···)
>
> 用于将源对象的所有可枚举属性复制到目标对象中。
>
> 在vue中可以实现响应式

**基本用法**

```
let target = {a: 1};
let object2 = {b: 2};
let object3 = {c: 3};
Object.assign(target,object2,object3);  
// 第一个参数是目标对象，后面的参数是源对象
target;  // {a: 1, b: 2, c: 3}
```

- 如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。

- 如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。

  ```
  Object.assign(3);         // Number {3}
  typeof Object.assign(3);  // "object"
  ```

使用案例：

Object.assign({},oldobj,newobj)

注意。这里的Object是真的Object,不能改变，后面的是真实的对象名称

```
	oldobj{
		name:'zs'
		sex:''
	}
	newobj{
		age:18
		sex:"female"
	}
```

那么Object.assign({},oldobj,newobj)的结果就是

```
	{
		name:'zs',
		sex:'female',
		age:18
	}
```

如果oldobj有的属性而newobj没有，那以oldobj为准，如果newobj有的属性，不管oldobj有没有都会以newobj为准

###### instanceof

在JS中，判断一个变量的类型，常常会用到`typeof`运算符，但当用来判断引用类型变量时，无论是什么类型的变量，它都会返回`Object`。为此，引入了`instanceof`。

`instanceof`相比与`typeof`来说，`instanceof`方法要求开发者明确的确认对象为某特定类型。即`instanceof`用于判断引用类型属于哪个构造函数的方法。

```js
var arr = []
arr instanceof Array // true
typeof arr // object, typeof 是无法判断是否为数组的
123
```

另外，更重的一点是 instanceof 可以在继承关系中用来判断一个实例是否属于它的父类型。

```js
// 判断 f 是否是 Foo 类的实例 , 并且是否是其父类型的实例
function Aoo(){} 
function Foo(){} 
Foo.prototype = new Aoo();//JavaScript 原型继承
 
var f = new Foo(); 
console.log(foo instanceof Foo)//true 
console.log(foo instanceof Aoo)//true
12345678
```

`f instanceof Foo` 的判断逻辑是：

- f 的 `__proto__`一层一层往上，是否对应到 `Foo.prototype`
- 再往上，看是否对应着`Aoo.prototype`
- 再试着判断 `f instanceof Object`

即`instanceof`可以用于判断多层继承关系。

下面看一组复杂例子

```js
console.log(Object instanceof Object) //true 
console.log(Function instanceof Function) //true 
console.log(Number instanceof Number) //false 
console.log(String instanceof String) //false 
console.log(Array instanceof Array) // false
 
console.log(Function instanceof Object) //true 
 
console.log(Foo instanceof Function) //true 
console.log(Foo instanceof Foo) //false
12345678910
```

在这组数据中，Object、Function instanceof 自己为true， 其他的instanceof自己都为false，这就要从instanceof的内部实现机制以及JS原型继承机制讲起。

**1. instanceof的内部实现机制**

instanceof的内部实现机制是通过判断对象的原型链上是否能找到对象的 `prototype`

```js
// instanceof 的内部实现 
function instance_of(L, R) {//L 表示左表达式，R 表示右表达式，即L为变量，R为类型
 // 取 R 的显示原型
 var prototype = R.prototype
 // 取 L 的隐式原型
 L = L.__proto__
 // 判断对象（L）的类型是否严格等于类型（R）的显式原型
 while (true) { 
   if (L === null) 
     return false
   if (prototype === L)// 这里重点：当 prototype 严格等于 L 时，返回 true 
     return true
   L = L.__proto__
 } 
}
```

###### object.definePrototype() 操作对象属性

这是用来定义对象属性的，里面有三个参数
	object.definePrototype(object,属性,描述符)
	描述符分两种一个是数据描述符一个是存取描述符

```
数据描述符{
value："",
configurable:false不能删除与重新定义，
writeable：true允许修改属性
enumerable：true允许变量循环
}
存取描述符
{
get：function（）{
return a
}，
set：function（b）{
a=b
}
}
```

**enumerable**

当且仅当该属性的 `enumerable` 键值为 `true` 时，该属性才会出现在对象的枚举属性中。
**默认为 `false`**。

基本使用（添加属性）：

```
import moment from 'moment';
Object.definePrototype(Vue.prototype, '$moment', { value: moment });
```

相当于：

```
import moment from 'moment';
Vue.prototype.$moment= moment
```

但是definePrototype可以在vue中实现对象属性响应式，也就是增加原来没有定义的属性也能实现响应式

###### **对象的方法扩展（ES8)**

keys、values、entries

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201108113724277.png" alt="image-20201108113724277" style="zoom:80%;" />

输出结果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201108113747705.png" alt="image-20201108113747705" style="zoom:80%;" />

##### 函数

> 函数也是一个对象，函数中可以封装一些功能（代码），在需要的时候可以执行这些（代码）

###### 创建函数对象

**方式一：**(很少使用)

> ​	可以将要封装的代码以字符串的形式传递给构造函数

```
		var fun = new Function("console.log('hello World')")
```

**方式二：**（推荐使用）

> 使用函数声明来创建一个函数

```
		function fun(){
			console.log('hello world')
		}
```

​	使用函数声明来创建函数（其他方式不会）会在所有的代码执行之前就被创建，`函数声明提前会在变量提升之后,变量提升会快于函数提升`

**方式三：**

> 使用函数表达式 来创建一个函数

```
		var fun = function(){
			console.log('hello world')
		}
```

**立即执行函数**

> 函数定义完，立即被调用，立即执行函数往往只调用一次	

```
		(function (){
			console.log('hello world')
		})()
		(function (a,b){
			console.log(a+b)
		})()
```

###### 函数参数

函数的实参可以是任意的类型

```
	function sum(a,b){
		return a+b
	}
	//相当于
	function sum(a,b){
		var a ,b //代码块会自动定义变量
		return a+b
	}
```

调用函数时，解析器不会检查实参的类型，

​	所以要注意，是否有可能会接收到非法的参数，如果有可能则需要对参数进行类型的检查

调用函数时，解析器也不会检查实参的数量

​	多余实参不会被赋值

如果实参的数量少于形参的数量，则没有对应实参的形参将是undefined

```
	function sum(a,b){
		console.log(a) //10
		console.log(b) //undefined
		//return只能返回一个值，如果返回多个，则只取最后一个返回
		return a,b
	}
	console.log(sum(10) //undefined
```

###### arguments参数

###### 函数返回值

`return 只能返回一个值，如果有多个，则只取最后一个返回`

```
	function sum(a,b){
		//return只能返回一个值，如果返回多个，则只取最后一个返回
		return a,b
	}
	console.log(sum(10)) //undefined
```

虽然return 只能返回一个值，但是我们可以返回对象或者数组等数据类型来间接返回多个值

```
	function sum(a,b){
		return {a,b}
	}
	console.log(sum(10).a,sum(10).b}) //10,undefined
```

`注：函数都是有返回值的`

​	`1、如果有return则返回return后面的值`

​	`2、如果没有return则返回undefined`

###### break、continue、return的区别

break: 结束当前的循环体(如：for、while)

continue:跳出循环，继续执行下一次循环（如：for、while）

return: 不仅可以退出循环，还能够返回return语句中的值，同时还可以结束当前的函数体内的代码

###### 箭头函数

()=>{}
箭头函数又称匿名函数，不能作为构造函数,不能使用new

```javascript
let f = () =>{
	console.log('123')
}
let fc = new f();  //这一行报错 f is not a constructor
```

箭头函数不绑定argumets,取而代之用rest参数解决

```javascript
//普通函数
function A(a){
	console.log(arguments); //伪数组 arguments是一个参数的集合 [1,2,3,4,5,callee: f ,Symbol(Symbol.iterator) : f]
	Array.prototype.push.call(arguments);
	//通过call来转换Array原型中的push的指向 			    arguments.push  
	//call() 方法 改变this的指向
}
A(1,2,3,4,5)

//箭头函数
let B = (b) =>{
	console.log(arguments); //这一行报错 arguments is not defined
}
B(1,2,3,4,5)
//Es6的扩展运算符
let C = (...c) =>{
	console.log(c)
}
C(1,2,3,4,5)  // [1,2,3,4,5]  
//Es6的扩展运算符 是将对象所有可遍历属性 拷贝到当前对象下
```

箭头函数会捕获父类的上下文来作为自己的this值
普通函数的this指向调用它的那个对象

```javascript
var a = 20;
var obj = {
	a:10,
	b:()=>{
		console.log(this.a);
	},
	c:function(){
		console.log(this.a);
	}
}
obj.b(); // 20
obj.c(); // 10
```

箭头函数没有原型

```javascript
var a = ()=>{
	return 1;
}
function b(){
	return 2;
}
console.log(a.prototype) // undefined
console.log(b.prototype) // {constructor:f}
```

箭头函数的this永远指向调用者的父类的上下文,任何方法都改变不了指向,比如 `call()` , `apply()` , `bind()`

普通函数的this指向调用它的那个对象

```
call()` `apply()` `bind()` 的用法和区别
call,apply,bind 它们在功能上没有区别的,都是改变this的指向,它们的区别主要是用于方法是实行形式和参数传递上的不同。call和apply方法都是在调用之后立即执行的,而bind调用之后是返回原函数`call()` `apply()`,需要再调用一次才行`bind(m)()
```

##### 类

> 在JavaScript中，`类本质上还是构造函数`

###### 构造函数

> `构造函数就是一个普通的函数`，创建方式和普通函数没有区别,不同的是构造函数习惯上首字母大写

**构造函数和普通函数的区别就是调用方式的不同**

​	**普通函数是直接调用，而构造函数需要使用new关键字来调用**(`当然构造函数和普通函数均能直接调用和使用new 关键字来调用`)

```
	function test(name) {
      this.name = name
      console.log('我是函数test');
    }
    //构造函数的方式调用
    let test1 = new test('刘德华')
    // 普通函数的方式直接调用
    test()
    console.log(test1);
```

执行结果：

![image-20201226152214257](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201226152214257.png)

```
	function Test(name) {
      this.name = name
      console.log('我是函数Test');
    }
    //构造函数的方式调用
    let Test1 = new Test('刘德华')
    // 普通函数的方式直接调用
    Test()
    console.log(Test1);
```

执行结果：

![image-20201226152354911](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201226152354911.png)

由上面代码执行结果可以看出，`构造函数就是普通函数，普通函数也是构造函数，只是调用方式不一样而已，一般情况构造函数习惯上首字母大写，`

`但是这并不是必须条件`

构造函数的执行流程：

​	1、立刻创建一个新的对象

​	2、将新建的对象设置为函数中的this

​	3、逐行执行函数中的代码

​	4、将新建的对象作为返回值返回

使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类

1、使用构造函数

```
     <script>
         function Phone(brand,price) {
           this.brand=brand;
           this.price=price;
           //创建公用方法
           Phone.prototype.call=function(){
           console.log('打电话');
         }
         }
         // 实例化对象
         let Huawei=new Phone('华为',2999);
         Huawei.call();
         console.log(Huawei);
      </script>
```

输出：

![image-20201108083319654](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201108083319654.png)

###### ES6Class

使用ES6中提供的class完成上面的功能

```
	class Phone{
           //构造方法，名字不能修改
           constructor(brand,price){
             this.brand=brand;
             this.price=price;
           }
           //方法必须使用该语法，放在原型上
           call(){
             console.log('我可以打电话');
           }
           //这样方法在每个实例对象上
           call2 = function(){
             console.log('我可以打电话2');
           }
           //类中可以直接写赋值语句，如下代码的含义是:给类的实例对象都添加一个属性，名为name,值为'Phone类',如果是大家共有的那么就可以这样写
           name = 'Phone类'
         }
         let k30=new Phone('xiaomi',2999);
         k30.call()           //我可以打电话
         console.log(k30);	//Phone { name: 'Phone类', brand: 'xiaomi', price: 2999 }
         console.log(k30.name)//Phone类
```

constructor相当于构造函数，一旦new这个类，就会执行该构造函数，方法的话相当于构造函数的 Phone.prototype.call=function(){
           console.log('我可以打电话');
         }

输出结果：
<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201108084128374.png" alt="image-20201108084128374" style="zoom: 80%;" />

实例对象和构造函数和类的方法和属性是不相通的，实例对象和它们的原型是相通的

**利用构造函数实现继承**

1、组合继承模式

```
    function Phone(brand,price) {
      this.brand=brand;
      this.price=price;
      Phone.prototype.call=function(){
      	console.log('打电话');
    	}
    }
    // 智能手机
    function SmartPhone(brand,price,color,size) {
      Phone.call(this,brand,price);
      this.color=color;
      this.size=size;
    }
    //设置子级构造函数的原型
    SmartPhone.prototype=new Phone();//这样就能形成原型链，进而实现继承
    //声明子类的方法
    SmartPhone.prototype.photo=function () {
      console.log('拍照功能');
    }
    const iPhone=new SmartPhone('iphone12',7777,'red','5.5')
    iPhone.photo()	 //拍照功能
    iPhone.call();   //打电话
    console.log(iPhone);
```

输出：

![image-20201108091316987](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201108091316987.png)

继承实现原理

![image-20210105224942582](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210105224942582.png)

2、组合寄生式继承

​	*//组合继承的缺点：需要两次调用Phone的构造函数，从而导致brand和price属性冗余，在Phone中存在一份，在Phone中又存在一份，只不过是sub把super里的属性覆盖了*

```
     //采用寄生组合继承模式可以解决上述问题
     function inheritPrototype(subClass, superClass){
		function F(){}
		F.prototype = superClass.prototype
		subClass.prototype = new F()
		//上面的b.constructor指向的是构造函数，但是如果构造函数原型被重写，b.constructor !== fun了，原因是指针指向的其实是原型对象。所以：实例化对象的				//constructor对象不是任何时候都指向构造函数本身，除非构造函数的原型一直不变，如果构造函数原型重写，全等关系就破灭了。
		subClass.prototype.constructor = subClass;  //增强对象，弥补因重写原型而失去的默认的constructor 属性
	}
	inheritPrototype(smartPhone,Phone)
```

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210205235210961.png" alt="image-20210205235210961" style="zoom: 67%;" />

利用class extends实现类的继承

```
 	class Phone{
        //构造方法
        constructor(brand,price){
          this.price=price;
          this.brand=brand;
        }
        //父类的成员属性
        call(){
          console.log('打电话功能');
        }
      }
      class SmartPhone extends Phone{
        //构造方法
        constructor(brand,price,color,size){
        	//这里的作用是给相当于给父类的this设置为新new的实例对象，不然就为undefined，因为我们子类实例调用父类的方法，父类这时是没有this的
        	//super相当于调用父元素的构造函数，super必须放在构造器的第一行
          super(brand,price);//相当于Phone.call(this,brand,price)
          this.color=color;
          this.size=size;
        }
        //重写从父类继承过来的方法,这样就不会去读取父类的call方法了
        //call(){
        // console.log('智能手机打电话功能');
        //}
        photo(){
          console.log('拍照功能');
        }
      }
      let iPhone=new SmartPhone('iphone12',7777,'黑色','6.1')
      iPhone.call()
      iPhone.photo();
      console.log(iPhone);
```

![image-20201108092226309](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201108092226309.png)

`注意：`

​	1、在ES6类中没有变量提升，所以必须先定义类，才能通过类实例化对象

​	2、类里面的共有的属性和方法一定要加this使用

```
   class Star {
    constructor(uname,age){
      this.uname = uname
      this.age = age
      sing() //报错
    }
    sing(){
      console.log(uname); //报错
    }
  }
  let ldh = new Star ('刘德华')
  ldh.sing() 
```

结果：

​	![image-20201226173919574](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201226173919574.png)

![image-20201226174006080](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201226174006080.png)

`在class类中this都指向新创建的实例对象，如果不加this去调用方法和属性，那么就会去全局作用域找，找不到就会报错`

正确的写法是：

```
    class Star {
    constructor(uname,age){
      this.uname = uname
      this.age = age
      this.sing()
    }
    sing(){
      console.log(this.uname); //刘德华
    }
  }
  let ldh = new Star ('刘德华')
  ldh.sing()
```

结果：

​	![image-20201226174313157](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201226174313157.png)



##### call、apply、bind

> call()、apply()、bind()是用来改变this的指向的。

![img](https://www.runoob.com/wp-content/uploads/2018/08/1535346409-8618-20170316165541854-1574871496.png)

```
     obj.objAge;  // 17
     obj.myFun()  // 小张年龄 undefined
```

![img](https://www.runoob.com/wp-content/uploads/2018/08/1535346409-8327-20170316170324541-406227186.png)

```
	shows()  // 盲僧　
```

比较一下这两者 this 的差别，第一个打印里面的 this 指向 obj，第二个全局声明的 shows() 函数 this 是 window ；

由于this只能存在于window对象和方法中，第一this并没有方法包裹，所以作用域是指向全局window,所以这时this指向window

**1，call()、apply()、bind() 都是用来重定义 this 这个对象的！**

![img](https://www.runoob.com/wp-content/uploads/2018/08/1535346409-8172-20170316172537651-1643313633.png)

```
     obj.myFun.call(db)；　　　　// 德玛年龄 99
     obj.myFun.apply(db);　　　 // 德玛年龄 99
     obj.myFun.bind(db)();　　　// 德玛年龄 99
```

以上除了 bind 方法后面多了个 () 外 ，结果返回都一致！

由此得出结论，bind 返回的是一个新的函数，你必须调用它才会被执行。

**2，对比call 、bind 、 apply 传参情况下**

![img](https://www.runoob.com/wp-content/uploads/2018/08/1535346409-7922-20170316173631526-1279562612.png)

```
obj.myFun.call(db,'成都','上海')；　　　　 // 德玛 年龄 99  来自 成都去往上海
obj.myFun.apply(db,['成都','上海']);      // 德玛 年龄 99  来自 成都去往上海  
obj.myFun.bind(db,'成都','上海')();       // 德玛 年龄 99  来自 成都去往上海
obj.myFun.bind(db,['成都','上海'])();　　 // 德玛 年龄 99  来自 成都, 上海去往 undefined
```

微妙的差距！

从上面四个结果不难看出:

call 、bind 、 apply 这三个函数的第一个参数都是 this 的指向对象，第二个参数差别就来了：

call 的参数是直接放进去的，第二第三第 n 个参数全都用逗号分隔，直接放到后面 **obj.myFun.call(db,'成都', ... ,'string' )**。

apply 的所有参数都必须放在一个数组里面传进去 **obj.myFun.apply(db,['成都', ..., 'string' ])**。

bind 除了返回是函数以外，它 的参数和 call 一样。

当然，三者的参数不限定是 string 类型，允许是各种类型，包括函数 、 object 等等！

##### 逻辑运算符（与或非）

**1、非！**

> ​	所谓非，就是取反，非真即假，非假即真。

​	非运算符不仅仅只能用于布尔值，其他数据类型也是可以的，如下:

​	1.如果操作数是一个对象，返回false

​	2.如果操作数是一个空字符串，返回true

​	3.如果操作数是一个非空字符串，返回false

​	4.如果操作数是数值0，返回true

​	5.如果操作数是任意非0数值(包括Infinity), 返回false

​	6.如果操作数是null,返回true

​	7.如果操作数是NaN,返回true

​	8.如果操作数是undefined, 返回true

**2、与&&**

> ​	作用于两到多个值，并且只有所有的操作数都是真值时，才为true。

​	JavaScript里面的与存在短路现象，具体说明如下:

​	1.第一个操作数为真:会进入第二个操作数的判断，且无论第二个操作数真假，都会返回第二个操作数。

​	2.第一个操作数为假:不会进入第二个操作数的判断，直接返回第一个操作数。

```
     console.log(3 && 5);//5
     console.log("Hello" && 20);//20
     console.log("Hello" && false);//false
     console.log("" && "shoe");//""
     console.log("Hello" && '');//''
```

**3、或||**

> 同样是作用于两到多个值，但是只要有一个操作数为真，就返回真。

JavaScript里面的或同样存在短路现象，具体说明如下:

1.如果第一个操作数为真，则不会进入第二个数的判断。所以无论第二个操作数真假，都直接返回第一个操作数

2.如果第一个操作数为假，则会进入第二个数的判断。但是无论第二个操作数真假，都直接返回第二个操作数

实例：

```
	console.log(false || true);//true
     console.log("Hello" || "");//Hello
     console.log("Hello" || "str");//Hello
     console.log(NaN || "");//""
     console.log(0 || "Hello World");//Hello World
     console.log('' || 'str');//str
     console.log('' || false);//false
```

经典题：

```
     let a = false;
     let b = a || c;因为a是false，所以会判断第二个数。
     console.log(b); //ReferenceError: c is not defined
     let a = false;
     let b = a && c;// 因为a是false，所以不会判断第二个数。
     console.log(b);//false
```

##### 作用域

###### 变量声明提前

-使用var关键字声明的变量，会在所有的代码执行之前被声明

var a=1相当于在代码最上方提前声明a；也就是var a;后面再赋值

-但是如果声明变量时`不使用var关键字，则变量不会被声明提前`

```
 	console.log(a); //undefined
     var a = 10
```

```
    console.log(a); //报错，let和const声明的变量都不会声明提前
    let a = 10
```

```
    console.log(a);//报错
    const a = 10
```

```
    console.log(a);//报错
    a = 10
```

###### 函数声明提前

**function fun(){}与var fun2=function(){}的区别**

函数声明提前

　　-使用函数声明形式创建的函数function 函数名（）{}

```
    console.log(a); //a(){}
    function a() {}
```

它会在所有的代码执行之前就被创建，`函数声明提前会在变量提升之后,变量提升会快于函数提升`

```
    console.log(a); //a(){}
    function a() {}
    var a = 10
    //上面代码在js中是这样解析的
    //var a;
    //function a(){}
    //console.log(a) //a(){}
    //a = 10
```

-使用函数表达式创建的函数不会声明提前（但是会变量提升，不会报错），所以不能在声明前调用

　　　　如果提前使用的话相当于undefined

```
    console.log(a); //undefined,不会函数提升
    var a = function () {}
```

##### 严格模式

**一、概述**

除了正常运行模式，ECMAscript 5添加了第二种运行模式：["严格模式"](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Functions_and_function_scope/Strict_mode)（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。

![img](http://www.ruanyifeng.com/blogimg/asset/201301/bg2013011401.jpg)

设立"严格模式"的目的，主要有以下几个：

> 　　- 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;
>
> 　　- 消除代码运行的一些不安全之处，保证代码运行的安全；
>
> 　　- 提高编译器效率，增加运行速度；
>
> 　　- 为未来新版本的Javascript做好铺垫。

"严格模式"体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经[支持](http://kangax.github.com/es5-compat-table)它，许多大项目已经开始全面拥抱它。

另一方面，同样的代码，在"严格模式"中，可能会有不一样的运行结果；一些在"正常模式"下可以运行的语句，在"严格模式"下将不能运行。掌握这些内容，有助于更细致深入地理解Javascript，让你变成一个更好的程序员。

本文将对"严格模式"做详细介绍。

**二、进入标志**

进入"严格模式"的标志，是下面这行语句：

> 　　"use strict";

老版本的浏览器会把它当作一行普通字符串，加以忽略。

**三、如何调用**

"严格模式"有两种调用方法，适用于不同的场合。

**3.1 针对整个脚本文件**

将"use strict"放在脚本文件的第一行，则整个脚本都将以"严格模式"运行。如果这行语句不在第一行，则无效，整个脚本以"正常模式"运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意。

(严格地说，只要前面不是产生实际运行结果的语句，"use strict"可以不在第一行，比如直接跟在一个空的分号后面。)

> 　　<script>　　　　
>        "use strict";　　　
>
> 　	console.log("这是严格模式。");　
>
> 　</script>
>
> 　　<script>　　　　
>
>    </script>
>
> console.log("这是正常模式。");kly, it's almost 2 years ago now. I can admit it now - I run it on my school's network that has about 50 		computers.　　
>
> </script>

上面的代码表示，一个网页中依次有两段Javascript代码。前一个script标签是严格模式，后一个不是。

**3.2 针对单个函数**

将"use strict"放在函数体的第一行，则整个函数以"严格模式"运行。

> 　　function strict(){
> 　　　　"use strict";
> 　　　　return "这是严格模式。";
> 　　}
>
> 　　function notStrict() {
> 　　　　return "这是正常模式。";
> 　　}

**3.3 脚本文件的变通写法**

因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。

> 　　(function (){
>
> 　　　　"use strict";
>
> 　　　　// some code here
>
> 　　 })();

**四、语法和行为改变**

严格模式对Javascript的语法和行为，都做了一些改变。

**4.1 全局变量显式声明**

在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。

> "use strict";
>
> 　　v = 1; // 报错，v未声明
>
> 　　for(i = 0; i < 2; i++) { // 报错，i未声明
> 　　}

因此，严格模式下，变量都必须先用var命令声明，然后再使用。

**4.2 静态绑定**

Javascript语言的一个特点，就是允许"动态绑定"，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。

严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。

具体来说，涉及以下几个方面。

**（1）禁止使用with语句**

因为with语句无法在编译时就确定，属性到底归属哪个对象。

> 　　"use strict";
>
> 　　var v = 1;
>
> 　　with (o){ // 语法错误
> 　　　　v = 2;
> 　　}

**（2）创设eval作用域**

正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval作用域。

正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。

> 　　"use strict";
>
> 　　var x = 2;
>
> 　　console.info(eval("var x = 5; x")); // 5
>
> 　　console.info(x); // 2

**4.3 增强的安全措施**

**（1）禁止this关键字指向全局对象**

> 　　function f(){
> 　　　　return !this;
> 　　}
> 　　// 返回false，因为"this"指向全局对象，"!this"就是false
>
> 　　function f(){
> 　　　　"use strict";
> 　　　　return !this;
> 　　}
> 　　// 返回true，因为严格模式下，this的值为undefined，所以"!this"为true。

因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。

> 　　function f(){
>
> 　　　　"use strict";
>
> 　　　　this.a = 1;
>
> 　　};
>
> 　　f();// 报错，this未定义

**（2）禁止在函数内部遍历调用栈**

> 　　function f1(){
>
> 　　　　"use strict";
>
> 　　　　f1.caller; // 报错
>
> 　　　　f1.arguments; // 报错
>
> 　　}
>
> 　　f1();

**4.4 禁止删除变量**

严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。

> 　　"use strict";
>
> 　　var x;
>
> 　　delete x; // 语法错误
>
> 　　var o = Object.create(null, {'x': {
> 　　　　　　value: 1,
> 　　　　　　configurable: true
> 　　}});
>
> 　　delete o.x; // 删除成功

**4.5 显式报错**

正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。

> 　　"use strict";
>
> 　　var o = {};
>
> 　　Object.defineProperty(o, "v", { value: 1, writable: false });
>
> 　　o.v = 2; // 报错

严格模式下，对一个使用getter方法读取的属性进行赋值，会报错。

> 　　"use strict";
>
> 　　var o = {
>
> 　　　　get v() { return 1; }
>
> 　　};
>
> 　　o.v = 2; // 报错

严格模式下，对禁止扩展的对象添加新属性，会报错。

> 　　"use strict";
>
> 　　var o = {};
>
> 　　Object.preventExtensions(o);
>
> 　　o.v = 1; // 报错

严格模式下，删除一个不可删除的属性，会报错。

> 　　"use strict";
>
> 　　delete Object.prototype; // 报错

**4.6 重名错误**

严格模式新增了一些语法错误。

**（1）对象不能有重名的属性**

正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。

> 　　"use strict";
>
> 　　var o = {
> 　　　　p: 1,
> 　　　　p: 2
> 　　}; // 语法错误



**（2）函数不能有重名的参数**

正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。

> 　　"use strict";
>
> 　　function f(a, a, b) { // 语法错误
>
> 　　　　return ;
>
> 　　}

**4.7 禁止八进制表示法**

正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。

> 　　"use strict";
>
> 　　var n = 0100; // 语法错误

**4.8 arguments对象的限制**

arguments是函数的参数对象，严格模式对它的使用做了限制。

**（1）不允许对arguments赋值**

> 　　"use strict";
>
> 　　arguments++; // 语法错误
>
> 　　var obj = { set p(arguments) { } }; // 语法错误
>
> 　　try { } catch (arguments) { } // 语法错误
>
> 　　function arguments() { } // 语法错误
>
> 　　var f = new Function("arguments", "'use strict'; return 17;"); // 语法错误

**（2）arguments不再追踪参数的变化**

> 　　function f(a) {
>
> 　　　　a = 2;
>
> 　　　　return [a, arguments[0]];
>
> 　　}
>
> 　　f(1); // 正常模式为[2,2]
>
> 　　function f(a) {
>
> 　　　　"use strict";
>
> 　　　　a = 2;
>
> 　　　　return [a, arguments[0]];
>
> 　　}
>
> 　　f(1); // 严格模式为[2,1]

**（3）禁止使用arguments.callee**

这意味着，你无法在匿名函数内部调用自身了。

> 　　"use strict";
>
> 　　var f = function() { return arguments.callee; };
>
> 　　f(); // 报错

**4.9 函数必须声明在顶层**

将来Javascript的新版本会引入"块级作用域"。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。

> 　　"use strict";
>
> 　　if (true) {
>
> 　　　　function f() { } // 语法错误
>
> 　　}
>
> 　　for (var i = 0; i < 5; i++) {
>
> 　　　　function f2() { } // 语法错误
>
> 　　}

**4.10 保留字**

为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。

使用这些词作为变量名将会报错。

> 　　function package(protected) { // 语法错误
>
> 　　　　"use strict";
>
> 　　　　var implements; // 语法错误
>
> 　　}

此外，ECMAscript第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的const保留字，也是不能作为变量名的。

##### this

> this是一个对象的别名，它指向一个对象，对象没有作用域，作用域与函数对应，this和对象对应

###### 普通函数的this指向

在普通函数中，谁调用它，this就指向它

**1.函数调用模式**

当一个函数并非一个对象的属性时，那么它就是被当做函数来调用的。在此种模式下，this被绑定为全局对象，在浏览器环境下就是window对象

![img](https://img-blog.csdn.net/20171002123510524?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**2.方法调用模式**

当函数被保存为一个对象的属性时，它就可称为这个对象的方法。当一个方法被调用时，this被绑定到这个对象上。如果调用表达式包含一个提取属性的动作（. 或 []），那么它被称为方法调用

![img](https://img-blog.csdn.net/20171002123553864?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

这里的this指向的对象是o，因为调用这个sayName()函数是通过o.sayName()执行的。

![img](https://img-blog.csdn.net/20171002123750147?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

因为是o.b调用的这个函数，所以指向b这个对象

![img](https://img-blog.csdn.net/20171002123841483?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

同理，因为是o.b调用的这个函数，所以指向b这个对象

![img](https://img-blog.csdn.net/20171002123856888?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

t是全局变量，在全局环境下执行，this指向window

**3.构造函数调用模式**

如果在一个函数前面加上new关键字来调用，那么就会创建一个连接到该函数的prototype成员的新对象，同时，this会被绑定到这个新对象上。这种情况下，这个函数就可以成为此对象的构造函数。

![img](https://img-blog.csdn.net/20171002123927881?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

在构造函数，new出一个对象时，this指向这个构造函数，new关键字会改变this的指向

![img](https://img-blog.csdn.net/20171002123959469?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

当用new关键字，返回的是一个对象，this指向的就是那个返回的对象；

如果返回的不是对象，this还是指向函数的实例，虽然null属于对象，但是返回null依然指向函数实例

![img](https://img-blog.csdn.net/20171002124026509?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

![img](https://img-blog.csdn.net/20171002124054904?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

![img](https://img-blog.csdn.net/20171002124108493?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

![img](https://img-blog.csdn.net/20171002124139423?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

![img](https://img-blog.csdn.net/20171002124150542?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

![img](https://img-blog.csdn.net/20171002124211762?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**4.apply和call调用模式**

JS中，函数也是对象，所有函数对象都有两个方法：apply和call，这两个方法可以让我们构建一个参数数组传递给调用函数，也允许我们改变this的值

![img](https://img-blog.csdn.net/20171002124236144?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

在全局范围内，this指向全局对象（浏览器下指window对象）

对象函数调用时，this指向当前对象

全局函数调用时，应该是指向调用全局函数的对象。

使用new关键字实例化对象时，this指向新创建的对象

当用apply和call上下文调用的时候指向传入的第一个参数

**练习题**

![img](https://img-blog.csdn.net/20171002124257732?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

在执行person1.sayName()时，时方法调用模式，this代表person1这个对象

在执行person2.sayName()时，时方法调用，但是sayName，并没有执行，而是将sayName()这个函数赋值给fun这个变量，fun是函数调用模式，this指向window，故输出全局的name

![img](https://img-blog.csdn.net/20171002124311867?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

执行console.log(b.n)时，b对象有自己的属性n值

执行console.log(c.n)时，c对象没有自己的属性n值，会向上查找，找的A对象中的属性n值

![img](https://img-blog.csdn.net/20171002124329433?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXZlcnd5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

vargetColor=test.getColor相当于把方法函数赋值给全局变量，

故getColor()中的this指向window

test.getColor()是方法调用

注：`原型对象里面的方法的this指向实例`

###### 箭头函数的this指向

`箭头函数中没有this,所以它会往上一层去找，如果都没有找到，this就指向window对象，如果找到，那么就找到的this作为自己的this`,`并且call、apply、bind都不能改变它的this指向，因为箭头函数根本没有this`

注意：作用域是对于函数来说的

箭头函数的this指向取决于该函数定义所在的作用域，它会捕获其所在（即定义的位置，也就是该作用域所处的对象）上下文（所处作用域的this）的this值， 作为自己的this值

例：

```
 let obj = {
      name: 'mike',
      fun : function () {
        console.log(this.name); //mike
        return ()=>{
          console.log(this.name); //mike
        }
      }
    }
    obj.fun()() 
```

```
 var name = 'window'
    let obj = {
      name: 'mike',
      fun : ()=>{
        console.log(this.name); //window
      }
    }
    obj.fun()
```

上面第一个例子的箭头函数定义在obj对象的一个方法内，这个方法是有作用域的，而且这个作用域处于obj对象内，所以箭头函数会指向obj对象，

第二个例子，虽然这个箭头函数定义在obj对象中，但是对象是没有作用域的，然后会往下一层找，找到了window,所以this指向了window对象

`如果箭头函数定义在构造函数或者类中，由于箭头函数没有this,那么就会往上找，找到构造函数的this,而构造函数的this为新new的实例，所以箭头函数的`

`this指向实例对象`

```
	function Demo(a) {
           this.a=a
           let arrow = ()=>{
             console.log(this);   //Demo {a: "test"}实例
           }
           let fun = function () {
             console.log(this);  //window对象
           }
           arrow()
           fun()
         }
    new Demo('test')
```

###### 回调函数的this指向

首先先说下正常的 this 指向问题

什么是 this：自动引用正在调用当前方法的.前的对象。

this指向的三种情况

1. obj.fun()   fun 中的 this->obj ，自动指向.前的对象

2. new Fun()  Fun 中的 this->正在创建的新对象，new 改变了函数内部的 this 指向，导致 this 指向实例化 new 的对象

3. fun() 和匿名函数自调  this 默认->window，函数内部的 this，this 默认是指向 window 的

再说回调函数中的 this 指向问题，我们先来看一个例子

```
<script>
    var Bob={
        sname:"鲍勃",
        friends:["Jack","Rose","Tom","Jerry"],
        intr(){
          this.friends.forEach(function(ele){
               console.log(this.sname+"认识"+ele);
          });
        }
    }
    Bob.intr();
</script>
```

看结果：

undefined认识Jack
		undefined认识Rose
	   undefined认识Tom
	    undefined认识Jerry

回调函数中的this默认是指向window的，因为本质上是在函数内callback,并没有 . 前的对象调用，当然我们必须要看这个函数是如何处理这个回调函数的，如果在函数内部再把这个回调函数赋值给新对象的

属性，然后再调用，那么就不是window了，在严格模式下（vue默认开启严格模式）， this为undefined

如何解决：

使用箭头函数

```
     <script>
         var Bob={
             sname:"鲍勃",
             friends:["Jack","Rose","Tom","Jerry"],
             intr(){
               this.friends.forEach(ele=>{
                    console.log(this.sname+"认识"+ele);
               });
             }
         }
         Bob.intr();
     </script>
```

结果是：

鲍勃认识Jack
	  鲍勃认识Rose
	  鲍勃认识Tom
	  鲍勃认识Jerry

可以看出箭头函数内的this自动指向了回调函数外层的 this 。

箭头函数中的 this:

　　函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。

　　this 指向的固定化，并不是因为箭头函数内部有绑定 this 的机制，实际原因是箭头函数根本没有自己的 this，导致内部的 this 就是外层代码块的 this。正是因为它没有 this，所以也就不能用作构造函数。

也可使用bind永久绑定this

```
var Bob={
        sname:"鲍勃",
        friends:["Jack","Rose","Tom","Jerry"],
        intr(){
          this.friends.forEach(function(friend){
               console.log(this.sname+"认识"+friend);
          }.bind(this));
        }
    }
    Bob.intr();
```

##### 闭包

> 闭包并不是js自带的内容，闭包的产生是为了解决外层作用域无法获取内层作用域变量等作用域问题

那么闭包到底是什么呢？

我们首先知道闭包有3个特性：

①函数嵌套函数

②函数内部可以引用函数外部的参数和变量

③参数和变量不会被垃圾回收机制回收

**闭包本质就是一个函数里面再定义一个函数，内层函数引用外层函数定义的变量，这样就可以解决许多问题。**

**问题一（外部作用域无法访问内部作用域的问题）**

​		内层函数使用return函数返回

​		<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201221114726294.png" alt="image-20201221114726294" style="zoom:67%;" />

​		在这段代码中，a()中的返回值是一个匿名函数，这个函数在a()作用域内部，所以它可以获取a()作用域下变量name的值，将这个值作为返回值赋给全局作用域下的变量b,实现了在全局变量下获取到局部变量中的变量的值

​		这样就可以访问其他函数定义的变量了，当然我们一定会有这样一个疑问：为什么不直接return 有name,而是使用一个匿名函数包裹返回？

​		直接return的确是可以的，但是获取到的变量与那个函数的变量就无关了，如果使用闭包获取到

​		的函数，那么仍然是使用返回函数的作用域，这样就可以延长函数作用域的作用周期

再来看一个闭包的经典例子

 <img src="https://img2018.cnblogs.com/blog/551750/201812/551750-20181212101629347-1385426172.jpg" alt="img" style="zoom: 80%;" />

一般情况下，在函数fn执行完后，就应该连同它里面的变量一同被销毁，但是在这个例子中，匿名函数作为fn的返回值被赋值给了fn1，这时候相当于fn1=function(){var n = 0 ... }，并且匿名函数内部引用着fn里的变量num，所以变量num无法被销毁，而变量n是每次被调用时新创建的，所以每次		fn1执行完后它就把属于自己的变量连同自己一起销毁，于是乎最后就剩下孤零零的num，于是这里		就产生了内存消耗的问题



**问题二、（异步函数问题）**

写一个for循环，让它按顺序打印出当前循环次数

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201221124224881.png" alt="image-20201221124224881" style="zoom:80%;" />

按照预期它应该依次输出1 2 3 4 5，而结果它输出了五次5，这是为什么呢？原来由于js是单线程的， 所以在执行for循环的时候定时器setTimeout被安排到任务队列中排队等待执行，而在等待过程中for	  循环就已经在执行，等到setTimeout可以执行的时候，for循环已经结束，i的值（函数内部没有该变量，所以只能到外部变量寻找，而这是的外部变量i已经变为5了）也已经变成5，所以打印出来五个5，那么我们为了实现预期结果应该怎么改这段代码呢？（ps:如果把for循环里面的var变成let，也能实现预期结果）

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201221125001618.png" alt="image-20201221125001618" style="zoom:80%;" />

在这段代码中，相当于同时启动5个定时器，i*100是为5个定时器分别设置了不同的时间，同时启动， 	  但是执行时间不同，每个定时器间隔都是100毫秒，实现了每隔100毫秒就执行一次打印的效果。由于

每个for循环生成了5个独立的函数作用域，然后再把每次循环的变量通过参数传进来，而且每个函数的都有独立的作用域，所以函数内部会优先引用函数作用域的变量

**经典题目：闭包作为参数传递**

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201221133117212.png" alt="image-20201221133117212" style="zoom: 80%;" />

在这段代码中，函数fn1作为参数传入立即执行函数中，在执行到fn2(30)的时候，30作为参数传入fn1中，这时候if(x>num)中的num取的并不是立即执行函数中的num，而是取创建函数的作用域中的num这里函数创建的作用域是全局作用域下，所以num取的是全局作用域中的值15，即30>15，打印30

 原因：虽然看起来fn1是在立即执行函数的作用域里面，但实际上并不是，这里只是调用，fn1仍然处于全局内，所以num还是会去全局中很早，而不会在立即执行函数中找

最后总结一下闭包的好处与坏处

**好处**

①保护函数内的变量安全 ，实现封装，防止变量流入其他环境发生命名冲突

②在内存中维持一个变量，可以做缓存（但使用多了同时也是一项缺点，消耗内存）

③匿名自执行函数可以减少内存消耗

**坏处**

①其中一点上面已经有体现了，就是被引用的私有变量不能被销毁，增大了内存消耗，造成内存泄漏，解决方法是可以在使用完变量后手动为它赋值为null；

②其次由于闭包涉及跨域访问，所以会导致性能损失，我们可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响

**使用在单例模式上**

```
//使用闭包进行改造
    var createSingle = (function () {
      var _unique = null
      return function () {
        if (_unique === null) {
          _unique = {a: 1}
        }
        return _unique
      }
    })()

    var a = createSingle()
    var b = createSingle()
    console.log(a === b);  //true
```



##### 原型链

###### ㈠原型 Prototype

**⑴我们所创建的每一个函数，解析器都会向函数中添加一个属性Prototype**

  		这个属性对应着一个对象，这个对象就是我们所谓的原型对象

**⑵如果函数作为普通函数调用prototype没有任何作用**

  		当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性
  	
  		指向该构造函数的原型对象，我们可以通过_ _proto_ _来访问

**⑶示例：**

```
     function MyClass(){
     }
     var mc = new MyClass();
     var mc2 = new MyClass();
     console.log(mc2.__proto__ == MyClass.prototype);
```

返回结果为：true；

**⑷原型对象就相当于一个公共的区域，所有同一类的实例都可以访问到这个原型对象**

  我们可以将对象中共有的内容，统一设置到原型对象中。

**⑸当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，**

  如果没有则会去原型对象中寻找，如果找到则直接使用（！important）

**⑹具体图形演示：**

***\*![img](https://img2020.cnblogs.com/blog/2029744/202009/2029744-20200912145335868-1772910806.png)

 **示例1：**

```
     function MyClass(){}//向MyClass的原型中中添加a属性
     MyClass.prototype.a = 123; 
     var mc = new MyClass(); 
     var mc2 = new MyClass(); 
     //向mc中添加a属性  
     mc.a = "我是mc中的a"; 
     console.log(mc.a);
     console.log(mc2.a);
     结果输出：
```

![img](https://img2020.cnblogs.com/blog/2029744/202009/2029744-20200912150836365-1277022884.png) 

**示例2：**

```
     function MyClass(){}//向MyClass的原型中中添加a属性
     MyClass.prototype.a = 123; 
     //向MyClass的原型中中添加一个方法
     MyClass.prototype.sayHello = function(){
          alert("hello");
     };
     var mc = new MyClass(); 
     var mc2 = new MyClass(); 
     //向mc中添加a属性  
     mc.a = "我是mc中的a"; 
     mc.sayHello();
```

 结果显示为：hello

**⑺以后我们创建构造函数时，可以将这些对象共有属性和方法，统一添加到构造函数的原型对象中，**

   这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了

 

###### ㈡显示原型与隐式原型

```
     function MyClass(){}
     //向MyClass的原型中添加一个name属性
     MyClass.prototype.name = "我是原型中的名字";
     var mc = new MyClass();
     console.log(mc.name);结果返回：我是原型中的名字
```

**⑴使用in检查对象中是否含有某个属性时，如果对象中没有但是原型中有，也会返回true**

  	console.log("name" in mc);
  	
  	 结果会返回:true

**⑵可以使用对象的hasOwnPrototype( )来检查对象自身是否含有该属性**

  	使用该方法只有当对象自身含有属性时，才会返回true
  	
  	 console.log(mc.hasOwnPrototype("age"));
  	
  	结果返回：true
  	
  	console.log(mc.hasOwnPrototype("hasOwnProperty"));
  	
  	 结果返回：false

**⑶原型对象也是对象，所以它也有原型**

   当我们使用一个对象的属性或方法时，会先在自身中寻找

   自身中如果有，则直接使用

   如果没有则去原型对象中寻找，如果原型对象中有，则使用

   如果没有则去原型的原型中寻找，直到找到Object对象的原型

   Object对象的原型是没有原型的。

   如果在Object中依然没有找到，则返回undefined

**(3）显式原型与隐式原型**

　　1）每个函数function都有一个prototype,即显式原型（属性）

　　2}每个实例对象都有一个proto，可称为隐式原型（属性）

　　3）对象的隐式原型的值为其对应构造函数的显示原型的值

　　4）总结：

　　　　函数的prototype属性：在定义函数之前自动添加的，默认值是一个空Object对象

　　　　实例对象的proto属性：创建对象时自动添加的，默认值为构造函数的prototype属性值

　　程序员能直接操作显式原型，但不能直接操作隐式原型（ES6之前）

 **原型链**

​		图例：

​		

###### （三）原型链

　　**1）访问一个对象的属性时，**

　　　　先在自身属性查找，找到返回

　　　　如果没有，再沿着proto这条链上查找，找到返回

　　　　如果最终没找到，返回undefinded**

**<img src="https://img2020.cnblogs.com/blog/2029744/202009/2029744-20200915130429181-177209062.png" alt="img" style="zoom: 67%;" />**

 

 　<img src="https://img2020.cnblogs.com/blog/2029744/202009/2029744-20200915130453584-380716796.png" alt="img" style="zoom:67%;" />

 

 

函数/原型/实体对象的关系（图解）**

　　　　**<img src="https://img2020.cnblogs.com/blog/2029744/202009/2029744-20200915125627899-1269807046.png" alt="img" style="zoom:67%;" />**

 

 ![image-20201226214554980](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201226214554980.png)

##### 深浅拷贝

**1.深拷贝与浅拷贝的区别**

> 如何区分深拷贝与浅拷贝，简单点来说，就是假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。

**2.栈堆、基本数据类型、引用数据类型**
栈堆：存放数据的地方
基本数据类型：number,string,boolean,null,undefined.
引用数据类型(Object类)有常规名值对的无序对象{a:1}，数组[1,2,3]，以及函数等。

**3.浅拷贝**

```js
     let a= [0,1,2,3,4],b=a;
     console.log(a===b);
     a[0] = 1
     console.log(a,b)
     1234
```

![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZS1zdGF0aWMuc2VnbWVudGZhdWx0LmNvbS8zNDIvMjgyLzM0MjI4MjcyOTgtNWI5ZjQzOTg4ZWUyOF9hcnRpY2xleA?x-oss-process=image/format,png)

**3.深拷贝**（典型方法）

```js
     function deepClone(obj){
       let objClone = Array.isArray(obj)?[]:{};
       if(obj && typeof obj==="object"){
         for(key in obj){
              //判断ojb子元素是否为对象，如果是，递归复制
               if(obj[key]&&typeof obj[key] ==="object"){
                   objClone[key] = deepClone(obj[key]);
               }else{
                   //如果不是，简单复制
                   objClone[key] = obj[key];
               }
            }
       }
       return objClone;
     } 

     let a=[1,2,3,4],b=deepClone(a);
     a[0]=2;
     console.log(a,b);
```

![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZS1zdGF0aWMuc2VnbWVudGZhdWx0LmNvbS85NjkvMDAwLzk2OTAwMDQyMS01YjlmNDQ3NmIxZjY2X2FydGljbGV4?x-oss-process=image/format,png)
**4.引用类型和基本类型栈内存储**

**4.1基本类型**

![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZS1zdGF0aWMuc2VnbWVudGZhdWx0LmNvbS80MDYvMjY0LzQwNjI2NDU5MTYtNWI5ZjQ1M2QzODA2ZF9hcnRpY2xleA?x-oss-process=image/format,png)

**4.2引用类型**

![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZS1zdGF0aWMuc2VnbWVudGZhdWx0LmNvbS8xMDgvNjE0LzEwODYxNDAyNzctNWI5ZjQ1ODI1N2YwNV9hcnRpY2xleA?x-oss-process=image/format,png)

**5.JS中拷贝Array的slice和concat方法**

5.1.slice拷贝

```js
var a = [1,2,3];
var b = a.slice(); //slice
console.log(b === a);
a[0] = 4;
console.log(a);
console.log(b);
123456
```

![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZS1zdGF0aWMuc2VnbWVudGZhdWx0LmNvbS8xMTYvODEyLzExNjgxMjg3OTItNWI5ZjQ3MTRhZTU1NV9hcnRpY2xleA?x-oss-process=image/format,png)
5.2.concat拷贝

```js
var a = [1,2,3];
var b = a.concat();  //concat
console.log(b === a);
a[0] = 4;
console.log(a);
console.log(b);
123456
```

![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZS1zdGF0aWMuc2VnbWVudGZhdWx0LmNvbS8xMDAvNTM2LzEwMDUzNjQwNDEtNWI5ZjQ3NWRkMGU0OF9hcnRpY2xleA?x-oss-process=image/format,png)
看到结果，如果你觉得，这两个方法是深拷贝，那就恭喜你跳进了坑里！
来看看有意思的例子吧

```js
var a = [[1,2,3],4,5];
var b = a.slice();
console.log(a === b);
a[0][0] = 6;
console.log(a);
console.log(b);
123456
```

![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZS1zdGF0aWMuc2VnbWVudGZhdWx0LmNvbS84NTMvOTU3Lzg1Mzk1NzY1LTViOWY0N2IzOTM1OTdfYXJ0aWNsZXg?x-oss-process=image/format,png)
可以看到`slice和contact对于第一层是深拷贝，但对于多层的时候，是复制的引用，所以是浅拷贝`
**6.JSON 对象的 parse 和 stringify都是深拷贝**（这个方法推荐使用，简单方便）

```js
var obj = {name:'cancan',age:23,company : { name : '阿里', address : '杭州'} };
var obj_json = JSON.parse(JSON.stringify(obj));
console.log(obj === obj_json);
obj.company.name = "cancan82";
obj.name = "haha";
console.log(obj);
console.log(obj_json);
1234567
```

![这里写图片描述](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZS1zdGF0aWMuc2VnbWVudGZhdWx0LmNvbS8yODkvOTA1LzI4OTkwNTU2NjEtNWI5ZjQ5MjFlMmMzM19hcnRpY2xleA?x-oss-process=image/format,png)

##### 对象处理



##### JSON

由于浏览器和服务器要经常传递数据，然后浏览器和服务器端所使用的语言不一定相同，

```
	var obj={"name":"孙悟空","age":18,"gender":"男"}//js对象
```

JS中的对象只有JS自己认识，其他语言不认识，所以对象不能以对象的方式直接传输

但是任何语言都能识别字符串，所以可以把JS对象转换成特殊字符串，然后在根据不同语言进行处理还原

```
	var obj='{"name":"孙悟空","age":18,"gender":"男"}'//js对象	
```

JSON分类：

​	1、对象{ }

​	2、数组[ ]

JSON中允许的值：

​	1、字符串

​	2、数值

​	3、布尔值

​	4、null

​	5、对象

​	6、数组

**JSON.parse()【从一个字符串中解析出json对象】**

例子：

//定义一个字符串

var data='{"name":"goatling"}'

//解析对象

JSON.parse(data)

结果是：

{name:"goatling"}

**JSON.stringify()【从一个对象中解析出字符串】**

var data={name:'goatling'}

JSON.stringify(data)

结果是：

'{"name":"goatling"}'

##### 正则表达式

> 正则表达式用于定义一些字符串的规则
>
> ​		计算机可以根据正则表达式来检查一个字符串是否符合规则
>
> ​		将字符串中符合规则的内容提取出来

正则表达式都能帮我们做什么？

​	1、数据隐藏（188****3456）

​	2、数据采集

​	3、数据过滤

​	4、数据验证（手机号，邮箱地址）

###### 创建正则表达式

**使用构造函数来创建正则表达式**

语法：

​	var 变量 = new RegExp("正则表达式",匹配模式");

​	使用typeof检查正则对象，会返回Object

​	在构造函数中可以传递一个`匹配模式`作为第二个参数

​			可以是：

​				i 忽略大小写

​				g 全局匹配模式

```
	//这个正则表达式可以来检查一个字符串中是否含有"a",并且忽略大小写
	var reg = new RegExp("a",'i')
	//这个正则表达式可以来检查一个字符串中是否含有"ab",并且忽略大小写
	var reg = new RegExp("ab",'i')
```

**使用字面量来创建正则表达式**

​		语法：var 变量 = /正则表达式/匹配模式

```
	var reg = new RegExp('a','i')
	var reg2 = /a/i; //等同于上面的创建方式
	console.log(reg2.test('a666'))  //true
```

`注：`

​	使用字面量的方式创建更加简单

​	使用构造函数创建更加灵活

###### 正则语法

​		1、**检查一个字符串是否含有“a"**

```
		//二者等价
		var reg = new RegExp('a') 
		var reg2 = /a/
```

​		2、**检查一个字符串中是否含有a或b**

```
		var reg = /a|b/    //使用 | 表示或者的意思
```

​		3、**检查一个字符串中是否含有字母**	

```
		var reg = /[ab]/   //[ ]里的内容也是或的关系，[ab] == a|b
		var reg2 = /[a-z]/  //[a-z] 任意小写字母
		var reg3 = /[A-Z]   //[A-Z] 任意大写字母
		var reg4 = /[A-z]/  //[A-z] 任意字母
		var reg5 = /[0-9]/  //[0-9] 任意数字
		console.log(reg.test("ae"))  //true
```

​		4、**检查一个字符串中是否含有abc或adc或aec**		

```
		var reg = /abc|adc|aec/
		var reg2 = /a[bde]c/   //二者等价
		console.log(reg2.test("aec"))  //true
		console.log(reg2.test("aeec"))  //false
```

​		5、**[^]除了**			

```
		var reg = /[^ab]/  //字符串除了"ab"都行
		var reg2 = /[^0-9]/  //字符串除了纯数字字符串
		console.log(reg.test("ab"))  //false
		console.log(reg.test("abc"))  //true
		console.log(reg2.test("abc"))  //true
		console.log(reg2.test("abc1"))  //false
```

​		6、**^检查一个字符串中是否以a开头**

​					^表示开头

```
		let reg = /^a/
		console.log(reg.test('fdsdfsfda')) //false
		console.log(reg.test('a45454sdhsadh'))  //true
```

​		7、**$ 检查一个字符串中是否以a结尾**

​					$表示结尾

```
		let reg = /a$/
		console.log(reg.test('fdsdfsfda')) //true
		console.log(reg.test('a45454sdhsadh'))  //false
		let reg2 = /^a$/
    		console.log(reg2.test('a')); //true
    		console.log(reg2.test('a4a')); //false
    		let reg = /^a|a$/   //a开头或者a结尾
    		console.log(reg.test('a322323'));  //true
```

​	8、**/^$/ 完全匹配正则表达式，而不是含有就行了**

```
		 let reg = /^a$/
           console.log(reg.test("a")) //true
           console.log(reg.test("aa")) //false
           let reg2 = /^aa$/
           console.log(reg2.test("a")) //false
           console.log(reg2.test("aa")) //true
           let reg3 = /^a123a$/
           console.log(reg3.test("a123a")); //true
```

​	9、**创建一个正则表达式，用来检查一个字符串是否是一个合法手机号**

​				手机号的规则（11位）：

​					1、以1开头

​					2、第二位3-9任意数字

​					3、第三位以后任意数字9个

​					^1  [3-9]  [0-9]{9}$

```
		var phoneStr = "17806707109"
         let reg = /^1[3-9][0-9]{9}$/  //如果以^开头$结尾，那么必须字段必须按规则严格匹配，不是含有就行了，{9}的意思是限定前面的[0-9]的数量
         console.log(reg.test(phoneStr)); //true
         console.log(reg.test(110));  //false
```

10、**检查一个字符串中是否含有 .**

​		. 表示任意字符

​		在正则表达式中使用\作为转义字符

​		\\.表示.

​		\\\\表示\

```
		var reg = /\./
		reg = /\\/
		console.log(reg.test("b.\\"))   //true
```

​		注意：使用构造函数时，由于它的参数是一个字符串，而\是字符串中的转义字符

​				 如果要使用\则需要使用\\\\来替代

11、**创建一个正则表达式检查一个字符串中是否含有单词child**		

```
	    let reg = /\bchild\b/
	    console.log(reg.test("hello child ren")) //true
	    console.log(reg.test("hello children")) //false
```

12、**去除掉字符串中前后的空格**

​				`去掉空格就是使用""来替换空格`

```
	    let str = prompt("请输入：")
         str = str.replace(/^\s*|\s*$/g,"")  
         console.log(str);
```

13、**检查邮件地址格式的正则表达式**

​		2249096563@qq.com

​		任意字母数字下划线  @  任意字母数字  .任意字母（2-5位）  任意字母（2-5位）

​		\w{3,}                     @  [A-z0-9]+      (\\.）[A-z]{2,5}){1,2}

```
	   let str = prompt("请输入：")
    	   var emailReg = /^\w{3,}@[A-z0-9]+(\.[A-z]{2,5}){1,2}$/
    	   console.log(emailReg.test(str));
```

 14、**排除含有lottery的行**

​		正则：/^(http)(.(?!lottery))*(html)$/

​		效果：

​		<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201229153839358.png" alt="image-20201229153839358" style="zoom:80%;" />

贪婪模式会尽可能匹配长

![image-20201229111303212](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201229111303212.png)

非贪婪模式不会，在*或者+后面加一个？就会变成非贪婪模式了

![image-20201229111253017](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201229111253017.png)

**量词**

​		-通过量词可以设置一个内容连续出现的次数

​		-量词只对它前面的一个内容起作用

​		-{n} 正好出现n次

​		-{m,n}出现m——n次

​		-{m,} 出现m次及以上

​       - + 至少一个，相当于{1，}

​		- * 0个或多个，相当于{0，}

​		- ？0个或1个，相当于{0，1}

```
          var reg = /a{3}/
          //ababab
          reg2 = /(ab){3}/
          reg3 = /ab{1,3}c/
          reg4 = /ab+c/
          reg5 = /ab*c/
          console.log(reg.test("aaabb"))  //true
          console.log(reg2.test("ababab"))  //true
          console.log(reg3.test("abc"))  //true
          console.log(reg3.test("abbbbc"))  //false
```

![image-20201228215248352](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201228215248352.png)

###### 正则表达式的组匹配

**什么是分组**

通俗来说，我理解的分组就是在正则表达式中用（）包起来的内容代表了一个分组，像这样的：

```
     var reg = /(\d{2})/
     reg.test('12');  //true
```

这里reg中的(/d{2})就表示一个分组，匹配两位数字

**分组内容的的形式**

一个分组中可以像上面这样有一个具体的表达式，这样可以优雅地表达一个重复的字符串

```
     /hahaha/
     /(ha){3}/
```

这两个表达式是等效的，但有了分组之后可以更加简洁。

分组中还可以有多个候选表达式，例如

```
     var reg = /I come from (hunan|hubei|zhejiang)/;
     reg.test('I come from hunan');   //true
     reg.test('I come from hubei');   //true
```

也就是说在这个分组中，通过|隔开的几个候选表达式是并列的关系，所以可以把这个|理解为或的意思

**分组的分类**

分组有四种类型

- 捕获型 ()
- 非捕获型 (?:)
- 正向前瞻型 (?=)
- 反向前瞻型 (?!)
  我们使用的比较多的都是捕获型分组，只有这种分组才会暂存匹配到的串

**分组的应用**

分组在正则中还算使用的比较广泛的，我们常用的是捕获型分组

- 捕获与引用

  - 被正则表达式捕获(匹配)到的字符串会被暂存起来，其中，由分组捕获到的字符串会从1开始编号，于是我们可以引用这些字符串：

  ```
  var reg = /(\d{4})-(\d{2})-(\d{2})/;
  var dateStr = '2018-04-18';
  reg.test(dateStr);  //true
  RegExp.$1   //2018
  RegExp.$2   //04
  RegExp.$3   //18
  ```

- 结合`replace方法`（match等方法也行）做字符串自定义替换

  - String.prototype.replace方法的传参中可以直接引用被捕获的串，比如我们想开发中常见的日期格式替换,例如后台给你返回了一个2018/04/18,让你用正则替换为2018-04-18，就可以利用分组

  ```
  var dateStr = '2018/04/18';
  var reg = /(\d{4})\/(\d{2})\/(\d{2})/;
  dateStr = dateStr.replace(reg, '$1-$2-$3') //"2018-04-18"
  ```

  不过这里需要注意的是/是需要用\转义的

  如果第二差数是以回调函数的形式的话，回调函数的第一个参数是`每次`匹配到的全部字符串

  ```
   function toCamelCase(str) {
              return str.replace(/-(.)/g, function (match, $1) {
                console.log(match,$1);    //-d d
                return $1.toUpperCase()
              })
            } 
          console.log(toCamelCase("abc-def-gh"));
  ```

  

- 反向引用

  - 正则表达式里也能进行引用，这称为反向引用：

  ```
       var reg = /(\w{3}) is \1/
       reg.test('kid is kid') // true
       reg.test('dik is dik') // true
       reg.test('kid is dik') // false
       reg.test('dik is kid') // false
  ```

  - 需要注意的是，如果引用了越界或者不存在的编号的话，就被被解析为普通的表达式

  ```
       var reg = /(\w{3}) is \6/;
       reg.test( 'kid is kid' ); // false
       reg.test( 'kid is \6' );  // true
  ```

- 非捕获型分组

  - 有的时候只是为了分组并不需要捕获的情况下就可以使用非捕获型分组，例如

  ```
       var reg = /(?:\d{4})-(\d{2})-(\d{2})/
       var date = '2012-12-21'
       reg.test(date)
       RegExp.$1 // 12
       RegExp.$2 // 21
  ```

- 正向与反向前瞻型分组

  - 正向前瞻型分组：你站在原地往前看，如果前方是指定的东西就返回true，否则为false

  ```
       var reg = /kid is a (?=doubi)/
       reg.test('kid is a doubi') // true
       reg.test('kid is a shabi') // false
  ```

  - 反向前瞻型分组：你站在原地往前看，如果前方不是指定的东西则返回true，如果是则返回false

  ```
       var reg = /kid is a (?!doubi)/
       reg.test('kid is a doubi') // false
       reg.test('kid is a shabi') // true
  ```

- 既然前瞻型分组和非捕获型分组都不会捕获，那他们有什么区别呢？先看例子：

```
     var reg, str = "kid is a doubi";
     reg = /(kid is a (?:doubi))/
     reg.test(str)
     RegExp.$1 // kid is a doubi

     reg = /(kid is a (?=doubi))/
     reg.test(str)
     RegExp.$1 // kis is a
```

也就是说非捕获型分组匹配到的字符串任然会被外层分组匹配到，而前瞻型不会，所以如果你希望在外层分组中不匹配里面分组的值的话就可以使用前瞻型分组了。

###### 正则表达式对象的方法

正则表达式的方法：

​		test()

​			-使用这个方法可以用来检查一个字符串是否符合正则表达式的规则，

​			 如果符合则返回true,否则返回false

```
		var reg = new RegExp("a",'i')
		console.log(reg.test("abcdjsk"))  //true
		console.log(reg.test("bcdjsk"))   //false	
```

​		exec()

​			-返回字符串中指定模式的字串，一次只能获取一个与之匹配的结果

```
		var reg = /[a-z]{3}/
		console.log(reg.exec("abcdjsk"))  //abc
		console.log(reg.exec("ab"))  //null
```



###### 支持正则表达式的String对象的方法

**search()**

​	**-可以搜索字符串中是否含有指定内容**

​	**-如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到则返回 -1**

​	**-它可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串，并返回检索到的字符下标**

​	**-search()只会查找第一个，即使设置全局匹配也没用**

```
	var str "hello abc hello aec"
	//搜索字符串中是否含有abc或aec或afc
	var result = str.search(/a[bef]c/)
	console.log(result)  //6
```

**match()**

​	**-可以根据正则表达式，从一个字符串中将符合条件的内容提取出来**

​	**-默认情况下我们的match方法只会找到第一个符合要求的内容，找到之后就停止检索了**

​			**我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容**

​			返回值以数组的形式返回

​			可以为一个正则表达式设置多个匹配模式，且顺序无所谓

​	-match()会将匹配到的内容封装到一个数组中返回，即时只查询到一个结果

```
	let str = "1a2b3cA"
	let result = str.match(/[a-z]/gi)  //全局匹配且忽略大小写
	console.log(result) //a,b,c,A
```

**replace()**

​	-可以将字符串中指定内容替换为新的内容

​	-参数：

​			1、被替换的内容,可以接收一个正则表达式作为参数

​			2、新的内容

返回值是改变后的数组

```
	let str = "78a898a98"
	let result = str.replace("a","@_@")
	console.log(result)  //78@_@898a98
	let result2 = str.replace(/a/g,"@_@")
	console.log(result2)  //78@_@898@_@98
	let result3 = str.replace(/a/g,"")
	console.log(result3)  //7889898
```

**split()**

​	**-可以将一个字符串拆分为一个数组**

​	**-方法中可以传递字符串或者一个正则表达式作为参数，如果参数是正则表达式，那么方法就会根据正则表达式来拆分字符串**

​	**-这个方法即使不指定全局匹配，也会全局拆分**

返回值是拆分后的数组

```
	var str = "1a2b3c4"
	//根据任意字母来将字符串进行拆分
	var result = str.split(/[A-z]/)
	console.log(result) //1,2,3,4
```

###### 常用的正常表达式

​	一、校验数字的表达式

1. 数字：^[0-9]*$

2. n位的数字：^\d{n}$

3. 至少n位的数字：^\d{n,}$

4. m-n位的数字：^\d{m,n}$

5. 零和非零开头的数字：^(0|[1-9][0-9]*)$

6. 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$

7. 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$

8. 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$

9. 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$

10. 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$

11. 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$

12. 非零的负整数：^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$

13. 非负整数：^\d+$ 或 ^[1-9]\d*|0$

14. 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$

15. 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$

16. 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$

17. 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$

18. 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$

19. 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$



二、校验字符的表达式

1. 汉字：^[\u4e00-\u9fa5]{0,}$

2. 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$

3. 长度为3-20的所有字符：^.{3,20}$

4. 由26个英文字母组成的字符串：^[A-Za-z]+$

5. 由26个大写英文字母组成的字符串：^[A-Z]+$

6. 由26个小写英文字母组成的字符串：^[a-z]+$

7. 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$

8. 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$

9. 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$

10. 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$

11. 可以输入含有^%&',;=?$\"等字符：[^%&',;=?$\x22]+ 12 禁止输入含有~的字符：[^~\x22]+

 

 

三、特殊需求表达式

1. Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$

2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?

3. InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$

4. 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$

5. 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$

6. 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}

7. 身份证号(15位、18位数字)：^\d{15}|\d{18}$

8. 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$

9. 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$

10. 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$

11. 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$

12. 日期格式：^\d{4}-\d{1,2}-\d{1,2}

13. 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$

14. 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$

15. 钱的输入格式：

16. 1.有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：^[1-9][0-9]*$

17. 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$

18. 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$

19. 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$

20. 5.必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：^[0-9]+(.[0-9]{2})?$

21. 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$

22. 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$

23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$

24. 备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里

25. xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$

26. 中文字符的正则表达式：[\u4e00-\u9fa5]

27. 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))

28. 空白行的正则表达式：\n\s*\r (可以用来删除空白行)

29. HTML标记的正则表达式：<(\S*?)[^>]*>.*?</\1>|<.*? /> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)

30. 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)

31. 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)

32. 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)

33. IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)

34. IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))

#### WebAPIs

##### 事件处理

###### 注册事件（绑定事件）

###### 删除事件（解绑事件）

###### DOM事件流

  ​	事件流描述的是从页面接受事件的顺序

  ​	事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流

​		1、JS代码只能执行捕获或者冒泡其中一个阶段。

​		2、onclick和`attachEvent( )（IE专属）`只能得到冒泡阶段

​		3、`如果addEventListener第三个参数是true，那么则处于捕获阶段 document -> html ->body ->father ->son`

​			 `如果addEventListener第三个参数是false(不写这个参数默认就是false),那么处于冒泡阶段 son ->father -body ->html ->document`

​		**事件冒泡**（事件默认触发冒泡）

​		IE的事件流叫做事件冒泡(event bubbling)，即事件开始时由最具体的元素(文档中嵌套层次最深的那个节点)接收，然后逐级向上传播到较为			不具体的节点(文档)

​		怎么用理解呢？直接上代码：

```
     <!DOCTYPE html>
     <html lang="en">
       <head>
         <meta charset="UTF-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1.0" />
         <title>Document</title>
         <style>
           #box {
             width: 100px;
             height: 100px;
             background-color: red;
             margin: 0 auto;
           }
         </style>
       </head>
       <body>
         <div id="box"></div>
         <script>
         	//给box绑定事件
           document.getElementById('box').addEventListener('click', function () {
             alert('我是box盒子触发的')
           },false)
           //给Body绑定事件
           document.body.addEventListener('click', function () {
             alert('我是body触发的')
           },false)
         </script>
       </body>
     </html>

```

​	效果图：

​		![](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201012232824865.png)

​	点击box,依次触发下面结果：

​		![image-20201012232917460](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201012232917460.png)

​	![image-20201012232941969](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201012232941969.png)

​	从上面例子可以看出：

​			当我点击了一下box盒子，实际上可以说是点击了body也行，因为整个页面都是body，所以你点哪里都可以说是点击了body,

​			那么问题来了，这两种说法都对，所以既会触发box盒子绑定的事件也会触发body绑定的事件。

​			但是，这两个事件触发的先后顺序可以规定好，box盒子，也就是子元素绑定的事件先执行，body，也就是父元素绑定的事件后执行

​	**事件捕获**

​		当我把上面addEventListener的第三个参数设置为true,那么就会处于捕获阶段

​		

```
      <script>
           //给box绑定事件
           document.getElementById('box').addEventListener('click', function () {
           alert('我是box盒子触发的')
           },false)
           //给Body绑定事件
           document.body.addEventListener('click', function () {
           alert('我是body触发的')
           },false)
      </script>
```

​		点击box,依次触发下面结果：

![image-20201012232941969](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201012232941969.png)

​		![image-20201012232917460](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201012232917460.png)

​	

​		这次事件触发的顺序和冒泡的相反，父元素先触发，子元素再触发

​		`注意：点击box盒子外的区域不会触发捕获和冒泡，因为，你只点击了body，这个就很明确，只会触发body绑定的事件`

###### 事件对象（event)

什么是事件对象？

• 就是当你触发了一个事件以后，对该事件的一些描述信息

• 例如：

   ° 你触发一个点击事件的时候，你点在哪个位置了，坐标是多少

   ° 你触发一个键盘事件的时候，你按的是哪个按钮

• 系统给我们自动创建一个对应的对象来描述这些信息，我们就把这个对象叫做 事件对象

• ``事件对象系统会自动传给我们的事件函数，在每一个事件处理函数的参数位置，默认第一个就是事件对象``

```
      var box = document.querySelector('.box')
         console.log(box)
         box.onclick = function (event){
             //event.X轴坐标点信息 根据页面来显示的
             console.log(event.x)
        }
```

- 这个事件对象我们可以自己命名 比如event、evt、e......
- 事件对象也有兼容性问题 ie678通过 window.event获取  兼容性的写法 event=event || window.event;

```
      box.addEventListener('click',function(event){
      		//当在正常浏览器中，event存在，那么就直接返回event,在ie678中，event=undefined,那么就会返回window.event
                event=event||window.event;
              })
```

**事件对象的常见属性和方法**

![image-20201013070952026](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201013070952026.png)

1.e.target与this

- e.target 返回的是触发事件的对象（元素）
- this返回的是绑定事件的对象（元素）
- e.target点击了哪个元素，就返回哪个元素；this哪个元素绑定了该事件就返回谁

```
    <div class="box"></div>
    <script>
      var box = document.querySelector('.box')
      box.addEventListener('click', function (e) {
        e = e || window.event
        console.log(event.target)
        console.log(this)
      })
    </script>
```

![image-20201013071729731](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201013071729731.png)

2、返回事件类型（type）

```
     <div class="box"></div>
         <script>
           var box = document.querySelector('.box')
           box.addEventListener('click', function (e) {
             e = e || window.e
             console.log(e.type)
           })
         </script>
```

​	![image-20201013072253545](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201013072253545.png)

3、阻止默认行为（事件），让链接不跳转或者提交按钮不提交

```
      <a href="http://www.baidu.com">百度一下</a>
         <script>
           var a = document.querySelector('a')
           a.addEventListener('click', function (e) {
             e = e || window.e
             e.preventDefault()
           })
         </script>
```

这样链接就不会跳转了

**鼠标事件对象**

![img](https://img2018.cnblogs.com/blog/1877004/202001/1877004-20200110211558558-1637153900.png)

```
       <script>
             // 鼠标事件对象 MouseEvent
             document.addEventListener('click', function(e) {
                 // 1. client 鼠标在可视区的x和y坐标
                 console.log(e.clientX);
                 console.log(e.clientY);
                 console.log('---------------------');
                 // 2. page 鼠标在页面文档的x和y坐标
                 console.log(e.pageX);
                 console.log(e.pageY);
                 console.log('---------------------');
                 // 3. screen 鼠标在电脑屏幕的x和y坐标
                 console.log(e.screenX);
                 console.log(e.screenY);
             })
         </script>
```



###### 阻止事件冒泡

事件方法默认只会触发冒泡，并不会触发捕获，所以并不需要阻止捕获，只需要阻止冒泡

事件冒泡：开始由最具体的元素接收，然后逐级向上传播到DOM最顶层节点。

阻止事件冒泡的的两种方式

**标准写法：利用事件对象里面的stopPropagation()方法**

> 在子元素的事件方法中加上e.stopPropagation();

非标准写法：IE6-8利用事件对象cancelBubble属性

> 在子元素的事件方法中加上e.cancelBubble=true;

阻止事件冒泡的兼容性解决方案

```
 	<a href="http://www.baidu.com">百度一下</a>
    <script>
      var a = document.querySelector('a')
      a.addEventListener('click', function (e) {
        if (e && e.stopPropagation) {
          e.stopPropagation()
        } else {
          window.event.cancelBubble = true
        }
      })
    </script>
```

###### 事件委托（代理，委派）

事件委托也称为事件代理，在jQuery里面称为事件委派

事件委托的原理：

​		`不是每个节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点`

​		案例：给ul注册事件，然后利用事件对象的target来找到当前点击的li,因为点击li,事件会冒泡到ul上，

​					ul由注册事件，就会触发事件监听器

​		**注意：e.target指的是触发事件的最上层元素，这个没有争议**

```
       <ul>
           <li>我是第一个li</li>
           <li>我是第二个li</li>
           <li>我是第三个li</li>
         </ul>
         <script>
           var ul = document.querySelector('ul')
           ul.addEventListener('click', function (e) {
             e = e || window.event
             //e.target指的是触发事件的最上层元素
             e.target.style.backgroundColor = 'pink'
           })
         </script>
```

![image-20201013085116175](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201013085116175.png)

事件委托的作用

​		我们只操作绑定了一个事件，提高了程序的性能

###### 常用的鼠标事件

![img](https://img2020.cnblogs.com/blog/2106211/202009/2106211-20200921233132391-803944683.png)

1、禁止鼠标右击菜单

​		contextmenu主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单

```
      document.addEventListener('contextmenu', function (e) {
             e.preventDefault()
           })
```

2、禁止选中文字

​	selectstart

```
      document.addEventListener('selectstart', function (e) {
             e.preventDefault()
           })
```

3、mousemove只要我们鼠标移动1px 就会触发这个事件

###### 常用的键盘事件

1.keyup 按键弹出的时候触发

　document.onkeyup = function(){

　　　console.log(' 我弹起了 ');

　}

2.keydown 按键按下的时候触发 能识别功能键 比如 Ctrl shift 左右箭头

　document.addEventListener('keydown',function(){

　　　console.log('我按下了down');

　})

3.keypress 按键按下的时候触发 不能识别功能键 比如 Ctrl shift  左右箭头

　document.addEventListener('keypress',function(){

　　　console.log('我按下了keypress');

　})

4.三个事件的执行顺序：keydown - - keypress - - keyup

5.键盘事件对象 keyCode 返回该键的 ASCII 值

6.keydown 和 keyup 不区分 字母大小写 keypress 区分字母大小写

　document.addEventListener('keydown',function(e){

　　　if( e.keyCode === 65 ){

　　　　　alert("按下了 a 键");

　　　}else{

　　　　　alert('没有按下 a 键 ');

　　　}

　})

`注意：keydown和keypress在文本框里面的特点：他们两个事件触发的时候，文字还没有落入文本框`

​		 `keyup事件触发的时候，文字已经落入文本框里面了`

##### DOM浏览器对象模型

###### BOM概述

1. 什么是BOM

   BOM(Browser Object Model)即浏览器对象模型，它提供了独立与内容而与浏览器窗口进行交互的对象，其核心对象是window.

   BOM由一系列相关的对象构成，并且每个对象都提供了很多方法和属性。

   BOM缺乏标准，javascript语法的标准化组织是ECMA,DOM的标准化组织是W3C，BOM最初是Netscape浏览器的一部分

   ![img](https://img-blog.csdn.net/20180310174632251?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2FveXVhbjEwNDQ3MDQ0NDY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

   <img src="https://img-blog.csdnimg.cn/20190128131908530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjYyMjYx,size_16,color_FFFFFF,t_70" alt="BOM 对象示意图" style="zoom:80%;" />

   window对象是浏览器的顶级对象，它具有双重角色。

   1、它是JS访问浏览器窗口的一个接口

   2、它是一个全局对象。定义在全局作用域中的变量、函数都会变成window对象的属性和方法。

   ​	 在调用的时候省略window,前面学习的对话框都属于window对象方法，如alert()、prompt().

   ​	let str = prompt("请输入：")
   
   ​	console.log(str)   //输入的内容
   
   <img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201228184222822.png" alt="image-20201228184222822" style="zoom:67%;" />
   
   ![image-20201228184236747](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201228184236747.png)
   
   `注意：window下的一个特殊属性window.name,这个属性为空，所以尽量不要定义name这个变量`
   
   

###### window对象的常见事件

1、窗口加载事件

```
     window.onload = function() { }
     或者
     window.addEventListener("load", function(){})	
```

​	window.onload是窗口（页面）加载事件，当文档内容完全加载完会触发该事件（包括图像、脚本文件、css文件等），就调用的处理函数。

​	**注意：**

​	1.有了window.onload就可以把js代码写在页面元素的上方，因为onload是等页面内容全部加载完毕，再去执行处理函数。

​	2.window.onload**传统注册事件方式**只能写一次，如果有多个，以最后一个window.onload为准。

​	3.如果使用addEventListener则没有限制。

​	**DOMContentLoaded事件**

```
	document.addEventListener('DOMContentLoaded', function(){})
```

​	DOMContentLoaded事件触发时，仅当DOM加载完毕，不包括样式表、图片、flash等等。IE9以上才支持。

​	如果页面的图片很多的话，从用户访问到onload触发可能需要较长的时间，交互效果就不能实现，必然会影响用户的体验，
​		  此时用DOMContentLoaded事件比较合适。

2、调整窗口大小事件

```
     window.onresize = function() { }
     window.addEventListener("resize", function(){});
```

​	window.onresize是调整窗口大小加载事件，当触发时就调用的处理函数。

​	**注意：**

​	1.只要窗口大小发生像素变化，就会触发这个事件。

​	2.`我们经常利用这个事件完成响应式布局`。window.innerWidth当前屏幕的宽度。

###### window对象常见的方法

1、open(),新建一个浏览器窗口

​	**语法：**

window.open([URL], [窗口名称], [参数字符串])

**参数说明:**

URL：可选参数，在窗口中要显示网页的网址或路径。如果省略这个参数，或者它的值是空字符串，那么窗口就不显示任何文档。

窗口名称：可选参数，被打开窗口的名称。

  1.该名称由字母、数字和下划线字符组成。
  	  2."_top"、"_blank"、"_self"具有特殊意义的名称。
  		  _blank：在新窗口显示目标网页
           _self：在当前窗口显示目标网页
           _top：框架网页中在上部窗口中显示目标网页
  	   3.相同 name 的窗口只能创建一个，要想创建多个窗口则 name 不能相同。
  	   4.name 不能包含有空格。

参数字符串：可选参数，设置窗口参数，各参数用逗号隔开。	

###### 定时器

**两种定时器**

window对象给我们提供了两个非常好用的方法-定时器

- setTimeout()
- setInterval()

**setTimeout()定时器**

```
	window.setTimeout(调用的函数，[延迟的毫秒数])；
```

setTimeout()方法用于设置一个定时器，该定时器在定时器到期后执行调用函数

语法规范：window.setTimeout(调用函数，延迟时间)；

1、这个window在调用的时候可以省略

2、这个延时时间单位是毫秒 但是可以省略，如果省略默认的是0

3、这个调用函数可以直接写函数，也可以引用函数，写函数名

4、页面中有很多的定时器，我们经常给定时器加标识符（名字）

例：

```
	var timer1=setTimeout(function(){
		console.log('时间到了')
	},2000)
	function callback(){
	console.log('爆炸了')
	}
	var timer2=setTimeout(callback,3000)//引用函数，直接写函数名
```

###### this

this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，一般情况下this的最终指向的是那个调用它的对象

1、全局作用域或者普通函数中this指向全局对象window(注意定时器里面的this指向window)

```
	console.log(this)//window
	function fn(){
		console.log(this)
	}
	window.fn()//window
	setTimeout(function(){
		console.log(this)
	},1000)//window
```

2、方法调用者谁调用this指向谁

3、构造函数中this指向构造函数的实例

###### JS执行机制

JS是单线程

javascript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。这是因为javascript这门脚本语言诞生的使命所致——javascript是为处理页面中用户的交互，以及操作DOM而诞生的。比如我们对某个DOM元素进行添加和删除操作，不能同时进行。应该先进行添加，之后再删除。 

###### location对象

###### navigator对象history对象

###### 储存对象

Web 存储 API 提供了Cookie, sessionStorage （会话存储） 和 localStorage（本地存储）两个存储对象来对网页的数据进行添加、删除、修改、查询操作。

- Cookie        大小4kb

- localStorage 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。   大小5MB
- sessionStorage 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。  大小5MB

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201111104922186.png" alt="image-20201111104922186" style="zoom:80%;" />

> sessionStorage使用实例：

```
     // 存储
     sessionStorage.setItem("lastname", "Smith");
     // 检索
     document.getElementById("result").innerHTML = sessionStorage.getItem("lastname");
```

> 语法

```
	window.sessionStorage
```

保存数据语法：

```
	sessionStorage.setItem("key", "value");
```

读取数据语法：

```
	var lastname = sessionStorage.getItem("key");
```

删除指定键的数据语法：

```
	sessionStorage.removeItem("key");
```

删除所有数据：

```
	sessionStorage.clear();
```

> localStorage使用实例：

```
     // 存储
     localStorage.setItem("lastname", "Smith");
     // 检索
     document.getElementById("result").innerHTML = localStorage.getItem("lastname");
```

> 语法

```
window.localStorage
```

保存数据语法：

```
localStorage.setItem("key", "value");
```

```
 sessionStorage.key = 'value'   //用这个也行
```

读取数据语法：

```
var lastname = localStorage.getItem("key");
```

```
var lastname = localStorage.key   //用这个也行
```

删除数据语法：

```
localStorage.removeItem("key");
```

`需要注意的是：sessionStorge和localStorge只能储存字符串，储存对象或者数组都需要先使用JSON.stringify()处理，取出使用JSON.parse()再转换为对象或者说组`

**localstorage可以实现多页面交互**

示例：

index1.html:

```
     <!DOCTYPE html>
     <html lang="en">
     <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
     </head>
     <body>
       <input type="text" id="input">
       <script>
         document.getElementById('input').onblur = function () {
           localStorage.setItem('demo',this.value)
         }
       </script>
     </body>
     </html>
```

index2.html

```
     <!DOCTYPE html>
     <html lang="en">
     <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
     </head>

     <body>
       <input type="text" id="val">
       <script>
         //只要localsrorage数据发生变化了，就会触发storage这个事件
        window.addEventListener('storage',function (e) {
          console.log(e);
          document.getElementById('val').value = e.newValue
        })
       </script>
     </body>
     </html>
```



#### ES6

##### 剩余参数

![image-20201022182220697](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022182220697.png)

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022182452793.png" alt="image-20201022182452793" style="zoom:80%;" />

##### 拓展运算符（重要）

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022182748232.png" alt="image-20201022182748232" style="zoom:80%;" />

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022183003525.png" alt="image-20201022183003525" style="zoom:80%;" />

![image-20201022183141205](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022183141205.png)

array.push方法可以一次性插入多个以逗号分割的参数

![image-20201022183302460](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022183302460.png)

拓展运算符也可以合并对象

基本用法：

```
     let age = {age: 15};
     let name = {name: "Amy"};
     let person = {...age, ...name};
     person;  //{age: 15, name: "Amy"}
```

**注意点**

`自定义的属性和拓展运算符对象里面属性的相同的时候：自定义的属性在拓展运算符后面，则拓展运算符对象内部同名的属性将被覆盖掉。`

```
     let person = {name: "Amy", age: 15};
     let someone = { ...person, name: "Mike", age: 17};
     someone;  //{name: "Mike", age: 17}
```

##### 模板字符串

1、模板字符串中可以`解析变量`。

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022162955617.png" alt="image-20201022162955617" style="zoom:80%;" />

在${}中可以使用变量，可以解析变量

2、模板字符串中可以`换行`

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022163123225.png" alt="image-20201022163123225" style="zoom:80%;" />

3、在模板字符串中可以`调用函数`

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022163255951.png" alt="image-20201022163255951" style="zoom:80%;" />

调用函数的位置的值是函数的返回值

##### String的扩展方法

**实例方法：startWith()和endsWidth()**

- startsWidth():表示参数字符串是否在原字符串的头部，返回布尔值

- endsWidth():表示参数字符串是否在原字符串的尾部，返回布尔值

  ![image-20201022163956969](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022163956969.png)

![image-20201022164120613](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022164120613.png)

输出结果：

![image-20201022164140769](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022164140769.png)

**实例方法：repeat()**

repeat方法表示将原字符串重复n次，返回一个新字符串

![image-20201022164351724](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022164351724.png)

##### Set集合

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201107225916736.png" alt="image-20201107225916736" style="zoom:67%;" />

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201107230324495.png" alt="image-20201107230324495" style="zoom:67%;" />

Set本身是一个构造函数，用来生成Set数据结构，可以使用for...of进行遍历

![image-20201022164650960](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022164650960.png)

Set函数可以接受一个数组作为参数，用来初始化。

![image-20201022164718108](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022164718108.png)

![image-20201022164800109](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022164800109.png)

输出结果：

![image-20201022164822446](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022164822446.png)

**数组去重**

  <script>
      var a = [1, 2, 3, 2, 1, 232, 11, 1]
      var s1 = new Set(a)
      console.log(s1)
      a = [...s1]
      console.log(a)
    </script>

输出结果：

![image-20201022180626354](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022180626354.png)

...s1这个括号运算符可以把数组,set数据结构通过分隔符，分割，详情请浏览`ES6->Array的扩展方法`

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022181447419.png" alt="image-20201022181447419" style="zoom:80%;" />

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022181854465.png" alt="image-20201022181854465" style="zoom:80%;" />

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201107231146591.png" alt="image-20201107231146591" style="zoom:67%;" />

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201107231429686.png" alt="image-20201107231429686" style="zoom:67%;" />

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201107231429686.png" alt="image-20201107231429686" style="zoom:67%;" />

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201107231528895.png" alt="image-20201107231528895" style="zoom:67%;" />

##### Map字典 

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201107231752402.png" alt="image-20201107231752402" style="zoom:67%;" />

**Maps 和 Objects 的区别**

- 一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。

- Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。

- Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。

- Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。

  当Map 中的 key

  **key 是字符串**

  ```
  var myMap = new Map();
  var keyString = "a string"; 
  myMap.set(keyString, "和键'a string'关联的值");
  myMap.get(keyString);    // "和键'a string'关联的值"
  myMap.get("a string");   // "和键'a string'关联的值"
                           // 因为 keyString === 'a string'
  ```

  **当key 是对象**

  ```
  var myMap = new Map();
  var keyObj = {}, 
  myMap.set(keyObj, "和键 keyObj 关联的值");
  myMap.get(keyObj); // "和键 keyObj 关联的值"
  myMap.get({}); // undefined, 因为 keyObj !== {}
  ```

  当**key 是函数**

  ```
  var myMap = new Map();
  var keyFunc = function () {}, // 函数
  myMap.set(keyFunc, "和键 keyFunc 关联的值");
  myMap.get(keyFunc); // "和键 keyFunc 关联的值"
  myMap.get(function() {}) // undefined, 因为 keyFunc !== function () {}
  ```

  当**key 是 NaN**

  ```
  var myMap = new Map();
  myMap.set(NaN, "not a number");
  myMap.get(NaN); // "not a number"
  var otherNaN = Number("foo");
  myMap.get(otherNaN); // "not a number"
  ```

  虽然 NaN 和任何值甚至和自己都不相等(NaN !== NaN 返回true)，NaN作为Map的键来说是没有区别的。



#### Ajax

## 设计模式

> Design Pattern

什么是设计模式？

> 假设有一个空房间，我们要日复一日地往里 面放一些东西。最简单的办法当然是把这些东西 直接扔进去，但是时间久了，就会发现很难从这 个房子里找到自己想要的东西，要调整某几样东 西的位置也不容易。所以在房间里做一些柜子也 许是个更好的选择，虽然柜子会增加我们的成 本，但它可以在维护阶段为我们带来好处。使用 这些柜子存放东西的规则，或许就是一种模式

学习设计模式，有助于写出可复用和可维护性高的程序

设计模式的原则是“找出 程序中变化的地方，并将变化封装起来”，它的关键是意图，而不是结构。

不过要注意，使用不当的话，可能会事倍功半。

### 设计原则

**单一职责原则（SRP）**

一个对象或方法只做一件事情。如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。

应该把对象或方法划分成较小的粒度

**最少知识原则（LKP）**

一个软件实体应当 尽可能少地与其他实体发生相互作用 

应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的 相互联系，可以转交给第三方进行处理

**开放-封闭原则（OCP）**

软件实体（类、模块、函数）等应该是可以 扩展的，但是不可修改

当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，尽量避免改动程序的源代码，防止影响原系统的稳定

### 工厂模式

> 工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型（抽象工厂）。
>
> 这个模式十分有用，尤其是创建对象的流程赋值的时候，比如依赖于很多设置文件等。并且，你会经常在程序里看到工厂方法，用于让子类定义需要创建的对象类型。
>
> 工厂模式根据抽象程度的不同可以分为：1.简单工厂 2.工厂方法 3.抽象工厂

#### 1.简单工厂

```
let  factory = function (role) {
function superman() {
    this.name ='超级管理员',
    this.role = ['修改密码', '发布消息', '查看主页']
}

function commonMan() {
    this.name = '普通游客',
    this.role = ['查看主页']
}

switch(role) {
    case 'superman':
    return new superman();
    break;
    case 'man':
    return new commonMan();
    break;
    default:
    throw new Error('参数错误')
}
}
let superman = factory('superman');
let man = factory('man');
```

在上述代码中,factory就是一个简单的工厂,该工厂中有二个构造函数分别对应不同的权限。我们只需要传递相应的参数就可以获取一个实例对象了。

简单工厂的优点: 你只需要传递一个合法的参数,就可以获取到你想要的对象,而无需知道创建的具体的细节。但是在函数内包含了所有对象的构造函数和判断逻辑的代码, 每次如果需要添加一个对象,那么我们需要新增一个构造函数,当我们需要维护的对象不是上面这2个,而是20个或者更多,那么这个函数将会成为超级函数,使得我们难以维护。所以简单工厂模式只适用于在创建时对象数量少,以及逻辑简单的情况。

#### 2.工厂方法

工厂方法模式本意是将实际创造的对象推迟到子类中,这样核心类就变成了抽象类。但是在js中很难像那些传统面向对象语言那样去实现抽象类,所以在js中我们只需要参考他的思想即可。

我们可以把工厂函数看成是一个工厂类。在简单模式我们,我们添加一个新的对象需要修改二处地方,在加入工厂方法模式以后,我们只需要修改一处即可。工厂方法的工厂类,他只做实例化这一件事情。我们只需要修改他的原型类即可。我们采用安全模式创建工厂对象。

```
   function Person(name) {
      this.name = name
    }
    Person.prototype.getName = function () {
      console.log(this.name);
    }
    function Car(model) {
      this.model = model
    }
    Car.prototype.getModel = function () {
      console.log(this.model);
    }
    function factory(type, param) {
      if (this instanceof create) {
        return new this[type](param)
      } else {
      	//处理使用factory函数忘记加new的情况
        return new factory(type, param)
      }
    }
    create.prototype = {
      person: Person,
      car: Car
    }
    var person1 = new factory('person', 'zhang san')
    var car1 = factory('car', 'Benz')
    console.log(person1);   // Person {name: "zhang san"}
    console.log(car1);	   //Car {model: "Benz"}
    person1.getName()	   //zhang san
    car1.getModel()		   //Benz
```

在上述代码中要是忘记加new了, 那么我们就获取不到Person，Car等构造函数了,使用安全模式可以很好的解决这个问题。

**什么时候使用工厂模式**

工厂模式在应用于以下情况时尤其有用：

当我们创建的对象或组件涉及到了很高的复杂度。当我们需要根据所处的环境生成不同的对象实例时。当我们处理含有相同属性的对象或组件时。当创建的对象是其他对象的实例，而且要求它们有一致的API接口时。有利于解耦。

### 建造者模式

> 建造者模式可以将一个复杂的对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。也就是说如果我们用了建造者模式，那么用户就需要指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需要知道了。建造者模式实际就是一个指挥者，一个建造者，一个使用指挥者调用具体建造者工作得出结果的客户。
>
> 建造者模式主要用于“分步骤构建一个复杂的对象”，在这其中“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。

**建造者模式的作用和注意事项**

模式作用：

1.分步创建一个复杂的对象

2.解耦封装过程和具体创建组件

3.无需关心组件如何组装

注意事项：

1.一定要一个稳定的算法进行支持

2.加工工艺是暴露的

**普通代码**

```
     <!DOCTYPE html>
     <html lang="en">
     <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
     </head>
     <body>
       <script>
         // 应聘者信息
         var data = [
           {
             name: 'zhang san',
             age: 23,
             work: 'engineer'
           },
           {
             name: 'li si',
             age: 26,
             work: 'teacher'
           },
           {
             name: 'wang wu',
             age: 13,
             work: 'xxx'
           }
         ]
         //生成应聘者实例的类
         function Candidate(param) {
           var _candidate = {}
           _candidate.name = param.name
           _candidate.age = param.age
           _candidate.firstName = _candidate.name.split(' ')[0]
           _candidate.secondName = _candidate.name.split(' ')[1]
           _candidate.work = {}
         	function switchFun(work) {
             switch (work) {
               case 'engineer':
                 _candidate.work.name = '工程师';
                 _candidate.work.description = '热爱编程';
                 break;
               case 'teacher':
                 _candidate.work.name = '教师';
                 _candidate.work.description = '乐于分享';
                 break;
               default:
                 _candidate.work.name = work
                 _candidate.work.description = '无';
             }
           }
           switchFun(param.work)
           //更改工作的方法
           _candidate.work.changeWork = function (work) {
             this.name = work;
             switchFun(work)
           }
           //更改工作描述的方法
           _candidate.work.changeDes = function (des) {
             this.description = des
           }
           return _candidate
         }
         var candidateArr = []
         // 遍历生成应聘者实例
         for (var i = 0; i < data.length; i++) {
           candidateArr[i] = Candidate(data[i])
         }
         console.log(candidateArr[0]);
         // 更改工作名称
         candidateArr[0].work.changeWork('xxx');
         console.log(candidateArr[0]);
       </script>
     </body>
     </html>
```

**使用建造者模式改造**

```
     <!DOCTYPE html>
     <html lang="en">
     <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
     </head>
     <body>
       <script>
         // 应聘者信息
         var data = [
           {
             name: 'zhang san',
             age: 23,
             work: 'engineer'
           },
           {
             name: 'li si',
             age: 26,
             work: 'teacher'
           },
           {
             name: 'wang wu',
             age: 13,
             work: 'xxx'
           }
         ]
         //生成应聘者实例的类
         function Candidate(param) {
           var _candidate = new Person(param)
           _candidate.name = new CreateName(param.name)
           _candidate.work = new CreateWork(param.work)
           return _candidate
         }

         function Person(param) {
           this.age = param.age
         }

         function CreateName(name) {
           this.wholeName = name;
           this.firstName = name.split(' ')[0]
           this.secondName = name.split(' ')[1]
         }
         function CreateWork(work) {
           switch (work) {
             case 'engineer':
               this.name = '工程师';
               this.description = '热爱编程';
               break;
             case 'teacher':
               this.name = '教师';
               this.description = '乐于分享';
               break;
             default:
               this.name = work
               this.description = '无';
           }
           //更改工作的方法
           CreateWork.prototype.changeWork = function (work) {
             CreateWork.call(this, work)
           }
           //更改工作描述的方法
           CreateWork.prototype.changeDes = function (des) {
             this.description = des
           }
         }
         var candidateArr = []
         // 遍历生成应聘者实例
         for (var i = 0; i < data.length; i++) {
           candidateArr[i] = Candidate(data[i])
         }
         console.log(candidateArr[0]);
         // 更改工作名称
         candidateArr[0].work.changeWork('xxx');
         console.log(candidateArr[0]);
       </script>
     </body>
     </html>
```

对比可以发现，普通代码把所有实现逻辑都放在一个类中，让这个类看起来非常臃肿阅读性差，而建造者模式会分步骤，一步步简化每个类里面的代码量，从而提高阅读性

### 单体模式

> 单例就是保证一个类只有一个实例，实现方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。在JavaScript里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。

问题：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    function NotSingle() {
      this.a = 123
    }
    var a1 = new NotSingle()
    var a2 = new NotSingle()
    console.log(a1 === a2);   //false
  </script>
</body>
</html>
```

同一个类创造的实例不相等，如果就想他们想相等呢？

可以采用单例模式来进行改造

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    var _unique = null;
    function createSingle() {
      var obj = {
        a: 1
      }
      if (_unique === null) {
        _unique = obj
      }
      return _unique
    }
    var a = createSingle()
    var b = createSingle()
    console.log(a === b);  //true
  </script>
</body>
</html>
```

上面这种方法虽然可以实现单例模式，但是由于实例对象定义在全局中，不安全，下面使用闭包来进行改造

```
 //使用闭包进行改造
    var createSingle = (function () {
      var _unique = null
      function single() {
        return {
          a: 1
        }
      }
      return function () {
        if (_unique === null) {
          _unique = single()
        }
        return _unique
      }
    })()
    var a = createSingle()
    var b = createSingle()
    console.log(a === b);  //true
```

### 装饰者模式

> 装饰者模式，希望在不改变原对象的基础上，通过对其拓展功能和属性来实现更复杂的逻辑。

有一个案例：4s店在卖一种车，价格为10万元，如果用户需要在此基础上加装一些配置则需要加钱。比如加热座椅配置需要2万元，电动后视镜需要0.8万元等等

**普通写法：**

```
  function Car() {
      this.price = 10
    }
    Car.prototype = {
      addHeatSeat: function () {
        this.hasHeatSeat = true
        this.price += 2
      },
      addAutoMirror: function () {
        this.hasAutoMirror = true
        this.price += 0.8
      }
    }
    var car1 = new Car()
    console.log(car1.price);  //10
    car1.addHeatSeat()
    car1.addAutoMirror()
    console.log(car1.price);  //12.8
```

**装饰者模式：**

```
	function Car() {
      this.price = 10
    }

    function carWithHeatSeat(carExample) {
      carExample.hasHeatSeat = true
      carExample.price += 2
    }
    function carWithHeatMirror(carExample) {
      carExample.hasAutoMirror = true
      carExample.price += 0.8
    }

    var car2 = new Car();
    console.log(car2.price); //10
    carWithHeatSeat(car2)
    carWithHeatMirror(car2)
    console.log(car2.price); //12.8
```

两种模式对比，装饰者模式是独立与构造函数之外的函数，这样就能减少对构造函数的介入

### 组合模式

> 组合模式作用于将多个部分通过组合变成一个整体。

比如我们在工作中经常会制作一些表单，比如登录，注册，或者一些信息填写等等，这些表单其实都是类似的，如果你今天制作一个注册的表单，明天做个调查问卷的表单，是不是会觉得很妈蛋，有点重复劳动的感觉？

组合模式可以解决这个问题

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //寄生式组合继承
    function inheritPrototype(subClass, superClass) {
      function F() { }
      F.prototype = superClass.prototype;
      subClass.prototype = new F()
      subClass.prototype.constructor = subClass
    }
    //组合继承
    // function inheritPrototype(subClass, superClass) {
    //   subClass.prototype = new superClass()
    // }
    //基类
    function Container() {
      aa
      this.children = []
      this.element = null
    }
    Container.prototype = {
      init: function () {
        throw new Error('请重写init方法')
      },
      add: function (child) {
        this.children.push(child)
        this.element.appendChild(child.element)
        return this
      }
    }
    //基于容器基类创建表单容器
    function CreateForm(id, method, action, parent) {
      Container.call(this)
      this.id = id || 'get';
      this.method = method || 'get'
      this.action = action || ''
      this.parent = parent
      this.init()
    }
    inheritPrototype(CreateForm, Container)
    CreateForm.prototype.init = function () {
      this.element = document.createElement('form')
      this.element.id = this.id
      this.element.method = this.method
      this.element.action = this.action
    }
    CreateForm.prototype.show = function () {
      this.parent.appendChild(this.element)
    }
    //行容器组件
    function CreateLine(className) {
      Container.call(this)
      this.className = className === undefined ? 'form-line' : 'form-line' + className
      this.init()
    }
    inheritPrototype(CreateLine, Container)
    CreateLine.prototype.init = function () {
      this.element = document.createElement('div')
      this.element.className = this.className
    }
    //label
    function CreateLabel(text, forName) {
      this.text = text || ''
      this.forName = forName || ''
      this.init()
    }
    CreateLabel.prototype.init = function () {
      this.element = document.createElement('label')
      this.element.setAttribute('for', this.forName)
      this.element.innerHTML = this.text
    }
    //input
    function CreateInput(type, id, name, defaultValue) {
      this.type = type || ''
      this.id = id || ''
      this.name = name || ''
      this.defaultValue = defaultValue || ''
      this.init()
    }
    CreateInput.prototype.init = function () {
      this.element = document.createElement('input')
      this.element.type = this.type
      this.element.id = this.id
      this.element.name = this.name
      this.element.value = this.defaultValue
    }
    
    var form = new CreateForm('owner-form', 'GET', 'https://www.baidu.com/s', document.body)
    console.log(new CreateLine());
    var userLine = new CreateLine()
      .add(new CreateLabel('用户名', 'user'))
      .add(new CreateInput('text', 'user', 'wd'))

    var pwdLine = new CreateLine()
      .add(new CreateLabel('密码', 'pwd'))
      .add(new CreateInput('password', 'pwd', 'pwd'))

    var submitLine = new CreateLine()
      .add(new CreateInput('submit', '', '', '登录'))
    form.add(userLine).add(pwdLine).add(submitLine).show()
  </script>
</body>
</html>
```

使用ES6 class来改造

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //基类
    class Container {
      constructor() {
        this.children = [],
          this.element = null
      }
      init() {
        throw new Error('请重写init方法')
      }
      add(child) {
        this.children.push(child)
        this.element.appendChild(child.element)
        return this
      }
    }
    //基于容器基类创建表单容器
    class CreateForm extends Container {
      constructor(id, method, action, parent) {
        super()
        this.id = id || 'get';
        this.method = method || 'get'
        this.action = action || ''
        this.parent = parent
        this.init()
      }
      init() {
        this.element = document.createElement('form')
        this.element.id = this.id
        this.element.method = this.method
        this.element.action = this.action
      }
      show() {
        this.parent.appendChild(this.element)
      }
    }
    //行容器组件
    class CreateLine extends Container {
      constructor(className) {
        super()
        this.className = className === undefined ? 'form-line' : 'form-line' + className
        this.init()
      }
      init() {
        this.element = document.createElement('div')
        this.element.className = this.className
      }
    }
    //label类
    class CreateLabel {
      constructor(text, forName) {
        this.text = text || ''
        this.forName = forName || ''
        this.init()
      }
      init() {
        this.element = document.createElement('label')
        this.element.setAttribute('for', this.forName)
        this.element.innerHTML = this.text
      }
    }
    //input类
    class CreateInput {
      constructor(type, id, name, defaultValue) {
        this.type = type || ''
        this.id = id || ''
        this.name = name || ''
        this.defaultValue = defaultValue || ''
        this.init()
      }
      init() {
        this.element = document.createElement('input')
        this.element.type = this.type
        this.element.id = this.id
        this.element.name = this.name
        this.element.value = this.defaultValue
      }
    }

    var form = new CreateForm('owner-form', 'GET', 'https://www.baidu.com/s', document.body)
    console.log(new CreateLine());
    var userLine = new CreateLine()
      .add(new CreateLabel('用户名', 'user'))
      .add(new CreateInput('text', 'user', 'wd'))

    var pwdLine = new CreateLine()
      .add(new CreateLabel('密码', 'pwd'))
      .add(new CreateInput('password', 'pwd', 'pwd'))
    var submitLine = new CreateLine()
      .add(new CreateInput('submit', '', '', '登录'))
    form.add(userLine).add(pwdLine).add(submitLine).show()
  </script>
</body>
</html>
```

### 观察者模式

> 观察者模式又叫发布订阅模式或者消息模式。
>
> 是设计模式中非常著名也是非常重要的一种模式，这种模式一般会定义一个主体和众多的个体，这里主体可以想象为一个消息中心，里面有各种
>
> 各样的消息，众多的个体可以订阅不同的消息，当未来消息中心发布某条消息的时候，订阅过他的个体就会得到通知

核心：

​	取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。

​	与传统的发布-订阅模式实现方式（将订阅者自身当成引用传入发布者）不同，在JS中通常使用注册回调函数的形式来订阅

实现：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    //订阅发布中心
    var msgCenter = (function () {
      var _msg = {};  //储存消息
      // var _msg = {
      //   'carInfo' : [fn1,fn2...],
      //   'newsInfo': [fn1,fn2...],
      //    ......
      // }
      return {
        //用于订阅一个消息
        subscribe: function (type, fn) {
          if (_msg[type]) {
            _msg[type].push(fn)
          } else {
            _msg[type] = [fn]
          }
        },
        //用于发布消息
        release: function (type, args) {
          if (!_msg[type]) {
            return
          }
          var event = {
            type: type,
            args: args || {}
          }
          for (let index = 0; index < _msg[type].length; index++) {
            _msg[type][index](event)
          }
        },
        //用于取消订阅消息
        cancel: function (type, fn) {
          if (!_msg[type]) {
            return
          }
          for (let index = 0; index < _msg[type].length; index++) {
            if (_msg[type][index] === fn) {
              _msg[type].splice(index, 1)
              break
            }
          }
        }
      }
    })()
    //订阅者类
    function Person() {
      this.alreadysubscribe = {}
      Person.prototype.subscribe = function (type, fn) {
        //防止重复订阅
        if (this.alreadysubscribe[type]) {
          console.log('你已经订阅过这个消息了，请不要重复订阅！');
        } else {
          msgCenter.subscribe(type, fn)
          //这句话是为了保存每个实例的订阅回调方法，通过对比，可以防止重复订阅
          this.alreadysubscribe[type] = fn
        }
      }
      Person.prototype.cancel = function (type) {
        msgCenter.cancel(type, this.alreadysubscribe[type])
        delete this.alreadysubscribe[type]
      }
    }
    var person1 = new Person()
    var person2 = new Person()
    var person3 = new Person()
    //订阅
    person1.subscribe('carInfo', function (e) {
      console.log('person1得到了关于' + e.type + '的消息，消息内容是：' + e.args.info);
    })
    person1.subscribe('newsInfo', function (e) {
      console.log('person1得到了关于' + e.type + '的消息，消息内容是：' + e.args.info);
    })
    person2.subscribe('carInfo', function (e) {
      console.log('person2得到了关于' + e.type + '的消息，消息内容是：' + e.args.info);
    })
    person3.subscribe('newsInfo', function (e) {
      console.log('person3得到了关于' + e.type + '的消息，消息内容是：' + e.args.info);
    })
    person3.subscribe('carInfo', function (e) {
      console.log('person3得到了关于' + e.type + '的消息，消息内容是：' + e.args.info);
    })
    //发布消息
    msgCenter.release('carInfo', { info: '新款汽车上市！' })
    msgCenter.release('newsInfo', { info: '某国家领导人访华' })
    //测试检测重复订阅功能
    person3.subscribe('carInfo', function (e) {
      console.log('person3得到了关于' + e.type + '的消息，消息内容是：' + e.args.info);
    })
    //测试取消订阅功能
    person3.cancel('carInfo')
    msgCenter.release('carInfo',{info:'再发一条消息'})
  </script>
</body>
</html>
```

上面代码实现的核心是把每个实例的函数传递给msgCenter函数中的_msg数组保存好，并且通过type属性来进行区分，如果有消息发布，就全部执行一遍该数组的所有方法

### 策略模式

> strategy，
>
> 在现实生活中常常遇到实现某种目标存在多种策略可供选择的情况，例如，出行旅游可以乘坐飞机、乘坐火车、骑自行车或自己开私家车等，超市促销可以釆用打折、送商品、送积分等方法。
>
> 在软件开发中也常常遇到类似的情况，当实现某一个功能存在多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能，如数据排序策略有冒泡排序、选择排序、插入排序、二叉树排序等。
>
> 如果使用多重条件转移语句实现（即硬编码），不但使条件语句变得很复杂，而且增加、删除或更换算法要修改原代码，不易维护，违背开闭原则。如果采用策略模式就能很好解决该问题。

通俗解析:

> 假设一段文字需要进行检测是否为数字，是否为空，是否是邮箱等等，一般来说我们会使用if_else来进行判断，如果既要检测是否为数字又是否为电话号码，那么就需要两个if_else，且灵活性和复用性并不强，而策略模式是把一大堆需要用到的检测方法或者算法或者功能封装到一个对象中，并且为对象配置validate方法，用以调用对象中的方法，随便用，一个或者多个，复用，都没问题

例子：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <input type="text">
  <script>
    //策略模式
    var formStrategy = (function () {
      var strategy = {
        notEmpty: function (value) {
          return value.length ? '' : '请填写内容'
        },
        isNumber: function (value) {
          var reg = /^[0-9]+(\.[0-9])?$/;
          return reg.test(value) ? '' : '请填写一个数字'
        },
        isPhone: function (value) {
          //010-12345678 0022-1234567
          var reg = /^\d{3}-\d{8}$|^\d{4}-\d{7}$/
          return reg.test(value) ? '' : '请输入一个正确的电话好吗'
        }
      }
      return {
        // 检测方法，type是输入要检测的类型，value是值
        validate: function (type, value) {
          //去除输入文字两边的空白符
          value = value.replace(/^\s*|\s*$/g, "")
          return strategy[type] ? strategy[type](value) : '没有这个检测方法，请手动添加'
        },
        //临时添加自定义检测算法
        addStrategy: function (type, fn) {
          if (strategy[type]) {
            return '这个方法已经存在'
          } else {
            strategy[type] = fn
          }
        }
      }
    })()
    //测试
    var oInput = document.querySelector('input')
    oInput.onchange = function () {
      var result;
      result = formStrategy.validate('notEmpty', this.value) || formStrategy.validate('isNumber', this.value) || '通过检测'
      console.log(result);
    }
  </script>
</body>

</html>
```

### 链模式

> 链模式是实现链式调用的主要方法，通过在自身方法中返回自身的方式，在一个对象连续多次调用自身方法可以简化写法
>
> 这种链式调用在开很多库和框架如jquery/zepto中频繁的被使用。

简单的链模式

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    var obj = {
      a: function () {
        console.log('aaa');
        return this
      },
      b: function () {
        console.log('bbb');
        return this
      }
    }

    obj.a().b().a().a()    ///aaa bbb aaa aaa
  </script>
</body>
</html>
```

### 委托模式

> 当多个对象需要处理同一请求时，可以将这些请求交由另一个对象统一处理

普通模式

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <ul class="ul1">
    <li>aaaa</li>
    <li>bbbb</li>
    <li>cccc</li>
    <li>dddd</li>
  </ul>
  <script>
     var aLis = document.getElementsByTagName('li')
     for (let index = 0; index < aLis.length; index++) {
       (function (i) {
        aLis[index].onclick = function () {
           console.log(index);
         }
       })(index)
     }
  </script>
</body>
</html>
```

这样会绑定多个事件，会影响性能

使用委托模式进行改进：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <ul class="ul1">
    <li>aaaa</li>
    <li>bbbb</li>
    <li>cccc</li>
    <li>dddd</li>
  </ul>
  <script>
    var oUl = document.querySelector('ul')
    oUl.onclick = function (e) {
      console.log(e);
      var e = e || window.event
      target = e.target || e.srcElement
      if(target.nodeName.toLowerCase() === 'li'){
        console.log(target.innerHTML);
      }
    }
    
    var oLi = document.createElement('li')
    oLi.innerHTMl = 'eeee'
    oUl.appendChild(oLi)
  </script>
</body>
</html>
```

### 数据访问对象模式

> 数据访问对象模式主要是用来抽象和封装一个对象来对数据源进行访问和存储，这样可以方便对数据的管理，以及避免数据间的重复，覆盖等问题

实例：

```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // {
    //   key: expire|value
    // }
    function DataVisitor(splitSign) {
      this.splitSign = splitSign || '|'
    }
    DataVisitor.prototype = {
      status: {
        SUCCESS: 1,
        FAILURE: 0,
        OVERFLOWER: 2,
        TIMEOUT: 3
      },
      set: function (key, value, cbFn, expireTime) {
        var status = this.status.SUCCESS;
        expireTime = typeof expireTime === 'number' ? expireTime + new Date().getTime() : -1
        try {
          window.localStorage.setItem(key, expireTime + this.splitSign + value)
        } catch (e) {
          status = this.status.OVERFLOWER
        }
        cbFn && cbFn.call(this, status, key, value);
        return value
      },
      get: function (key, cbFn) {
        var status = this.status.SUCCESS
        var value = window.localStorage.getItem(key)
        if (value) {
          var index = value.indexOf(this.splitSign),
            time = value.slice(0, index)
          if (time > new Date().getTime() || time == -1) {
            value = value.slice(index + this.splitSign.length)
          } else {
            value = null;
            status = this.status.TIMEOUT;
            window.localStorage.removeItem(key)
          }
        } else {
          status = this.status.FAILURE
        }
        cbFn && cbFn.call(this, status, key, value)
      },
      remove: function (key, cbFn) {
        var status = this.status.FAILURE;
        value = window.localStorage.getItem(key);
        if (value) {
          value.slice(value.indexOf(this.splitSign) + this.splitSign.length)
          window.localStorage.removeItem(key);
          status = this.status.SUCCESS;
        }
        cbFn && cbFn.call(this, status)
      }
    }
    
    var test = new DataVisitor();
    test.set('aaa', '1273', function (status) {
      console.log(Boolean(status));
    }, 2000)
    test.get('aaa', function (status, key, value) {
      console.log(status, key, value);
    })
    setTimeout(() => {
      test.get('aaa', function (status, key, value) {
        console.log(status, key, value);
      }, 2000)
    }, 1000);
    setTimeout(() => {
      test.get('aaa', function (status, key, value) {
        console.log(status, key, value);
      }, 2000)
    }, 3000);
    // test.remove('aaa',function (status) {
    //    console.log(Boolean(status));
    // })
    // test.remove('aaab', function (status) {
    //     console.log(Boolean(status));
    //   })
  </script>
</body>

</html>
```

### 等待者模式

> 通过对多个异步进程的监听，对未来事件进行统一管理。

### MVC模式

> MVC即Model-View-Controller（模型-视图-控制器）是一种软件设计模式，最早出现在Smalltalk语言中，后被Sun公司推荐为Java EE平台的设计模式。

　MVC把应用程序分成了上面3个核心模块，这3个模块又可被称为业务层-视图层-控制层。顾名思义，它们三者在应用程序中的主要作用如下：

**业务层**：负责实现应用程序的业务逻辑，封装有各种对数据的处理方法。它不关心它会如何被视图层显示或被控制器调用，它只接受数据并处理，然后返回一个结果。

**视图层**：负责应用程序对用户的显示，它从用户那里获取输入数据并通过控制层传给业务层处理，然后再通过控制层获取业务层返回的结果并显示给用户。

**控制层**：负责控制应用程序的流程，它接收从视图层传过来的数据，然后选择业务层中的某个业务来处理，接收业务层返回的结果并选择视图层中的某个视图来显示结果。

![img](https://t11.baidu.com/it/u=3066061642,1532806395&fm=173&app=25&f=JPEG?w=504&h=300&s=A983CC1223DA6DC80A761159020050FA)

在MVC里，View是可以直接访问Model的，所以View里会包含Model信息以及一些业务逻辑。 MVC模型关注的是Model的不变，所以在MVC模型里，Model不依赖于View，但是 View是依赖于Model的。不仅如此，因为有一些业务逻辑在View里实现了，导致要更改View也是比较困难的，至少那些业务逻辑是无法重用的。

代码：

```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    //一个简单的mvc实例
    var MVC = {}

    MVC.model = (function () {
      var data = {
        sidebar: [{
          title: 'sidebar1',
          href: './a.html'
        }, {
          title: 'sidebar2',
          href: './b.html'
        }, {
          title: 'sidebar3',
          href: 'http://www.baidu.com'
        }]
      }

      return {
        getData: function (key) {
          return data[key]
        },
        setData: function (key, value) {
          data[key] = value
          MVC.view('createSidebar')
        }
      }
    })()

    MVC.view = (function () {
      var m = MVC.model
      var view = {
        createSidebar: function () {
          var data = m.getData('sidebar')
          var html = ''
          html += '<div id ="#sidebar">'
          for (let i = 0; i < data.length; i++) {
            html += '<div class="sidebar-item"><a href="' + data[i].href + '">' + data[i].title + '</a></div>'
          }
          html += '</div>'

          document.body.innerHTML += html
        }
      }
      return function (v) {
        view[v]()
      }
    })()

    MVC.ctrl = (function () {
      var m = MVC.model
      var v = MVC.view
      var c = {
        initSideBar: function () {
          v('createSidebar')
        },
        updateSiderBar: function () {
          m.setData('sidebar', [{ title: 'new sidebar', href: 'http://www.baidu.com' }])
        }
      }
      return c
    })()

    window.onload = function () {
      //从control修改model
      MVC.ctrl.initSideBar()
      setTimeout(() => {
        MVC.ctrl.updateSiderBar()
      }, 3000);
      setTimeout(() => {
        MVC.view('createSidebar')
      }, 6000);
      setTimeout(() => {
        MVC.view('createSidebar')
      }, 9000);
    }
  </script>
</body>

</html>
```

### MVVM模式

> MVVM模式在传统MVC模式下进行改造，实现其重在数据驱动视图的一种设计模式。

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210219030956917.png" alt="image-20210219030956917" style="zoom:67%;" />

```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    //如何实现数据与视图绑定
    // 1、需要知道哪个数据改变了。一般我们可以使用数据访问对象的方法。在vue中我们使用的是es5的对象访问属性get/set
    // 2、修改视图
    var model = {
      a: 1,
      b: 2
    }
    // vm
    for (var key in model) {
      ; (function (key) {
        var value = model[key]
        Object.defineProperty(model, key, {
          get: function () {
            return value
          },
          set: function (newVal) {
            value = newVal
            render()
          }
        })
      })(key)
    }
    //view
    let render = (function render() {
      console.log('render执行了');
      document.body.innerHTML = '<div><h3>想显示一些文案</h3><p>a的值: ' + model.a + ',b的值：' + model.b + '</p></div>'
      return render
    })()

    setTimeout(() => {
      model.b = 3
    }, 2000);
    setTimeout(() => {
      model.b = 11111
    }, 3000);

  </script>
</body>

</html>
```



## 	布局

### 		Flex布局

### 		Rem布局

### 		响应式布局

# 手机端

## 	构建工具（Hbuilder)

# 小程序

## 	构建工具（微信开发者工具）

# PC端

## Electron

### Electron简介

### Electron开发环境搭建

1. 安装nodejs

2. 安装electron

   npm i electron -g 

   <img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201016095134633.png" alt="image-20201016095134633" style="zoom: 80%;" />

   输入npx electron -v检查是否安装成功

   ![image-20201016095215619](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201016095215619.png)

3. 创建Helloworld

   创建三个必备文件夹，第一文件夹是窗口要渲染的页面，第二个文件是主进程，第三个文件是配置文件

   ![image-20201016095940167](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201016095940167.png)

   具体内容：

   main.js:

   ```
   var electron = require('electron')
   //引用app
   var app = electron.app
   // 窗口引用
   var BrowserWindow = electron.BrowserWindow
   //声明要打开的主窗口
   var mainWindow = null
   app.on('ready', () => {
     mainWindow = new BrowserWindow({
       width: 800,
       height: 600,
     })
     mainWindow.loadFile('index.html')
     mainWindow.on('closed', () => {
       mainWindow = null
     })
   })
   ```

   package.json:

   简洁命令：npm init --y

```
     {
       "name": "helloworld",
       "version": "1.0.0",
       "description": "",
       "main": "main.js",
       "scripts": {
         "test": "echo \"Error: no test specified\" && exit 1"
       },
       "keywords": [],
       "author": "",
       "license": "ISC"
     }

```

index.html就不展示了，和普通的一样

进入到项目目录，输入electron . 执行

![image-20201016100305750](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201016100305750.png)

![image-20201016100315096](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201016100315096.png)

#### 打包文件

**方案一：（不推荐）**

1. 输入 npm install electron-packager -g**全局安装**我们的打包神器：

```
		npm i electron --save-dev
		npm install electron-packager -g
```

  2、在项目文件夹下面，也就是根目录下面打开DOS执行打包命令：	

```
	electron-packager . HelloWorld --platform=win32 --arch=x64 --icon=computer.ico --out=./out --asar --app-version=0.0.1 --overwrite --			ignore=node_modules --electron-version 5.0.0
```

**各个参数介绍：**

```
HelloWorld ：你将要生成的exe文件的名称
```

![img](https://img2018.cnblogs.com/blog/1242944/201906/1242944-20190618135520631-1919275615.png)

```
--platform=win32：确定了你要构建哪个平台的应用,可取的值有 darwin, linux, mas, win32
--arch=x64：决定了使用 x86 还是 x64 还是两个架构都用
--icon=computer.ico：自定义设置应用图标
--out=./out：指定打包文件输出的文件夹位置,当前指定的为项目目录下的out文件夹
--asar：该参数可以不加，如果加上，打包之后应用的源码会以.asar格式存在
```

![img](https://img2018.cnblogs.com/blog/1242944/201906/1242944-20190618141037414-1277263689.png)

```
，否则会以文件夹形式存在
```

![img](https://img2018.cnblogs.com/blog/1242944/201906/1242944-20190618141130331-2106206669.png)

```
--app-version=0.0.1：生成应用的版本号
--overwrite：覆盖原有的build,让新生成的包覆盖原来的包
--ignore=node_modules：如果加上该参数，项目里node_modules模块不会被打包进去
--electron-version 5.0.0：指定当前要构建的electron的版本,需要和当前的版本一致,具体可以在package.json文件中查看,可以不加该
```

**方案二：（推荐）**

建议将打包的命令设置在`package.json`的`script`中

设置如下:

```
  "scripts": {"package":"electron-packager . HelloWorld --platform=win32 --arch=x64 --icon=computer.ico --out=./out --asar --app-version=0.0.1 --overwrite --ignore=node_modules"
  }
```

然后在项目文件夹DOS窗口下执行命令：

```
npm run package
```

即可打包成功

# 微前端

## WebComponents

# TypeScript

## 简介

> TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。
>
> TypeScript = Type + JavaScript (为JS添加了类型系统)
>
> TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。
>
> TypeScript是微软开发的开源编程语言，设计目标是开发大型应用。
>
> 可以在任何浏览器、任何计算机、任何操作系统上运行。

**TypeScript 代码：有明确的类型，即 ：number (数值类型)**

```
	let age: number = 18
```

JavaScript 代码：无明确的类型

```
	let age = 18
```

## 环境配置

nodejs

```
	npm i -g typescript
```

typescript：就是用来解析TS的工具包。提供了TS命令，是实现了TS->JS的转化。

```
	tsc -v  //查看typescript版本，可以检查是否安装成功
```

![image-20201121131021457](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201121131021457.png)

## 基本使用

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201121131601229.png" alt="image-20201121131601229" style="zoom:67%;" />

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201121132208220.png" alt="image-20201121132208220" style="zoom:67%;" />

## 变量

> **基本使用**

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201121133100575.png" alt="image-20201121133100575" style="zoom:67%;" />

```
	//第一步：声明变量并指定类型
	let age: number
	//第二步: 给变量赋值
	age = 18
	console.log(age)   //18
	//变量是可以变化的
	age = 19
	console.log(age)   //19
```

> **简化形式**

```
	//简化方式： 声明变量的同时就赋值
	let age: number = 18
	console.log(age)  //18
```

> 变量的命名规则

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201121134601478.png" alt="image-20201121134601478" style="zoom:67%;" />

## 运算符

加号的其他作用：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201121155956941.png" alt="image-20201121155956941" style="zoom:67%;" />

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201121160041060.png" alt="image-20201121160041060" style="zoom:67%;" />

`注意：以上的只是针对TS语法，JS并不完全一样，JS中减法可以有除number类型的其他数据，并且都会转化成number类型`

## 数组

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201121221043029.png" alt="image-20201121221043029" style="zoom: 67%;" />

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201121222351980.png" alt="image-20201121222351980" style="zoom:67%;" />

## 函数

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201121223309539.png" alt="image-20201121223309539" style="zoom: 67%;" />

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201121223532245.png" alt="image-20201121223532245" style="zoom:67%;" />

## 对象

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201122124356699.png" alt="image-20201122124356699" style="zoom:67%;" />

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201122124415777.png" alt="image-20201122124415777" style="zoom:67%;" />

### 接口

> 为对象的类型注解命名，并为你的代码建立契约来约束对象的结构

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201122124305185.png" alt="image-20201122124305185" style="zoom:67%;" />

## 在浏览器中运行TS

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201122140542944.png" alt="image-20201122140542944" style="zoom:67%;" />

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201122141620490.png" alt="image-20201122141620490" style="zoom:67%;" />

# Webpack

> 



# 		Vue

## 环境安装

```
npm install --global vue-cli
```

在vue.config.js中输入以下代码可以更简单使用文件路径：

```
module.exports = {
  configureWebpack: {
    resolve: {
      alias: {
        assets: "@/assets",
        common: "@/common",
        components: "@/components",
        network: "@/network",
        views: "@/views"
      }
    }
  },
};

```

引入全局css

在app.vue的style中引入

```
@import "./assets/css/base.css";
```

或者在main.js中引入

```
import "./assets/css/base.css";
```

打包Vue项目，

第一步：

在router得文件夹中的Index.js中的路由模式必须为hash模式（由于默认就是hash模式，所以我们不写也行，但不能写history模式）

```
     const router = new VueRouter({
       mode: 'hash',
       base: process.env.BASE_URL,
       routes
     })
```

第二步：

在vue.config.js中添加：

```
 	publicPath: "./"
```

![image-20201128141508724](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201128141508724.png)

之后执行:npm run build

然后打包成功，并放置在asset文件夹

## 不同屏幕适配

### rem布局

> 原理

由于px是不可变的，所以我们适配不同分辨率的屏幕时不能使用px，我们可以使用rem或者vw这些可变化的单位来进行适配，比如我们在一个宽度分辨率为2000px的屏幕，假设我们的设计稿也是2000px的，如果我们在2000px的屏幕显示刚好是显示100%,没有任何问题，但是如果在宽度分辨率为1000px的屏幕就不能100%显示，而是只能显示1000px，设计稿也就是一半，这体验是非常不友好的，我们应该也要把我们的网页也对应缩小一半，也就是按比例来缩小（类似vw布局），所以我们应该统一使用rem为单位来开发，但我们屏幕比设计稿小一半时，我们只需要把rem缩小一半就行，这个步骤我们可以使用js来实现，当然，我们如果使用了vue来进行开发，我们可以使用插件来更简单的实现rem布局

js实现的基本代码，当然，我们使用时使用rem单位，可以通过less来进行简单计算，因为没有使用插件来进行但未进行转换，需要我们手动转换

```
// rem等比适配配置文件
// 基准大小
const baseSize = 50
// 设置 rem 函数
function setRem () {
  // 当前页面宽度相对于 1920宽的缩放比例，可根据自己需要修改。
  const scale = document.documentElement.clientWidth / 1920
//Math.min(pramA,pramB...) 返回零个或更多个数值的最小值。
  // 设置页面根节点字体大小（“Math.min(scale, 2)” 指最高放大比例为2，可根据实际业务需求调整）
  document.documentElement.style.fontSize = baseSize * Math.min(scale, 2) + 'px'
}
// 初始化
setRem()
// 改变窗口大小时重新设置 rem
window.onresize = function () {
  setRem()
}
```

实现步骤：

1. 安装amfe-flexible插件

   ```
   npm i amfe-flexible
   ```

2. 在main.js引入amfe-flexible插件

   ```
   import 'amfe-flexible'
   ```

3. 安装postcss-px2rem插件

   ```
   npm i postcss-px2rem
   ```

4. 在package.json中配置

   ```
    "postcss": {
       "plugins": {
         "autoprefixer": {},
         "postcss-px2rem": {
           "remUnit": 108   //设计稿的10/1，108也就是指设计稿为1080px
         }
       }
     }
   ```

如果个别地方不想转化px。可以简单的使用大写的 **PX** 或 **Px** 。

**进阶适配：**

​	上面的适配可以解决绝大部分的屏幕适配问题，但是如果当屏幕比发生变化时，上面的适配是根据屏幕宽度来进行适配的，比如在浏览器不全屏显示的时候，高度是可以占满的，但是全屏后，由于屏幕宽度没有发生变化，所以rem也不会变化，全屏后就产生了高度不占满屏幕的情况

解决上面问题可以采用rem布局（根据高度来进行适配），屏幕宽度使用flex布局或者百分比，或者ant-design的栅格布局等等

实现步骤：

1. 安装postcss-pxtorem插件

   ```
   npm i postcss-pxtorem
   ```

2. 在vue.config.js中引入并配置该插件

   ```
   css: {
       loaderOptions: {
         postcss: {
           plugins: [
             require('postcss-pxtorem')({//这里是配置项，详见官方文档
               rootValue: 20, // 设计稿下的rem大小，单位为px
               propList: ['*'],
             }),
           ]
         }
       }
     },
   ```

3. 创建rem.js，用来按比例放大或缩小网页，如果是设计稿的高度的比例就为1

   ```
   // rem等比适配配置文件
   // 基准大小
   const baseSize = 20
   // 设置 rem 函数
   function setRem () {
     // 当前页面宽度相对于 1920宽的缩放比例，可根据自己需要修改。
     const scale = document.documentElement.clientHeight / 1080
     //Math.min(pramA,pramB...) 返回零个或更多个数值的最小值。
     // 设置页面根节点字体大小（“Math.min(scale, 2)” 指最高放大比例为2，可根据实际业务需求调整）
     document.documentElement.style.fontSize = baseSize * Math.min(scale, 2) + 'px'
   }
   // 初始化
   setRem()
   // 改变窗口大小时重新设置 rem
   window.onresize = function () {
     setRem()
   }
   ```

4. 在main.js引入rem.js

   ```
   import './rem.js'
   ```

### vw布局



## 模块化开发

### scoped

> 在Vue文件中的style标签上有一个特殊的属性，scoped。当一个style标签拥有scoped属性时候，它的css样式只能用于当前的Vue组件，可以使组件的样式不相互污染。如果一个项目的所有style标签都加上了scoped属性，相当于实现了样式的模块化。

**原理：scoped是通过给当前组件的元素加上一个随机唯一属性，然后通过属性选择器进行唯一确认，从而不会影响到其他组件的元素**

但是有一个特别要注意的点，假设我们在一个组件使用另一个组件，我们在父组件使用

scoped也是会影响子组件的最外层div的，这是为了方便父元素布局，但是只能影响子组件的最外层div，其他无法影响

但是scoped也会带来一个问题，由于有了scoped的限制，我们引用的一些echrts和ui框架组件就不能直接影响他们的样式了，如果去掉scoped就会污染全局，

解决方案：我们可以在该选择器前面加上/deep/就行了，比如下图，这样我们的样式就只会影响.tableHome下面的元素了，而不会污染全局

![image-20201206233329101](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201206233329101.png)

## 模块化概述

**传统开发模式的主要问题**

- 命名冲突
- 文件依赖

**通过模块化解决上述问题**

- 模块化就是单独的一个功能封装到一个模块（文件）中，模块之间相互隔离，但是可以通过特定的接口公开内部成员，也可以依赖别的模块
- 模块化开发的好处：方便代码的重用，从而提升开发效率，并且方便后期的维护

### **浏览器端模块化规范**

1、AMD

2、CMD

### **服务器端模块化规范**

CommonJS

1. 模块分为`单文件模块`与`包`

2. 模块成员导出：`module.exports`和`exports`

   module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量

   node为每一个模块提供了一个exports变量(可以说是一个对象)，指向 module.exports。这相当于每个模块中都有一句这样的命令 var exports = module.exports;

   **使用实例(文件均在同一个目录下）：**

   c.js

   ```
   const a = 10
   const b = 11
   exports.a = a
   module.exports.b = b
   ```

   d.js:

   ```
   const c = require('./c')
   console.log(c)
   ```

   输出结果：

   ![image-20201014225241275](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201014225241275.png)

   一般采用module.export直接导出全部变量

   当c.js变成这样：

   ```
   const a = 10
   const b = 11
   module.exports = {
     a,
     b,
   }
   ```

   输出结果：

   ![image-20201014225244872](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201014225244872.png)

   可以实现一样的效果

   使用ES6的对象结构语法接受导入对象也是比较常见的：

   d.js：

   ```
   const { a, b } = require('./c')
   console.log(a)
   console.log(b)
   ```

   ![image-20201014225436175](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201014225436175.png)

3. 模块化成员导入：`require('模块标识符')`

### **大一统的模块化规范-ES6模块化**

在ES6模块化规范诞生之前，Javascript社区已经尝试并提出了AMD、CMD、CommonJS等模块化规范。

但是，这些社区提出的模块化标准，还是存在一定的差异性与局限性，并不是浏览器与服务器通用的模块化标准，例如：

- AMD和CMD适用于浏览器端的Javascript模块化
- CommonJS适用于服务器端的Javascript模块化

因此，ES6语法规范中，在语言层面上定义了ES6模块化规范，是浏览器端与服务器端通用的模块化开发规范。

ES6模块化规范中定义：

- 每个js文件都是一个独立的模块
- `导入模块成员`使用`import`关键字
- `暴露模块成员`使用`export和export default关键字

> export和export default的区别

 **1.export与export default均可用于导出常量、函数、文件、模块等**
	   **2.在一个文件或模块中，export、import可以有多个，export default只可以有一个**
	   **3.通过export方式导出，在导入时要加{ }，而且名称要一一对应（可以用as来起别名），export default则不需要，名称也没有限制**	

**ES6模块化规范在服务器端的使用*（nodejs)*****

通过babel实现，nodejs环境默认不支持ES6模块化规范

`babel是将高级、有兼容性的js，转换为低级、无兼容性的js的**语法转换工具**`

1. npm install --save-dev @babel/core @babel/cli @babel/preset-env @babel/node

2. npm install --save @babel/polyfill

3. 在项目根目录创建文件babel.config.js

4. babel.config.js文件内容如下代码：

   ```
   const presets = [
   	[
   		"@babel/env",{
   			targets:{
   				edge:"17",
   				firefox:"60",
   				chrome:"67",
   				safari:"11.1"
   			}
   		}
   	]
   ]
   module.exports = {
   	presets
   }
   ```

5. 通过npx babel-node index.js 执行代码

***注释：babel运行之前，先读取babel.config.js配置文件，根据配置信息，进行代码转换***

**使用实例(文件均在同一个目录下）：**

m1.js:

```
	let a = 10
     function show() {
       console.log('11111')
     }
     export default {
       a,
       show,
     }
     export let s1 = 'aaa'
     export function say() {
       console.log('asasas')
     }
```

index.js:

```
     import m1, { s1, say } from './m1.js'
     console.log(m1)
     console.log(s1)
     say()
```

输出结果：

![image-20201014231044003](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201014231044003.png)

**ES6模块化规范在浏览器端的使用**

**使用实例(文件均在同一个目录下）：**

a.js:

```
     var name = '小明'
     var age = 18
     var address = '广州'
     // 导出方式一
     export { name, age }
     //导出方式二：
     export var num1 = 1000
     export function mul(numl) {
       return num1
     }
     //导出方式三:
     export default address
```

b.js:

```
	//第一种导入方式
	import address, { name as alias, age, num1, mul } from './a.js'
     console.log(alias)
     console.log(age)
     console.log(num1)
     console.log(mul)
     console.log(address)
     //第二种导入方式：
     import address, * as aaa from './a.js'
	console.log(aaa.name + aaa.age + aaa.num1)
```

index.html:

```
     <!DOCTYPE html>
     <html lang="en">
       <head>
         <meta charset="UTF-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1.0" />
         <title>Document</title>
       </head>
       <body>
         <!-- <script src="./a.js" type="module"></script> -->
         <script src="./b.js" type="module"></script>
       </body>
     </html>
```

注：要使用export和import，在引入js文件的时候必须加上属性type='module',不需要全部文件都在html引入，只需要引入b.js，因为a.js已经在b.js引入了，a.js有作用的部分已经放到b.js中了，如果还在html引入就没有意义了

### 插件

在Vue项目中，我们使用Element-ui,或者ant-design这些都需要使用Vue.use安装使用它，这是为什么？

比如：![image-20201031172437682](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201031172437682.png)

因为这样相当于全局注册了该组件，就可以在任何组件中使用了。（注意：某些组件不能通过Vue.use注册，比如axios,是因为它没有install方法

我们首先自己自定义一个全局组件吧

在index.js中：

![image-20201031172809099](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201031172809099.png)

Vue.components中的Filters是真正使用的插件名，比如<Filters/>,而不是<table/>

在main.js中注册(实际上就运行了下index.js中的table函数)

![image-20201031173145811](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201031173145811.png)

这样我们就可以在任何地方使用了

例如在user.vue中；
	![image-20201031173244669](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201031173244669.png)

实际上注册全局组件并不需要那么复杂，只需要两行代码就行，上面的方法只是更好的封装以及功能更强大

![image-20201031173930801](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201031173930801.png)

只需要

```
     import index from './components/index.vue'
     // Vue.use(index)
     Vue.component('Filters', index)
```

要注意，记得加上.vue后缀，不能省略，因为在.js文件中，如果没有加后缀名，会优先加载.js

两行代码就能搞定的事为什么要搞那么复杂呢？

实际上Vue.use也是基于这两行代码

Vue.use()中的参数是一个对象，然后会执行参数对象中的install方法，所以使用Vue.use也是相当于执行了Vue.component('Filters', index)，没有区别，只不过

Vue.use()还可以注册全局方法等有用的东西

```
    let MyPlugin={}
    MyPlugin.install = function (Vue, options) {
       // 1. 添加全局方法或 property
       Vue.myGlobalMethod = function () {
         // 逻辑...
       }
       // 2. 添加全局资源
       Vue.directive('my-directive', {
         bind (el, binding, vnode, oldVnode) {
           // 逻辑...
         }
         ...
       })
       // 3. 注入组件选项
       Vue.mixin({
         created: function () {
           // 逻辑...
         }
         ...
       })
       // 4. 添加实例方法
       Vue.prototype.$myMethod = function (methodOptions) {
         // 逻辑...
       }
     }
     export default Myplugin
```

### scoped属性

> Add "scoped" attribute to limit CSS to this component only

**使用：**

​	使用在style标签上	

例如：

![image-20201029134008532](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201029134008532.png)

**作用：实现组件样式的私有化不对全局造成样式污染**

例如：

子组件：

```
     <template>
         <p class="son">son</p>
     </template>
     <script>
     export default {
       name: 'HelloWorld',
       props: {
         msg: String
       }
     }
     </script>
     <style scoped>
       .parent{
         color: red;
       }
     </style>
```

父组件：

```
     <template>
       <div id="app">
        <hello-world/>
        <p class="parent">parent</p>
       </div>
     </template>
     <script>
     import HelloWorld from './components/HelloWorld.vue'
     export default {
       name: 'App',
       components: {
         HelloWorld
       }
     }
     </script>
      <style>
       .son{
         color: blue;
       }
     </style>
```

输出结果：

![image-20201029134540897](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201029134540897.png)

由于子组件中的style标签加了scoped属性，所以它的样式只对自身组件有效，并不能影响其他组件

父组件中的style标签没有scoped属性，所以它的样式可以控制全局样式

假如把子组件中的scoped去掉也一样可以控制父元素的样式

![image-20201029134837243](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201029134837243.png)

## 				vue基本语法

### v-bind

> v-bind  主要用于属性绑定，Vue官方提供了一个简写方式 **:bind**，例如：

```
<!-- 完整语法 -->
<a v-bind:href="url"></a>
<!-- 缩写 -->
<a :href="url"></a>
```

**绑定HTML Class**

**一、对象语法：**

我们可以给v-bind:class 一个对象，以动态地切换class。注意：v-bind:class指令可以与普通的class特性共存

HTML代码：

```
<ul class="box" v-bind:class="{‘textColor‘:isColor, ‘textSize‘:isSize}">
    <li>学习Vue</li>
    <li>学习Node</li>
    <li>学习React</li>
</ul>
```

CSS代码：

```
.box{
    border:1px dashed #f0f;
}
.textColor{
    color:#f00;
    background-color:#eef;
}
.textSize{
    font-size:30px;
    font-weight:bold;
}
```

JS代码：

```
var vm= new Vue({
    el:'.box',
    data:{
        isColor:true,
        isSize:true
    }
})
```

**也可以直接绑定数据里的一个对象：**

HTML代码：

```
<ul class="box" :class="classObject">
    <li>学习Vue</li>
    <li>学习Node</li>
    <li>学习React</li>
</ul>
```

JS代码：

```
var vm= new Vue({
    el:‘.box‘,
    data:{
        classObject:{
            ‘textColor‘:true,
            ‘textSize‘:false //不渲染，注意看下面的截图
        }
    }
})
```

<img src="http://s3.51cto.com/wyfs02/M02/89/2F/wKioL1gLE7jBVrvSAACSP3ftTFM106.png" alt="技术分享" style="zoom:67%;" />

**二、数组语法**

我们可以把一个数组传给v-bind:class，以应用一个class列表

HTML代码：

```
<ul class="box" :class="[classA, classB]">
    <li>学习Vue</li>
    <li>学习Node</li>
    <li>学习React</li>
</ul>
```

JS代码：

```
var vm= new Vue({
    el:‘.box‘,
    data:{
        classA:‘textColor‘,
        classB:‘textSize‘
    }
})
```

**如果想根据条件切换列表中的class，可以用三目运算**

HTML代码：

```
<ul class="box" :class="[isA?classA:‘‘, classB]">
    <li>学习Vue</li>
    <li>学习Node</li>
    <li>学习React</li>
</ul>
```

JS代码：

```
var vm= new Vue({
    el:‘.box‘,
    data:{
        classA:‘textColor‘,
        classB:‘textSize‘,
        isA:false 
    }
})
```

在这个例子中，首先判断isA的boolean值，如果为true，则渲染classA；如果为false，则不渲染。classB没有做三目运算，所以是始终显示的，看看页面截图

[<img src="http://s2.51cto.com/wyfs02/M01/89/2F/wKioL1gLFw7zSxVrAACvZz_XHmk974.png" alt="技术分享" style="zoom:80%;" />](http://s2.51cto.com/wyfs02/M01/89/2F/wKioL1gLFw7zSxVrAACvZz_XHmk974.png)

**对于多个class，可以这么写：**

**<component>内置组件 + v-bind: is：实现动态组件**

```
<div v-bind:class="[classA, { classB: isB, classC: isC }]">
```

**绑定内联样式**

**一、对象语法**

v-bind:style 的对象语法十分直观--非常像CSS，其实它是一个Javascript对象，**CSS属性名必须用驼峰命名法**（官方文档写的是既可以用驼峰也可以用 短横分隔命名法），但是用短横分隔是会报错的

HTML代码：`（这里演示CSS属性名用短横分隔报错）,注意css属性样按照驼峰命名法的规则去写`

```
	<div id="box" :style="{color:activeColor, fontSize:size}">红嘴绿鹦哥</div>
```

JS代码：

```
var vm= new Vue({
    el:‘#box‘,
    data:{
        activeColor:‘#f00‘,
        size:‘30px‘,
        shadow:‘5px 2px 6px #000‘
    }
})
```

**二、数组语法**

可将多个样式对象应用到一个元素上

HTML代码：

```
<div class="box" :style="[styleObjectA, styleObjectB]">好好学习，天天向上</div>
```

JS代码：

```
var vm2= new Vue({
    el:‘.box‘,
    data:{
        styleObjectA:{
            fontSize:‘36px‘,
            color:‘blue‘
        },
        styleObjectB:{
            textDecoration:‘underline‘
        }
    }
})
```

**添加图片SRC地址**

给img标签的src属性赋值时，按照传统的方法{{url}}：

HTML代码：

```
<img class="box" :src="url" >
```

JS代码：

```
var vm= new Vue({
    el:‘.box‘,
    data:{
        url:‘https://ss0.bdstatic.com/5aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png‘
    }
})
```

![image-20201121213917611](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201121213917611.png)

>  <component> 元素是vue 里面的一个内置组件。
>
> 在<component>里面使用 v-bind: is，可以实现动态组件的效果。
>
> 也就是说is等于什么这里就渲染哪个组件，而不需要使用v-if和v-else这些方法来筛选，并且能在同一个位置实现响应式动态显示不同组件

<img src="https://img-blog.csdnimg.cn/20181025215659491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc5NjYzMQ==,size_27,color_FFFFFF,t_70" alt="img" style="zoom: 80%;" />

<img src="https://img-blog.csdnimg.cn/20181025220423733.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTc5NjYzMQ==,size_27,color_FFFFFF,t_70" alt="img" style="zoom:80%;" />

使用实例：

```
<div id="app">
     <component v-bind:is="whichcomp"></component>//组件渲染的位置
     <button v-on:click="choosencomp('a')">a</button>
     <button v-on:click="choosencomp('b')">b</button>
     <button v-on:click="choosencomp('c')">c</button>
</div>
```

```
//做一个包含列表组件
//需要给组件创建props--"todos",用于存放组件通过绑定prop --"todo"获取实例中的data数据"todolists"
var app=new Vue({
  el: '#app',
	components:{
		acomp:{
		   template:`
				<p>这里是组件A</p>
			`
			},
		bcomp:{
		   template:`
				<p>这里是组件B</p>		`
		},
		ccomp:{
			template:`
				<p>这里是组件C</p>
		`
		}},
	data:{
		whichcomp:""
	},
	methods:{
	   choosencomp:function(x){
	   this.whichcomp=x+"comp"}
   }
})
```

效果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201121162128826.png" alt="image-20201121162128826" style="zoom:80%;" />

### v-model

v-model可以实现输入框和值的双向绑定，利用@input="msg=$event.target.value"监听输入并重新赋值和v-bind：value=“msg"

```
     <input v-model="sth" />
     //  等同于
     <input :value="sth" @input="sth = $event.target.value" /> //自html5开始,input每次输入都会触发oninput事件，所以输入时input的内容会绑定到sth中，于是sth的值就被改变;
     //$event 指代当前触发的事件对象;
     //$event.target 指代当前触发的事件对象的dom;
     //$event.target.value 就是当前dom的value值;
     //在@input方法中，value => sth;
     //在:value中,sth => value;
```

v-model的修饰符

1. lazy

   在默认情况下，`v-model` 在input事件中同步输入框的值与数据。

   在添加了lazy之后，会把 `oninput` 事件改成 `onchange` 事件。

   以下是核心代码

   ```
     <div id="app">
       <input type="text" v-model.lazy="msg">
       <p>{{msg}}</p>
     </div>
   </template>
   
   <script>
   export default {
     name: 'app',
     data () {
       return {
         msg: ''
       }
     }
   }
   </script>
   ```

   <img src="https://upload-images.jianshu.io/upload_images/7275569-6beeff14f77751a8.gif?imageMogr2/auto-orient/strip|imageView2/2/w/503/format/webp" alt="img" style="zoom:67%;" />

   可以看到，input框输入的内容并不会实时更新到p标签里。因为这里使用了 `lazy` 修饰符，把 `oninput` 事件改成 `onchange` 事件。

2. number

   `number` 修饰符会把 `v-model` 的值转换成数值类型。

   以下是核心代码

   ```xml
   <template>
     <div id="app">
       <input type="text" v-model.number="msg">
       <p>{{msg}} : {{typeof(msg)}}</p>
     <div/
   <template/>
   <script>
   export default {
     name: 'app',
     data () {
       return {
         msg: ''
       }
     }
   }
   </script>
   ```

   <img src="https://upload-images.jianshu.io/upload_images/7275569-f3336064f0a90a0e.gif?imageMogr2/auto-orient/strip|imageView2/2/w/503/format/webp" alt="img" style="zoom:67%;" />

   需要注意的是，如果输入的第一个字是字符串，那`number`这个修饰符就不会生效。
    输入的第一个只能是数字或者小数点或者是正负号。

   从上图可以看到，如果一开始输入的是数字，后面跟着字符串。再`number`的转换后，会把后面的字符串删掉。

   

3. trim

   `trim`的作用是过滤用户输入时首尾的空格字符。

   以下是核心代码

   ```
   <template>
     <div id="app">
       <input type="text" v-model.trim="msg">
     </div>
   </template>
   <script>
   export default {
     name: 'app',
     data () {
       return {
         msg: ''
       }
     },
     watch: {
       msg(newValue) {
         console.log(newValue);
       }
     }
   }
   </script>
   ```

   <img src="https://upload-images.jianshu.io/upload_images/7275569-7649ccb2dd63cef9.gif?imageMogr2/auto-orient/strip|imageView2/2/w/733/format/webp" alt="img" style="zoom:67%;" />

   这里用了 `watch` 来监听 `msg` ，每当 `msg` 的值有更新，就会在控制台输出更新后的值。

   从控制台可以看到，我们在值的前后输入空格，通过 `trim` 转换后得到的新值首位的空格都是被清除了。

### v-on

> `v-on`就是**用于绑定事件的**
> 例如：有个按钮，当点击的时候执行一些操作

```
<div class="app">
    <button v-on:click="myclick">click me</button>
</div>  
```

上述代码中，`v-on:`后面的值是一个方法，可以写成`myclick()`，没有参数可以写成`myclick`。
 另外这种事件对应的方法不是定义在`data`选项中，而是定义在`vue`实例的`methods`选项中，里面都是一个一个的`function`

```
var app = new Vue({
    el:'.app',
    data:{
        
    },
    methods:{
        myclick:function(){
            console.log(111111);
        }
    }
});
```

`v-on`也可以绑定多个事件
多个事件可以单独多个v-on绑定

```
<div class="app">
    <button v-on:mouseenter='onenter' v-on:mouseleave='leave'>click me</button>
</div>  
```

也可以使用一个`v-on`，里头用对象的形式书写，对象的键名就是事件名，对象的键值就是对应事件要执行的方法。多个事件之间通过`,`分开

```
<div class="app">
    <button v-on="{mouseenter:onenter,mouseleave:leave}">click me</button>
</div>  
```

当然也可以混合使用

```
<div class="app">
    <button v-on="{mouseenter:onenter,mouseleave:leave}" v-on:click="myclick">click me</button>
</div>  
```

例子：在绑定form表单中的提交事件时

```jsx
<div class="app">
    <form v-on:submit='onSubmit($event)'>
        <!-- $event是vue里面的事件对象，vue能认识 -->
        <input type="text" >
        <button type="submit">提交</button>
    </form>
</div>  
```

```
var app = new Vue({
    el:'.app',
    data:{
        
    },
    methods:{
        onSubmit:function(e){
            e.preventDefault();
            //阻止浏览器的默认行为，因为在表单提交的时候，浏览器会默认发送一个get或者post请求到指定页面，刷新整个页面。
            console.log("onSubmited");
        }
    }
});
```

注意：
 `$event`是`vue`里面的事件对象，`vue`能认识
 在表单提交的时候，浏览器会默认发送一个`get`或者`post`请求到指定页面，刷新整个页面。阻止浏览器的默认行为，可以用事件对象`e.preventDefault()`

但像上述form表单提交的这种浏览器默认事件，每次都要写`e.preventDefaul()`其实还是比较麻烦。`vue`中可以更好的解决，只要在事件的后面添加一个`prevent`修饰符即可，表示阻止默认事件

```jsx
<div class="app">
    <form v-on:submit.prevent='onSubmit'>
        <input type="text" >
        <button type="submit">提交</button>
    </form>
</div>  
```

```jsx
var app = new Vue({
    el:'.app',
    data:{
        
    },
    methods:{
        onSubmit:function(){
            console.log("onSubmited");
        }
    }
});
```

绑定事件中，除了`prevent`修饰符，还有`stop`,表示停止冒泡事件

```jsx
<div class="app">
    <div v-on:click.stop='onClick'>
    </div>
</div>  
```

另外,当绑定的事件是`keyup`、`keypress`、`keydown`键盘事件时，当需要判断按下是回车时。
 在以前我们需要判断事件对象的`keyCode`，虽然功能特别简单，但是每次去写还是特别麻烦。所以对应也有修饰符，如enter修饰符，表示按键是enter键

```jsx
<div class="app">
    <div v-on:keydown.enter='mykeydownFn'>
    </div>
</div>  
```

跟`v-bind`一样，v-on也非常常用，对应也有快捷方式：
 `v-on:事件名 可以简写为 @事件名

```jsx
<div class="app">
    <div @keydown.enter='mykeydownFn'>
    </div>
</div>  
```

**v-on 修饰符**

- .stop - 调用 event.stopPropagation()，禁止事件冒泡。
- .prevent - 调用 event.preventDefault()，阻止事件默认行为。
- .capture - 添加事件侦听器时使用 capture 模式。
- .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。
- .{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。
- `.native - 监听组件根元素的原生事件。`
- .once - 只触发一次回调。
- .left - (2.2.0) 只当点击鼠标左键时触发。
- .right - (2.2.0) 只当点击鼠标右键时触发。
- .middle - (2.2.0) 只当点击鼠标中键时触发。
- .passive - (2.3.0) 以 { passive: true } 模式添加侦听器
- .native   如果你想在某个组件的根元素上绑定事件，直接使用 @click=''function' 是不生效的，我们可以添加.native修饰符 @click.native=''function''

这些修饰符可以连着使用，比如：

```
@click.native.prevent='fun'
```

### 数据响应式要注意的点

假如data定义了一个对象，boy{name:'laji'},如果我们修改name为'niubi',那么这个是可以实现响应式的，模板会对应更新的，

但是我想增加一个属性呢，比如增加一个属性age:11（this.boy.age=18这个方式增加),这不是响应式的，模板是不会随着更新的，如果想要实现响应式，有两种方法

1. 我们定义对象的时候可以先定义age:'',这样怎么都是响应式的，但是这只能实现改，不能增加
2. 要增加或者设置的话都可以使用这个方法this.$set(this.boy,'age',18)——参数分别是对象，属性，值

### 父子组件通信

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201027214048493.png" alt="image-20201027214048493" style="zoom:80%;" />

#### 通过props向子组件传递数据（传）

父组件：

```
<template>
  <div id="app">
    <child :sonmsg="parentmsg"></child>
  </div>
</template>
<script>
import child from './views/child'
export default {
  name: 'App',
  components: {
    child,
  },
  data() {
    return {
      parentmsg: 'parentmsg',
    }
  },
}
</script>
<style></style>
```

子组件（用法一）：

```
<template>
  <div>
    <h3>我是子组件</h3>
    <h3>获取父组件的数据:{{ sonmsg }}</h3>
  </div>
</template>
<script>
export default {
  name: 'child',
  data() {
    return {}
  },
	// 不检测类型,全盘接受
    props: ["sonmsg"],
}
</script>
<style scpoed></style>
```

子组件（用法二）：

```
<template>
  <div>
    <h3>我是子组件</h3>
    <h3>获取父组件的数据:{{ sonmsg }}</h3>
  </div>
</template>
<script>
export default {
  name: 'child',
  data() {
    return {}
  },
  props: {
    //定义方式一
    sonmsg: String,
    //定义方式二
    // sonmsg: {
    //   type: Number,
    //   default: 10,//如果父组件没有传值那么默认就为10，
    // 如果是数组或对象，默认值必须是一个函数来返回
    //   propE: {
    // 	type: Array,
    // 	default: () => []
    // }
    // },
    // 定义方式三:
    // sonmsg: {
    //   type: Number,
    //   required: true, //必须传，不然报错
    // },
    //定义方式四
    // 自定义一个验证函数
    // sonmsg: {
    //   validator: (value) => {
    //     return value > 1000 //当函数返回 false 时，输出警告。该函数命名是规定叫validator
    //   },
    // },
  },
}
</script>
<style scpoed></style>

```

结果：

![image-20201027220029318](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201027220029318.png)

`注意：经过测试发现，经过props传值后参数，在Props定义的该参数和父组件是一样的，由于对象是引用类型，所以当父组件把一个对象传给一个子组件的时候，实际上引用的是用一个对象，这时候子组件该值改变也会同时改变父组件该对象的值`

实际上不符合上面规则也能正常显示，但是会报错

#### 通过事件向父组件发送消息（传）

父组件：

```
<template>
  <div id="app">
    <child @itemClick="parentfun"></child>
  </div>
</template>
<script>
import child from './views/child'
export default {
  name: 'App',
  components: {
    child,
  },
  methods: {
    //不接收参数
    parentfun() {
      console.log('子传父')
    },
    //接收参数
    parentfun(item) {
      console.log(item)
      console.log('子传父')
    },
  },
}
</script>
<style></style>
```

子组件：

```
<template>
  <div>
    <button @click="btnClick(name)">子组件按钮，发射事件</button>
  </div>
</template>
<script>
export default {
  name: 'child',
  data() {
    return {
      name: '我是子组件中的name',
    }
  },
  methods: {
    //不传参数
    btnClick() {
      //发射
      this.$emit('itemClick')
    },
    //传参数
    btnClick(item) {
      //发射
      this.$emit('itemClick', item)
    },
  },
}
</script>
<style scpoed></style>
```

#### 父组件访问子组件（访）

> 父组件访问子组件：使用$children或$refs reference(引用)
>
> this.$children或者$refs是一个数组类型，它包含子组件所有对象

**$children**

直接输出this.$children:

```
  created() {
    console.log(this.$children)
  },
```

输出

![image-20201028001432768](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201028001432768.png)

$this.children是所有子组件的一个数组，通过它可以访问它所有子组件的所有数据和方法等等，但是$this.children是通过数组下标来访问子组件数据，比如

```
	console.log(this.$children[0].name)  //name是子组件的数据
	console.log(this.$children[0].btnClick)  //btnClick是子组件的方法
```

可以直接访问子组件的数据和方法，不需要this.$children.data.name或者this.$children.methods.btnClick

但是this.$children有一个缺点，就是需要通过下标来访问子组件，假如有多个子组件，就得输出区查看对应子组件得下标值才能确定用哪个下标

**$refs**

直接输出this.$refs:

```
  created() {
    console.log(this.$children)
  },
```

输出

![image-20201028002305031](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201028002305031.png)

输出为一个空对象

$refs默认为一个空数组，但是在对应得子组件加上ref="自定义名字",就能访问该子组件了，并且可以通过该自定义名称来访问

当我在子组件child加上ref时

![image-20201028002501028](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201028002501028.png)

这时候再输出$refs

![image-20201028002530448](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201028002530448.png)

这时候就可以通过自定义名称访问子组件了，

```
	console.log(this.$refs.one.name)  //name是子组件的数据
	console.log(this.$refs.one.btnClick)  //btnClick是子组件的方法
```

`最重要一点是,通过ref可以直接获取普通原宿的dom，这样就不需要document.get什么了，`

例：

```
<template>
  <div class="com-container" ref="test">
    <div class="com-chart" ref="seller_ref">你好</div>
  </div>
</template>
<script>
export default {
  name: 'Seller',
  data() {
    return {}
  },
  components: {},
  methods: {
  },
  mounted() {
    console.log(this.$refs.test)      
    console.log(this.$refs.seller_ref.innerHTML)
  },
}
</script>
```

输出：

![image-20210106101430868](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210106101430868.png)

#### 子组件访问父组件（访）

> 子组件访问父组件：使用$parent

子访问父由于只可能有一个父组件（定义在模板里面的不是子组件，只有调用了才算子组件，就算同一个模板在不同组件里面它们也是独立的，只可能有一个父组件），所以$parent非常简单

直接输出：

```
  created() {
    console.log(this.$parent)
  },
```

输出：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201028003140417.png" alt="image-20201028003140417" style="zoom:67%;" />

如果需要访问父组件的数据或者方法可以这样访问：

	console.log(this.$parent.name)  //name是父组件的数据
	console.log(this.$parent.btnClick)  //btnClick是父组件的方法
虽然$children、$refs和$parent非常简单易用，但是会让组件之间不够独立，尽量减少使用

### 组件通信（非父子关系）

> 有时候两个组件也需要通信（非父子关系）。当然Vue2.0提供了Vuex，但在简单的场景下，可以使用一个空的Vue实例作为中央事件总线。

在main.js创建一个空的Vue实例，并且赋值给Vue.prototype.bus

```
	Vue.prototype.bus = new Vue()
```

现在，这个特定的总线使用两个方法 `$on` 和 `$emit` 。一个用于创建发出的事件，它就是`$emit` ；另一个用于订阅 `$on` ,可以在任意组件使用，但是尽量在平行组件使用，而且减少使用

在一个组件发送事件和数据：

```
	this.bus.$emit("eventName",data)
```

在另一个组件中接收事件和数据（一般放在created方法中)：

```
	this.bus.$on("eventName",(data) => { console.log(data)})
```

this的作用域要指向当前的vm实例，on监听事件一般放在组件生命周期函数中的created或者mounted中，注销bus需要在beforeDestroy中；

页面路由的时候，原有页面中的bus事件并没有被注销，依然隐藏在程序中，注册的总线事件要在组件销毁时卸载，否则会多次挂载，造成触发一次但多个响应的情况可以在离开界面时注销bus。

```
	beforeDestroy () {
   		 this.$bus.$off('eventName',this.todo);
	}
```

需要注意的是：`由于公车总线是利用新创建的Vue对象来进行传递事件的`，`所以emit和on中绑定的回调函数中的this并不指向原来的Vue对象，`

`所以我们需要提前定义一个变量来接收原来的this,比如在emit和on函数前写：let _this = this，这样我们就能拿到原来对象的数据了`

### slot插槽,

#### 匿名插槽

匿名插槽的基本使用，

使用例子：

子组件：

```
<template>
    <div class="child">
        <h3>这里是子组件</h3>
        <slot><span>默认值</span></slot>
    </div>
</template>

```

父组件：

```
<template>
    <div class="father">
        <h3>这里是父组件</h3>
        <child>
            <div class="tmpl">
              <span>菜单1</span>
              <span>菜单2</span>
              <span>菜单3</span>
              <span>菜单4</span>
              <span>菜单5</span>
              <span>菜单6</span>
            </div>
        </child>
    </div>
</template>
<script>
  import Child from './Child.vue'
    export default {
        components:{
          'child': Child
        }
    }
</script>
```

在使用子组件时，只有当子组件里面定义了插槽才能往子组件里面填东西，而且都会插在匿名插槽里面

`<slot><span>默认值</span></slot>，solt里面可以给定默认值，如果没有给他插入值，那么就显示默认值，如果有插入其他元素，那么默认值就会被覆盖`

上面使用后输出结果：

![image-20201028230741038](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201028230741038.png)

#### 具名插槽

具名插槽的基本使用，

子组件：

```
<template>
  <div class="child">
    <slot name="up"></slot>
    <h3>这里是子组件</h3>
    <slot name="down"></slot>
    <slot></slot>
  </div>
</template>
```

父组件：

```
<template>
  <div class="father">
    <h3>这里是父组件</h3>
    <child>
      <div class="tmpl" slot="up">
        <span>我是name为up的具名插槽</span>
      </div>
      <div class="tmpl" slot="down">
        <span>我是name为down的具名插槽</span>
      </div>
      <div class="tmpl">
        <span>我是匿名插槽</span>
      </div>
    </child>
  </div>
</template>
<script>
  import Child from './Child.vue'
  export default {
    components:{
      'child': Child
    }
  }
</script>
```

`具名插槽可以和匿名插槽混用`，具名插槽有名字，子组件通过 <slot name="up"></slot>定义，父组件在使用的时候通过slot="up"使用，并且会放到对应的位置

上面例子的输出结果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201028232146002.png" alt="image-20201028232146002" style="zoom:80%;" />

#### 作用域插槽(vue3.0已废弃)

在接下来所有的 2.x 版本中 `slot` 和 `slot-scope` attribute 仍会被支持，但已经被官方废弃且不会出现在 Vue 3 中。

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201028233714051.png" alt="image-20201028233714051" style="zoom:80%;" />

由上面我们可以得知，作用域插槽的主要作用时能够让父组件自定义使用子组件里面的数据，比如下面例子

子组件：

```
<template>
  <div class="child">
    <h3>这里是子组件</h3>
    <slot :data="per" name="up"></slot>
    <slot :data="per" ></slot>
  </div>
</template>

<script>
export default {
  data: function() {
    return {
      per: ["zhangsan", "lisi", "wanwu", "zhaoliu", "tianqi", "xiaoba"]
    };
  },
  computed: {},
  methods: {},
  components: {}
};
</script>
```

子组件里面有数据data，通过:data=“per",我们可以把子组件中的一些数据传给父组件处理，而不是在子组件写死

父组件：

```
<template>
  <div class="father">
    <h3>这里是父组件</h3>
    <!--第一次使用：用flex展示数据-->
    <child>
      <div1 slot-scope="user1" slot="up">
        <div class="tmpl">
          <span v-for="item in user1.data" :key="item">{{ item }}</span>
        </div>
      </div1>
    </child>
    <!--第二次使用：用列表展示数据-->
    <child>
      <template slot-scope="user2" slot="up">
        <ul>
          <li v-for="item in user2.data" :key="item">{{ item }}</li>
        </ul>
      </template>
    </child>
    <!--第三次使用：直接显示数据-->
    <child>
      <template slot-scope="user3">
        {{ user3.data }}
      </template>
    </child>
    <!--第四次使用：不使用其提供的数据-->
    <child>
      我就是模板
    </child>
  </div>
</template>
<script>
import Child from "./Child.vue";
export default {
  components: {
    child: Child
  }
};
</script>
```

在要插入的内容中加上solt-scope='自定义名字'就可以获取子组件中绑定给:data的数据了，并且赋值给自定义名字,

从上面可以看出，这时候就可以利用solt-scope获取子组件数据，从而实现自定义使用了

上面有些不是使用div而是使用template,这是因为旧版本要求必须是template,所以为了兼容性，有些时候会写template

注意：是通过自定义名字.data输出子组件数据

上面例子输出结果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201029000428683.png" alt="image-20201029000428683" style="zoom:80%;" />

## 生命周期

> Vue实例有一个完整的生命周期，也就是说从开始创建、初始化数据、编译模板、挂在DOM、渲染-更新-渲染、卸载等一系列过程，我们成为Vue 实例的生命周期，钩子就是在某个阶段给你一个做某些处理的机会。

<img src="https://upload-images.jianshu.io/upload_images/11370083-f279314aef6741db.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1080/format/webp" alt="img" style="zoom: 67%;" />

**beforeCreate( 创建前 )**

在实例初始化之后，数据观测和事件配置之前被调用，此时组件的选项对象还未创建，el 和 data ,methods并未初始化，因此无法访问methods， data， computed等上的方法和数据。

**created ( 创建后 ）**

实例已经创建完成之后被调用，在这一步，实例已完成以下配置：数据观测、属性和方法的运算，watch/event事件回调，完成了data 数据的初始化，el没有。 然而，挂在阶段还没有开始, $el属性目前不可见，这是一个常用的生命周期，因为你可以调用methods中的方法，改变data中的数据，并且修改可以通过vue的响应式绑定体现在页面上，，获取computed中的计算属性等等，通常我们可以在这里对实例进行预处理，也有一些童鞋喜欢在这里发ajax请求，值得注意的是，这个周期中是没有什么方法来对实例化过程进行拦截的，因此假如有某些数据必须获取才允许进入页面的话，并不适合在这个方法发请求，建议在组件路由钩子beforeRouteEnter中完成

**beforeMount**

挂在开始之前被调用，相关的render函数首次被调用（虚拟DOM），实例已完成以下的配置： 编译模板，把data里面的数据和模板生成html，完成了el和data 初始化，注意此时还没有挂在html到页面上。

**mounted**

挂在完成，也就是模板中的HTML渲染到HTML页面中，此时一般可以做一些ajax操作，mounted只会执行一次。

**beforeUpdate**

在数据更新之后被调用，发生在虚拟DOM重新渲染和打补丁之前，可以在该钩子中进一步地更改状态，不会触发附加地重渲染过程

**updated（更新后）**

虚拟dom重新被渲染挂载成功

**beforeDestroy（销毁前）**

在实例销毁之前调用，实例仍然完全可用，

1. 这一步还可以用this来获取实例，
2. 一般在这一步做一些重置的操作，比如清除掉组件中的定时器  和 监听的dom事件

**destroyed（销毁后）**

在实例销毁之后调用，调用后，所以的事件监听器会被移出，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="app">
    <p id="h3">
      {{msg}}
    </p>
    <button @click='change'>按钮</button>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
  <script>
    var vm = new Vue({
      el: '#app',
      data: {
        msg: '我是msg'
      },
      methods: {
        show() {
          console.log('执行了show方法');
        },
        change() {
          this.msg = '修改后的msg'
        }
      },
      //这是第1个生命周期函数，表示实例完全被创建出来之前，data和methods中的数据都还没有初始化
      beforeCreate() {
        console.log('------beforeCreate------');
        console.log(this.msg);
        this.show()
      },
      //这是第2个生命周期函数，data和methods中的数据已经初始化可以访问了
      created() {
        console.log('------created------');
        console.log(this.msg);
        this.show()
      },
      //这是第3个生命周期函数，表示模板已经在内存中编辑成功了，但是尚未把模板渲染到页面中
      beforeMount() {
        console.log('------beforeMount------');
        console.log(document.getElementById('app').innerHTML);
        //在beforeMount执行的时候，页面中的元素，还没有被真正替换过来
      },
      //这是第4个生命周期函数，虚拟dom挂载完毕
      mounted() {
        console.log('------mounted------');
        console.log(document.getElementById('app').innerHTML);
      },
      //这是第5个生命周期函数，在数据更新之后被调用
      beforeUpdate() {
        console.log('------beforeUpdate------');
      },
      //这是第6个生命周期函数，虚拟dom重新被渲染挂载成功
      updated() {
        console.log('------updated------');
      }
    })
  </script>
</body>

</html>
```

结果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210220003456166.png" alt="image-20210220003456166" style="zoom:67%;" />



## watch

> 可以监听特定数据变化

基本用法：

当fullName值变化时，watch监听到并且执行

```
<div>
      <p>FullName: {{fullName}}</p>
      <p>FirstName: <input type="text" v-model="firstName"></p>
</div>
new Vue({
  el: '#root',
  data: {
    firstName: 'Dawei',
    lastName: 'Lou',
    fullName: ''
  },
  watch: {
    firstName(newName, oldName) {
      this.fullName = newName + ' ' + this.lastName;
    }
  } 
})
```

watch中的函数名必须和要监听的数据变量名一致，参数中的newName和oldName分别为数据未改变前的值和改变后的值，当然，这两个参数名可以自定义，只需要注意第一个参数为旧值，第二个参数为新值就行

- handler方法和immediate属性
   上面的例子是值变化时候，watch才执行，我们想让值最初时候watch就执行就用到了`handler`和`immediate`属性

```
watch: {
  firstName: {
    handler(newName, oldName) {
      this.fullName = newName + ' ' + this.lastName;
    },
    // 代表在wacth里声明了firstName这个方法之后立即先去执行handler方法，如果设置了false，那么效果和上边例子一样
    immediate: true
  }
}
```

- deep属性（深度监听，常用语对象下面属性的改变）

```
<div>
      <p>obj.a: {{obj.a}}</p>
      <p>obj.a: <input type="text" v-model="obj.a"></p>
</div>
new Vue({
  el: '#root',
  data: {
    obj: {
      a: 123
    }
  },
  watch: {
    obj: {
      handler(newName, oldName) {
         console.log('obj.a changed');
      },
      deep: true
    }
  } 
})
```

我们在在输入框中输入数据视图改变obj.a的值时，我们发现是无效的。受现代 JavaScript 的限制 (以及废弃 Object.observe)，Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。

 默认情况下 handler 只监听obj这个属性它的引用的变化，我们只有给obj赋值的时候它才会监听到，比如我们在 mounted事件钩子函数中对obj进行重新赋值：

```
mounted: {
  this.obj = {
    a: '456'
  }
}
```

 那么我们需要监听obj里的属性a的值呢？这时候deep属性就派上用场了:

```
watch: {
  obj: {
    handler(newName, oldName) {
      console.log('obj.a changed');
    },
    immediate: true,
    deep: true
  }
}
```

 这样的方法对性能影响很大，修改obj里面任何一个属性都会触发这个监听器里的 handler。所以尽量少使用

实际开发中，watch会随着组件一并销毁。

## 				vue-cli脚手架

## 				vue-router路由

### **前端路由如何实现的？**

- 改变URL，但是页面不进行整体的刷新。

**怎么实现呢？**

URL的hash

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201021235831243.png" alt="image-20201021235831243" style="zoom:67%;" />

还有html5的history

这些方法都会改变url，但是不会让页面重新刷新

vue-router就是基于以上实现的

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022001834640.png" alt="image-20201022001834640" style="zoom: 50%;" />

### vue-router的基本使用

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022001958526.png" alt="image-20201022001958526" style="zoom: 67%;" />

安装的话可以使用脚手架自动安装也可以手动安装

第一步导入路由对象：import VueRouter from 'vue-router'

第二步创建路由实例：

```
	import Vue from 'vue'
     import VueRouter from 'vue-router'
     import Main from '../views/Main.vue'
     import CategoryEdit from 'views/CategoryEdit'
     import CategoryList from 'views/CategoryList'
	Vue.use(VueRouter)
     const routes = [
       {
         path: '',
         redirect: '/main',
       },
       {
         path: '/main',
         name: 'Main',
         component: Main,
         children: [
           {
             path: '/categories/create',
             component: CategoryEdit,
           },
           {
             path: '/categories/list',
             component: CategoryList,
           },
         ],
       },
     ]
     创建路由实例
     const router = new VueRouter({
       mode: 'history',
       base: process.env.BASE_URL,
       routes,
     })
     export default router
```

第三步：在Vue实例挂载路由实例

在main.js中：

```
     import http from 'network/index'
     new Vue({
      router,
      store,
      render: (h) => h(App),
     }).$mount('#app')			
```

如何使用呢？

可以通过this.$router.push('/categories/list')和this.$router.replace('/categories/list'),前者会保存历史，后者不会保存

通过上面方法可以改变url但不会重新刷新，然后$router会根据url重新渲染页面

当然要渲染在哪里，需要一个标签<router-view/>

还可以用<keep-alive>包裹<router-view/>来保持状态，防止被销毁,使用keep-alive的保持的组件都要有name属性

![image-20201022004516279](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022004516279.png)

这时候的push和replace实际就是history的pushState和replaceState方法

一级路由会在任何的<router-view/>中渲染对应的模板，App.vue中的 `<router-view>` 是最顶层的出口，渲染最高级路由匹配到的组件。子路由只会在父路由的<router-view/>中的模板的<router-view/>渲染

### Vue**的前进和后退**

> 项目开发的时候，有时候可能需要我们来对页面后退和前进，这个东西跟浏览器自带的前进后退功能很像

1. 后退功能

   vue中的后退有好多种方法可以使用，`使用这些方法前要确认有之前的页面，否则后退就到了一个空页面！`

   可以通过history.length来获取历史记录的长度

   ```
   console.log(history.length)
   ```

   `1.window.history`对象中保存有页面访问的历史记录，在编写时可不使用 window 这个前缀。 加载历史列表中的前一个URL，这与在浏览器中点击前进按钮是相同的

   window.history.back();  后退1步

   history.back();        后退1步

   `2.this.$router.go(-1);`   通过vue的路由来进行后退1步

     this.$router.go(-2);   后退2步

     this.$router.back();   后退1步

2. 前进功能

   可以通过history.forward(); 来加载历史列表中的下一个URL，这与在浏览器中点击前进按钮是相同的,`使用前需要确认有下一个URL，否则没反应~`

### 动态路由

#### 用法一

定义

![image-20201022005021089](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022005021089.png)

使用

![image-20201022005410642](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022005410642.png)

![image-20201022005341350](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022005341350.png)

跳转的页面展示：

![image-20201022005756913](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022005756913.png)

![image-20201022005741368](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022005741368.png)

**this.$route.prams是获取当前活跃的页面的路由的参数，可以通过动态路由来传递数据**

**this.$route.path是获取当前活跃的页面的路由的参数**



#### 用法二

在路由定义对象中加上props:true,然后在跳转的页面的props定义对应的变量就可以直接传值了

```
     routes:[
     path:’/about/:param’,
     component:About,
     props:true//这个表示用法一的$router.params会通过props传给下一个url中的props
     ]
```

```
	//跳转的页面
	props:{
		param:''
	}
```



### 路由传递参数的另外两种方式

我们经常使用this.$router.push("/home");,参数为字符串的方式来方式来跳转，这种方式很简单，但是不能传递参数

下面介绍的两种传递路由参数的方法都是以对象的方式进行传递

#### 命名路由

> 命名路由的前提就是在注册路由的地方需要给路由（跳转后的页面）命名如：

<img src="https://img-blog.csdn.net/20180706161414540?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQzMDczNDk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img" style="zoom:80%;" />

命名路由传递参数需要使用params来传递，这里一定要注意使用params不是query。目标 页面接收传递参数时使用params

`特别注意：命名路由这种方式传递的参数，如果在目标页面刷新是会出错的`，因为刷新后prams就为空了

使用方法如下：

```
	this.$router.push({ name: 'news', params: { userId: 123 }})
```

代码如下：

```
	 <template>
       <div class="hello">
         <h1>未跳转的页面</h1>
         <button @click="routerTo">click here to news page</button>
       </div>
     </template>
     <script>
     export default {
       name: 'HelloWorld',
       methods:{
         routerTo(){
           this.$router.push({ name: 'news', params: { userId: 123 }});
         }
       }
     }
```

接收传递的参数：

```
     <template>
       <div>
         this is the news page.the transform param is {{this.$route.params.userId}}
       </div>
     </template>
     <script>
     </script>
```

#### 查询参数传递（推荐使用）

> 查询参数其实就是在路由地址后面带上参数和传统的url参数一致的，传递参数使用query而且必须配合path来传递参数而不能用name，目标页面接收传递的参数使用query。

`注意：和name配对的是params，和path配对的是query`

使用方法如下：

```
	this.$router.push({ path: '/news', query: { userId: 123 }});
```

代码如下：

```
     <template>
       <div class="hello">
         <h1>跳转前</h1>
         <button @click="routerTo">click here to news page</button>
       </div>
     </template>
     <script>
     export default {
       name: 'HelloWorld',
       methods:{
         routerTo(){
           this.$router.push({ path: '/news', query: { userId: 123 }});
         }
       }
     }
     </script>
```

接收参数如下：

```
<template>
  <div>
    跳转后 {{this.$route.query.userId}}
  </div>
</template>
<script>
</script>
```

最后总结：路由传递参数和传统传递参数是一样的，命名路由类似表单提交而查询就是url传递，在vue项目中基本上掌握了这两种传递参数就能应付大部分应用了，最后总结为以下两点：
***\*1.命名路由搭配params，刷新页面参数会丢失
	2.查询参数搭配query，刷新页面数据不会丢失
	3.接受参数使用this.$router后面就是搭配路由的名称就能获取到参数的值\****

另外，二者还有点区别，直白的来说query相当于get请求，页面跳转的时候，可以在地址栏看到请求参数，而params相当于post请求，参数不会再地址栏中显示

### 路由的懒加载

### 嵌套路由（子路由）

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022010256373.png" alt="image-20201022010256373" style="zoom:67%;" />

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022010413211.png" alt="image-20201022010413211" style="zoom:67%;" />

路由配置`（记住，子路由开头不能加/)`

![image-20201022010954082](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022010954082.png)

使用

![image-20201022010828374](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022010828374.png)

子路由的view-router只能在父路由的组件中写router-view

### 导航守卫

1. 全局路由钩子

   > 是指路由实例上直接操作的钩子函数，他的特点是所有路由配置的组件都会触发，直白点就是触发路由就会触发这些钩子函数

   **beforeEach(to,from, next)**

   这个钩子作用主要是用于登录验证，在路由跳转前触发

   基本使用：

   ```
   router.beforeEach((to, from, next) => {
     if (to.path === '/Login') {
       next()
     } else {
       let token = localStorage.token
       if (!token) {
         next('/Login')
       } else {
         next()
       }
     }
   })//这些代码写在router文件夹中的index.js下
   ```

   next('/Login')就是跳转到/Login路由，next()就是正常跳转，详情请看下面介绍

   **beforeResolve(to,from, next)**

   这个钩子和beforeEach类似，也是路由跳转前触发，即在 beforeEach 和 组件内beforeRouteEnter 之后，afterEach之前调用。

   **afterEach(to,from)；**

   和beforeEach相反，他是在路由跳转完成后触发，`参数包括to,from没有了next（参数会单独介绍）`,他发生在beforeEach和beforeResolve之后，beforeRouteEnter（组件内守卫，后讲）之前。

2.  独享路由钩子

   > 指在单个路由配置的时候也可以设置的钩子函数，其位置就是下面示例中的位置

   ```
   const router = new VueRouter({
     routes: [
       {
         path: '/foo',
         component: Foo,
         beforeEnter: (to, from, next) => {
           // ...
         }
       }
     ]
   })
   ```

   **beforeEnter(to,from, next)；**

   和beforeEach完全相同，在该组件渲染前执行，如果都设置则在beforeEach之后紧随执行，参数to、from、next

3. 组件内路由钩子

   ```
   指在组件内执行的钩子函数，类似于组件内的生命周期，相当于为配置路由的组件添加的生命周期钩子函数。
   ```

   **beforeRouteEnter(to,from, next)**

   路由进入之前调用，参数包括to，from，next。该钩子在全局守卫beforeEach和独享守卫beforeEnter之后，全局beforeResolve和全局afterEach之前调用，要注意的是该守卫内访问不到组件的实例，也就是this为undefined，也就是他在beforeCreate生命周期前触发。在这个钩子函数中，可以通过传一个回调给 next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数，可以在这个守卫中请求服务端获取数据，当成功获取并能进入路由时，调用next并在回调中通过 vm访问组件实例进行赋值等操作，（next中函数的调用在mounted之后：为了确保能对组件实例的完整访问）。

   **beforeRouteUpdate(to,from, next)**

   在当前路由改变时，并且该组件被复用时调用，可以通过this访问实例。参数包括to，from，next。可能有的同学会疑问，what is 路由改变 or what is 组件被复用？

   - 对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，组件实例会被复用，该守卫会被调用
   - 当前路由query变更时，该守卫会被调用

   **beforeRouteLeave(to,from, next)**

   导航离开该组件的对应路由时调用，可以访问组件实例`this`，参数包括to，from，next。

   ```
   <template>
     ...
   </template>
   export default{
     data(){
       //...
     },
     beforeRouteEnter (to, from, next) {
       // 在渲染该组件的对应路由被 confirm 前调用
       // 不！能！获取组件实例 `this`
       // 因为当守卫执行前，组件实例还没被创建
     },
     beforeRouteUpdate (to, from, next) {
       // 在当前路由改变，但是该组件被复用时调用
       // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
       // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
       // 可以访问组件实例 `this`
     },
     beforeRouteLeave (to, from, next) {
       // 导航离开该组件的对应路由时调用
       // 可以访问组件实例 `this`
     }
   }
   ```

   **导航守卫回调参数**

   to：目标路由对象；

   from：即将要离开的路由对象；

   next：他是最重要的一个参数，他相当于佛珠的线，把一个一个珠子逐个串起来。以下注意点务必牢记：

   1.但凡涉及到有next参数的钩子，必须调用next() 才能继续往下执行下一个钩子，否则路由跳转等会停止。

   2.如果要中断当前的导航要调用next(false)。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮)，那么 URL 地址会重置到`from`路由对应的地址。（主要用于登录验证不通过的处理）

   3.当然next可以这样使用，next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。意思是当前的导航被中断，然后进行一个新的导航。可传递的参数与[router.push](https://link.zhihu.com/?target=https%3A//router.vuejs.org/zh/guide/essentials/navigation.html)中选项一致。

   4.在beforeRouteEnter钩子中next((vm)=>{})内接收的回调函数参数为当前组件的实例vm，这个回调函数在生命周期mounted之后调用，也就是，他是所有导航守卫和生命周期函数最后执行的那个钩子。

   5.next(error): (v2.4.0+) 如果传入 `next` 的参数是一个 `Error` 实例，则导航会被终止且该错误会被传递给 `router.onError()` 注册过的回调。

   总结：
   **当点击切换路由时：beforeRouterLeave-->beforeEach-->beforeEnter-->beforeRouteEnter-->beforeResolve-->afterEach-->beforeCreate-->created-->beforeMount-->mounted-->beforeRouteEnter的next的回调**，

   **当路由更新时：beforeRouteUpdate**

   <img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201107173715727.png" alt="image-20201107173715727" style="zoom:80%;" />

## 				vue-x

**vuex是做什么的？**

官方解释：Vuex是一个专为Vue.js应用程序开发的状态管理模式。

- 它采用`集中式存储管理`应用的所有组件的状态(state),并以相应的规则保证状态以一种可预测的方式发生变化。
- Vuex也集成到Vue的官方调试工具Devtools extension,提升了诸如零配置的time-travel调试、状态快照导入导出等高级调试功能。

### **基本使用**（不建议使用）

在store文件夹中的index.js添加以下代码（如果使用脚手架创建时选择了vuex功能那么以下代码会自动生成）：

```
     import Vue from 'vue'
     import Vuex from 'vuex'
     //使用插件
     Vue.use(Vuex)
     //创建并导出实例对象
     export default new Vuex.Store({
         state: {
         //全局数据，可以在任何组件使用
             counter: 1000,
             studentarr:[]
         },
         mutations: {
         },
         actions: {},
         modules: {}
     })
```

在main.js中加上以上代码（如果使用脚手架创建时选择了vuex功能那么以下代码会自动生成）：

```
     import Vue from 'vue'
     import App from './App.vue'
     import router from './router'
     import store from './store'
     Vue.config.productionTip = false
     new Vue({
       router,
       //挂载vuex实例对象
       store,
       render: h => h(App)
     }).$mount('#app')
```

上面代码配置完毕后就可以在任何组件使用vuex中的数据和方法了，在<script>中调用使用：this.$store.state.couter,

在<template>中调用使用：$store.state.counter

例如在home.vue中使用(直接修改state)：

![image-20201020205124071](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201020205124071.png)

![image-20201020205619263](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201020205619263.png)

上面是最简单的使用方式，但是这样使用会导致Devtools无法监控数据的修改情况

为什么会这样呢？

![image-20201020205936930](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201020205936930.png)

因为这是vue官方规定的 ，但并不强制，而且这样这是可以的，并且devtools也能监控到数据变化，但是只能监控同步数据，

异步数据需要用action->mutations->state

![image-20201020210332281](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201020210332281.png)

### Mustaions

处理同步函数

下面是第二种方法（通过mutations修改state）:

在store中的index.js的mutations加上方法：

```
	import Vue from 'vue'
     import Vuex from 'vuex'
     //使用插件
     Vue.use(Vuex)
     //创建并导出实例对象
     export default new Vuex.Store({
         state: {
         //全局数据，可以在任何组件使用
             counter: 1000,
             studentarr:[]
         },
         //定义mutations方法
         mutations: {
         	  increment(state){
         	  	state.counter++
         	  }
         },
         actions: {},
         modules: {}
     })
```

调用mutations方法：

```
 methods: {
    add() {
      this.$store.commit('increment')
    },
  },
```

那么mutations该怎么携带参数呢？

```
mutations: {
    istabbar(state, istrue) {
      state.main = istrue
    },
    addstudent(state, student) {
      state.studentarr.push(student)
    },
  },
```

```
methods: {
    addstudent() {
      let stu = {
        name: '卢本伟',
        mark: 89,
      }
      //这样只能携带一个参数，如果希望传入多个参数，可以以对象的形式传
      this.$store.commit('addstudent', stu)
    },
  },
```

### Actions

处理异步函数

第三种方法(action->mutations->state)：

Vuex要求我们Mutations中的方法必须是同步方法。

```
      state: {
         main: 'true',
         studentarr: [{ name: '卢本伟', mark: 78 }],
       },
       mutations: {
         istabbar(state, istrue) {
           state.main = istrue
         },
         addstudent(state, student) {
           state.studentarr.push(student)
         },
       },
       actions: {
         //context上下文，这里的context相当于state
         aAddstudent(context, stu) {
           setInterval(() => {
             context.commit('addstudent', stu)
           }, 1000)
         },
       },
```

```
 methods: {
    addstudent() {
      let stu = {
        name: '卢本伟',
        mark: 89,
      }
      this.$store.dispatch('aAddstudent', stu)
    },
  },
```

如果需要回调函数还可以这样：

```
 actions: {
    //context上下文，这里的context相当于state
    aAddstudent(context, stu) {
      setInterval(() => {
        context.commit('addstudent', stu.payload)
        stu.success()
      }, 1000)
    },
  },
```

```
  this.$store.dispatch('aAddstudent', {
        payload: stu,
        success: () => {
          console.log('执行完成')
        },
      })
```

或者这样(`最推荐`）：

```
 actions: {
    //context上下文，这里的context相当于state
    aAddstudent(context, stu) {
     return new Promise((reslove,reject)={
		setInterval(() => {
        context.commit('addstudent', stu.payload)
        resolve('执行完毕了')
      }, 1000)
	}) 
    },
  },
```

```
  this.$store.dispatch('aAddstudent', {
        payload: stu,
        success: () => {
          console.log('执行完成')
        },
      }).then(res=>{
      console.log(res)
      })
```

### Module

Module是模块的意思，为什么在Vuex中我们要使用模块呢？

- Vue使用单一状态树，那么也意味着很多状态都会交给Vuex来管理
- 当应用变得非常复杂时，store对象就有可能变得相当臃肿
- 为了解决这个问题，Vuex允许我们将store分割成模块（Module)，而每个模块拥有自己的state,mutation,action

## axios

### 基本使用

axios功能特点：

- 在浏览器中发送XMLHttpRequests请求
- 在node.js中发送http请求
- 支持Promise API
- 拦截请求和响应
- 转换请求和响应数据

1. 安装axios(vue是不自带axios的，需要手动安装)

   ```
   npm install axios --save
   ```

2. 引入并配置axios

   第一步：创建network文件夹（非必须，个人习惯），在network文件夹下创建request.js

   request.js输入以下内容：

   ```
   import axios from 'axios'
   const http = axios.create({
     baseURL: 'http://localhost:3000/api/admin',//这个按实际情况填写
   })
   export default http
   ```

   第二部：在main.js中引入并配置axios(`推荐使用`)

   如果想获取baseUrl,需要$http.defaults.baseUrl

   输入以下代码：

   ```
   import http from 'network/index'
   Vue.prototype.$http = http//这样可以让axios在所有组件中使用
   ```

3. 基本使用

   <img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201020232129637.png" alt="image-20201020232129637" style="zoom:80%;" />

   **1、axios(config)**

   ```
   import axios from 'axios'
   //如果method不写，默认是get请求
     axios({
     	 method:'get'
         url: 'http://152.136.185.210:8000/home/data?type=sell&page=3',
    }).then((res) => {
         console.log(res)
    })
   ```

   ```
     axios({
         url: 'http://152.136.185.210:8000/home/data',
         //专门针对get请求的参数拼接
         params:{
           type='top',
           page:1
         }}).then((res) => {
         console.log(res)
       })
   ```

   2、axios.get(url[,config]),中括号[]里面的表示可选，config表示配置

   ```
   import axios from 'axios'
   //如果method不写，默认是get请求
     axios.get('http://152.136.185.210:8000/home/data?type=sell&page=3',{
     	 method:'get'
    }).then((res) => {
         console.log(res)
    })
   ```

   3、axios.post(url[,data[,config]])

   ```
   import axios from 'axios'
   //如果method不写，默认是get请求
     axios.post('http://152.136.185.210:8000',{
     	name:'lisi',
     	age:18
    }).then((res) => {
         console.log(res)
    })
   ```

注意：axios请求返回的是一个promise，我们需要用.then(res =>{})来拿到正常的数据类型

### axios发送并发请求

指定一个或几个请求发送接收完毕再处理

```
 axios
      .all([
        axios.get('url: 'http://152.136.185.210:8000/home/data',
          {
          params: {
            type: 'top',
            page: 1,
          },
        }),
        axios.get('url: 'http://152.136.185.210:8000/home/data'),
      ])
      .then(
        axios.spread((res1, res2) => {
          console.log(res1)
          console.log(res2)
        })
      )
```

其中res1对应第一个请求结果，res2对应第二个请求结果

![image-20201021005944417](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201021005944417.png)

### 全局配置

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201021010330644.png" alt="image-20201021010330644" style="zoom:67%;" />

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201021012609384.png" alt="image-20201021012609384" style="zoom:67%;" />

### axios的实例

```
   const instance1 = axios.create({
      baseURL: 'http://localhost:3005/admin/api',
      timeout: 5000,
    })
    instance1.get('/index').then((res) => {
      console.log(res)
    })
```

### axios模块封装

为了实现可复用，我们一般会采用封装的形式使用axios，也就是再network文件夹创建request.js,然后向外暴露接口，

有需要使用网络请求的直接调用这个接口

使用实例：

在network中的request.js中：

```
	import axios from 'axios'
     export function request(config) {
       // 1、创建axios的实例
       const instance = axios.create({
         baseURL: 'http://152.136.185.210:8000',
         timeout: 5000,
       })
       //发送真正的网路请求
       return instance(config)
     }
```

在其他组件中：

```
	import { request } from './network/request'	
	request({
      url: '/home/data',
    })
      .then((res) => {
        console.log(res)
      })
      .catch((err) => {
        console.log(err)
      })
```

当然，上面方法还是需要在每个组件中导入，所以还不够好，以下方案比较推荐使用，不需要每次都导入，直接可以用$http引用

第一步：创建network文件夹（非必须，个人习惯），在network文件夹下创建request.js

request.js输入以下内容：

```
     import axios from 'axios'
     const http = axios.create({
       baseURL: 'localhost:3000/admin/api',//这个按实际情况填写
     })
     export default http
```

第二部：在main.js中引入并配置axios(`推荐使用`)

输入以下代码：

```
     import http from 'network/index'
     Vue.prototype.$http = http//这样可以让axios在所有组件中使用
```

### axios拦截器（interceptors)的使用

request请求拦截器：发送请求前统一处理，如：设置请求头headers、应用的版本号、终端类型,登录token等。

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201107110132399.png" alt="image-20201107110132399" style="zoom:67%;" />	  

config就是发送的请求，必须return 返回，请求才能继续发送

如果我们想阻止发送请求或者接收请求，我们可以返回一个Promise.reject(err)

response响应拦截器：有时候我们要根据响应的状态码来进行下一步操作，例如：由于当前的token过期，接口返回401未授权，那我们就要进行重新登录的操作。

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201107110154752.png" alt="image-20201107110154752" style="zoom:80%;" />

响应拦截可以实现登录控制，和返回数据处理

### 处理跨域

在vue.config.js（如果没有就在项目根目录新创建）中加上如下代码：

![image-20201017122820391](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201017122820391.png)

```
//解决跨域问题
  devServer: {
    proxy: {
      //配置跨域
      '/api': {
        target: 'http://121.121.67.254:8185/', //这里后台的地址模拟的;应该填写你们真实的后台接口
        changOrigin: true, //允许跨域
      },
    },
  },
```

其中/api的意思是拦截你所有带有/api的请求，然后让拦截的本地模拟服务器请求数据，这样就不会产生跨域了

`设置跨域后，组件中的请求地址就不能再带ip和端口了，因为这里设置的跨域处理会默认帮加上的，组件的请求的往本地服务器请求的，如果没有`

`填服务器和端口就默认使用本地的，这样就不会导致跨域，这里会拦截这个请求，并且会加上目标服务器和端口`

## 轮播图插件

![image-20201022231837423](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022231837423.png)

**Swiper配置轮播图属性**

![image-20201022232503077](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022232503077.png)

SwiperItem.vue是装图片的容器

index.js把这两个组件一起导出

接下来就可以在需要的页面使用了

第一步：导入上面的两个插件

```
	import { Swiper, SwiperItem } from 'components/common/swiper/index'
```

```
     components: {
         Swiper,
         SwiperItem,
       },
```

第二步：在<template/>插入下面代码，Swiper负责实现轮播功能，然后SwiperItem负责装内容，比如图片

注意加上v-if='banners.length'这一句

```
	<Swiper v-if="banner.length">
      <SwiperItem v-for="(item, index) in banners" :key="index">
        <a :href="item.link">
          <img :src="item.image" alt="" />
        </a>
      </SwiperItem>
    </Swiper>
```

如果熟练的话还可以再封装一层

![image-20201022234336319](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022234336319.png)

把轮播图封装成一个组件再引进来

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201022234423698.png" alt="image-20201022234423698" style="zoom:80%;" />

Swiper默认会有class="swiper",可以直接用.swiper控制Swiper位置

而且必须加上v-if="banners.length"这一句，否则刷新后轮播图就失效了

![image-20201023002401300](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201023002401300.png)

## Vue源码解析

### 模板引擎

> 模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的[HTML](https://baike.baidu.com/item/HTML/97049)文档。简单来说就是把数据变为视图。

#### **历史出现的数据变为视图的方法**

##### 纯DOM法

> 非常笨拙，没有实战价值，但是非常底层

案例：

```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <ul id="list">
  </ul>
  <script>
    var arr = [
      { "name": "小明", "age": 12, "sex": "男" },
      { "name": "小红", "age": 11, "sex": "女" },
      { "name": "小强", "age": 13, "sex": "男" }
    ];
    var list = document.getElementById('list');
    for (var i = 0; i < arr.length; i++) {
      // 每遍历一项，都要用DOM方法去创建li标签
      let oLi = document.createElement('li');
      // 创建hd这个div
      let hdDiv = document.createElement('div');
      hdDiv.className = 'hd';
      hdDiv.innerText = arr[i].name + '的基本信息';
      // 创建bd这个div
      let bdDiv = document.createElement('div');
      bdDiv.className = 'bd';
      // 创建三个p
      let p1 = document.createElement('p');
      p1.innerText = '姓名：' + arr[i].name;
      bdDiv.appendChild(p1);
      let p2 = document.createElement('p');
      p2.innerText = '年龄：' + arr[i].age;
      bdDiv.appendChild(p2);
      let p3 = document.createElement('p');
      p3.innerText = '性别：' + arr[i].sex;
      bdDiv.appendChild(p3);
      // 创建的节点是孤儿节点，所以必须要上树才能被用户看见
      oLi.appendChild(hdDiv);
      // 创建的节点是孤儿节点，所以必须要上树才能被用户看见
      oLi.appendChild(bdDiv);
      // 创建的节点是孤儿节点，所以必须要上树才能被用户看见
      list.appendChild(oLi);
    }
  </script>
</body>
</html>
```

效果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210209133027028.png" alt="image-20210209133027028" style="zoom:67%;" />

##### 数组join法

> 曾几何时非常流行，是曾经前端必会知识

实例：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <ul id="list"></ul>
  <script>
    var arr = [
      { "name": "小明", "age": 12, "sex": "男" },
      { "name": "小红", "age": 11, "sex": "女" },
      { "name": "小强", "age": 13, "sex": "男" }
    ];
    var list = document.getElementById('list');
    // 遍历arr数组，每遍历一项，就以字符串的视角将HTML字符串添加到list中
    for (let i = 0; i < arr.length; i++) {
      list.innerHTML += [
        '<li>',
        '    <div class="hd">' + arr[i].name + '的信息</div>',
        '    <div class="bd">',
        '        <p>姓名：' + arr[i].name + '</p>',
        '        <p>年龄：' + arr[i].age + '</p>',
        '        <p>性别：' + arr[i].sex + '</p>',
        '    </div>',
        '</li>'
      ].join('')
    }
  </script>
</body>
</html>
```

效果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210209162722775.png" alt="image-20210209162722775" style="zoom:67%;" />

##### ES6的反引号法

实例：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <ul id="list"></ul>
  <script>
    var arr = [
      { "name": "小明", "age": 12, "sex": "男" },
      { "name": "小红", "age": 11, "sex": "女" },
      { "name": "小强", "age": 13, "sex": "男" }
    ];
    var list = document.getElementById('list');
    // 遍历arr数组，每遍历一项，就以字符串的视角将HTML字符串添加到list中
    for (let i = 0; i < arr.length; i++) {
      list.innerHTML += `
                <li>
                    <div class="hd">${arr[i].name}的基本信息</div>    
                    <div class="bd">
                        <p>姓名：${arr[i].name}</p>    
                        <p>性别：${arr[i].sex}</p>    
                        <p>年龄：${arr[i].age}</p>    
                    </div>    
                </li>
            `;
    }
  </script>
</body>
</html>
```

效果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210209163245073.png" alt="image-20210209163245073" style="zoom:67%;" />

#### Mustache模板引擎

在Javascript中 mustache.js是实现mustache模板系统。

Mustache是一种没有逻辑的模板语法。它可以应用于HTML、配置文件、源代码等任何地方。 它通过使用散列或对象中提供的值在模板中展开标记来工作。

我们称它为没有逻辑的模板，是因为它没有if语句、else子句和for循环，它只有标签。一些标签被替换为值或什么也没有或者一系列的值。

不能在模板中使用else if做逻辑判断，我们可以在数据传入之前对数据做逻辑操作。

我们在那使用mustache.js

你可以在任何可以使用JavaScript的地方使用mustache.js来渲染mustache模板。包括web浏览器、服务器环境（node）。

语法

- 模板以包裹住内容，格式中写入的是模板的内容。 被替换的内容字段使用双花括号包裹起来"{{}}"
- 插值表达式：双花括号{{}} 包裹替换的字段
- {{#prop-name}}{{/prop-name}}用作for循环渲染，当prop-name的值为非空数组时，mustach不会遍历该数组，渲染出个数和该数组长度相等的DOM元素
- 也可以用作if-else判断。{{#prop-name}}{{/prop-name}}和{{^prop-name}}{{/prop-name}}两组标签结合使用，当prop-name的值存在且不为false时，会渲染{{#prop-name}}{{/prop-name}}的内容，否则渲染{{^prop-name}}{{/prop-name}}的内容。

##### 基本使用

**基本用法一（不循环）：**

```
     <!DOCTYPE html>
     <html lang="en">
     <head>
         <meta charset="UTF-8">
         <meta name="viewport" content="width=device-width, initial-scale=1.0">
         <title>Document</title>
     </head>
     <body>
         <div id="container"></div>
         <script src="https://cdn.bootcdn.net/ajax/libs/mustache.js/4.1.0/mustache.js"></script>
         <script>
             var templateStr = `
                 <h1>我买了一个{{thing}}，好{{mood}}啊</h1>
               `;
             var data = {
                 thing: '华为手机',
                 mood: '开心'
             };
             var domStr = Mustache.render(templateStr, data);
             var container = document.getElementById('container');
             container.innerHTML = domStr;
         </script>
     </body>
     </html>
```

效果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210209204414202.png" alt="image-20210209204414202" style="zoom:80%;" />

**基本用法二（循环对象数组）：**

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="container"></div>
  <!-- 模板 -->
  <script type="text/template" id="mytemplate">
        <ul>
            {{#arr}}
                <li>
                    <div class="hd">{{name}}的基本信息</div>    
                    <div class="bd">
                        <p>姓名：{{name}}</p>    
                        <p>性别：{{sex}}</p>    
                        <p>年龄：{{age}}</p>    
                    </div>
                </li>
            {{/arr}}
        </ul>
    </script>
  <script src="https://cdn.bootcdn.net/ajax/libs/mustache.js/4.1.0/mustache.js"></script>
  <script>
    var templateStr = document.getElementById('mytemplate').innerHTML;
    var data = {
      arr: [
        { "name": "小明", "age": 12, "sex": "男" },
        { "name": "小红", "age": 11, "sex": "女" },
        { "name": "小强", "age": 13, "sex": "男" }
      ]
    };
    var domStr = Mustache.render(templateStr, data);
    var container = document.getElementById('container');
    container.innerHTML = domStr;
  </script>
</body>

</html>
```

效果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210209204928002.png" alt="image-20210209204928002" style="zoom:80%;" />

注：<script>设置type="text/template"，标签里面的内容不会被执行，也不会显示在页面上，但是可以在另一个script里面通过获取插入到页面中。这样就把大段的HTML操作从js里面分离开了。处理type = "text/javascript"的<sctipt>标签都不会执行，但是可以通过DOM获取该标签，利用innerHTML获取其中的内容。

基本用法三（循环简单数组）：

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div id="container"></div>
    <script src="https://cdn.bootcdn.net/ajax/libs/mustache.js/4.1.0/mustache.js"></script>
    <script>
        var templateStr = `
            <ul>
                {{#arr}}
                    <li>{{.}}</li>    
                {{/arr}}
            </ul>
        `;

        var data = {
            arr: ['A', 'B', 'C']
        };
        var domStr = Mustache.render(templateStr, data);
        var container = document.getElementById('container');
        container.innerHTML = domStr;
    </script>
</body>
</html>
```

效果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210209205455382.png" alt="image-20210209205455382"  />

注：我们注意到上面代码render的第二个参数都是一个对象，第二个参数我们通常都会使用对象类型，传入一个对象，在模板中书写对象属性，可以渲染出对象的值。 但也可以是其它类型如 数组、字符串类型、数字，如果第二个参数是其它类型，那么在模板中双花括号内就用点 `.` 来表示，使用起来不方便。 一般在项目中很少会传入其它类型。

基本用法四（数组的嵌套使用）：

实例：

```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="container"></div>
  <script src="https://cdn.bootcdn.net/ajax/libs/mustache.js/4.1.0/mustache.js"></script>
  <script>
    var templateStr = `
            <ul>
                {{#arr}}
                    <li>
                        {{name}}的爱好是：
                        <ol>
                            {{#hobbies}} 
                                <li>{{.}}</li>
                            {{/hobbies}} 
                        </ol>
                    </li>    
                {{/arr}}
            </ul>
        `;
    var data = {
      arr: [
        { 'name': '小明', 'age': 12, 'hobbies': ['游泳', '羽毛球'] },
        { 'name': '小红', 'age': 11, 'hobbies': ['编程', '写作文', '看报纸'] },
        { 'name': '小强', 'age': 13, 'hobbies': ['打台球'] },
      ]
    };
    var domStr = Mustache.render(templateStr, data);
    var container = document.getElementById('container');
    container.innerHTML = domStr;
  </script>
</body>
</html>
```

效果：

![image-20210209205959811](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210209205959811.png)



基本用法五（if-else):

```
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="container"></div>
  <script src="jslib/mustache.js"></script>
  <script>
    var templateStr = `
            {{#m}}
                <h1>你好</h1>
            {{/m}}
            {{^m}}
                <h1>好你</h1>
            {{/m}}
        `;
    var data = {
      m: false
    };
    var domStr = Mustache.render(templateStr, data);
    var container = document.getElementById('container');
    container.innerHTML = domStr;
  </script>
</body>
</html>
```

效果：

![image-20210209210057061](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210209210057061.png)

注：也可以用作if-else判断。{{#prop-name}}{{/prop-name}}和{{^prop-name}}{{/prop-name}}两组标签结合使用，当prop-name的值存在且不为false时，会渲染{{#prop-name}}{{/prop-name}}的内容，否则渲染{{^prop-name}}{{/prop-name}}的内容。

##### 实现原理

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210220040236062.png" alt="image-20210220040236062" style="zoom: 50%;" />![image-20210220040353683](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210220040353683.png)

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210220040458359.png" alt="image-20210220040458359" style="zoom:50%;" />![image-20210220040839272](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210220040839272.png)

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210220040458359.png" alt="image-20210220040458359" style="zoom:50%;" /><img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210220040839272.png" alt="image-20210220040839272" />

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210220040839272.png" alt="image-20210220040839272" style="zoom:50%;" />![image-20210220041605723](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210220041605723.png)

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210220041627991.png" alt="image-20210220041627991" style="zoom:50%;" />



# Element-UI

## Element-UI的基本使用

Element-UI：一套为开发者、设计者和产品经理准备的基于Vue2.0的桌面端组件库。

官网地址为：https://element.eleme.cn/2.0/

**1、基于命令行方式手动安装**

1. 安装依赖包 npm i element-ui -S

2. 导入 Element-UI相关资源（不推荐使用）

   ```
   //导入组件库
   import ElementUI from 'element-ui';
   //导入组件相关样式
   import 'element-ui/lib/theme-chalk/index.css';
   //配置Vue插件
   Vue.use(ElementUI);
   ```

**2、命令行按需安装**(推荐使用，系统会自动配置)

​	1、在 命令行输入 vue add element

​	2、How do you want to import Element?选择 Import on demand （关键）按需引入❯ Fully import 全局引入Choose the locale you want to load

​	3、选择 zh-CN

​	4、npm run server

**3、引入组件**

​	访问Element-UI官网

​	找到需要的组件，复制对应的代码

​	<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201015170514261.png" alt="image-20201015170514261" style="zoom:80%;" />

![image-20201015170609887](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201015170609887.png)

把组件代码粘贴在你需要的页面中

效果：

![image-20201015170649633](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201015170649633.png)

## 	自由使用element标签

配置好elementui后，可以在所有模板中使用element标签

例如：

​	<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201017115201718.png" alt="image-20201017115201718" style="zoom: 80%;" />

![image-20201017115225148](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201017115225148.png)

样式可以使用点+标签的形式控制样式

# Ant Design of Vue

## 简介

> 这里是 Ant Design 的 Vue 实现，开发和服务于企业级后台产品。

## 安装

```
 npm i --save ant-design-vue
```

在main.js中引入：

```
import Antd from 'ant-design-vue';
import 'ant-design-vue/dist/antd.css';
Vue.use(Antd);
```

这样就可以在vue项目中任何地方使用了

## 基本使用

```
<template>
  <div id="app">
    <a-button>测试</a-button>//antD按钮组件
  </div>
</template>
<script>
export default {
  name: 'App',
}
</script>
<style>
</style>
```

效果：

![image-20201029214137085](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201029214137085.png)



可以看出，已经成功使用了

## 布局Layout

### Layout布局

1. a-layout

   > 布局容器，其下可嵌套 `Header` `Sider` `Content` `Footer` 或 `Layout` 本身，可以放在任何父容器中。

2. a-layout-header

   > 顶部布局，自带默认样式，其下可嵌套任何元素，只能放在 `Layout` 中。

   垂直布局

3. a-layout-content

   > 内容部分，自带默认样式，其下可嵌套任何元素，只能放在 `Layout` 中。

   垂直布局或水平布局

4. a-layout-sider

   > 侧边栏，自带默认样式及基本功能，其下可嵌套任何元素，只能放在 `Layout` 中。

   水平布局

5. a-layout-footer

   > 底部布局，自带默认样式，其下可嵌套任何元素，只能放在 `Layout` 中。

   垂直布局

### Grid栅格

> 在多数业务情况下，Ant Design Vue 需要在设计区域内解决大量信息收纳的问题，因此在 12 栅格系统的基础上，我们将整个设计建议区域按照 24 等分的原则进行划分。
> 划分之后的信息区块我们称之为『盒子』。建议横向排列的盒子数量最多四个，最少一个。『盒子』在整个屏幕上占比见上图。设计部分基于盒子的单位定制盒子内部的排版规则，以保证视觉层面的舒适感。

**概述**

布局的栅格化系统，我们是基于行（row）和列（col）来定义信息区块的外部框架，以保证页面的每个区域能够稳健地排布起来。下面简单介绍一下它的工作原		理：

- 通过`row`在水平方向建立一组`column`（简写col）

- 你的内容应当放置于`col`内，并且，只有`col`可以作为`row`的直接元素

- 栅格系统中的列是指 1 到 24 的值来表示其跨越的范围。例如，三个等宽的列可以使用 `<a-col :span="8" />` 来创建

- `如果一个row中的col总和超过 24，那么多余的col会作为一个整体另起一行排列`

  **Flex 布局**

  我们的栅格化系统支持 Flex 布局，允许子元素在父节点内的水平对齐方式 - 居左、居中、居右、等宽排列、分散排列。子元素与子元素之间，支持顶部对齐、垂直居中对齐、底部对齐的方式。同时，支持使用 order 来定义元素的排列顺序。
  Flex 布局是基于 24 栅格来定义每一个『盒子』的宽度，但不拘泥于栅格。

**通过getter我们可以控制元素的水平和垂直间隔**

例如：

```
 <a-row :gutter="[10, 60]" type="flex">
      <a-col :span="1">
        <div>Column</div>
      </a-col>
      <a-col :span="1">
        <div>Column</div>
      </a-col>
    </a-row>
    <a-row :gutter="[10, 60]" type="flex">
      <a-col :span="1">
        <div>Column</div>
      </a-col>
      <a-col :span="1">
        <div>Column</div>
      </a-col>
    </a-row>
```

如果getter属性只有一个数字，那么就代表水平方向的间距，单位是px,如果是一个数据，那么就一次控制水平方向和垂直方向的

**使用 `offset` 可以将列向右侧偏。例如，`:offset="4"` 将元素向右侧偏移了 4 个列（column）的宽度。**

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201103093817381.png" alt="image-20201103093817381" style="zoom:80%;" />

```
<template>
  <a-row>
    <a-col :span="8">
      col-8
    </a-col>
    <a-col :span="8" :offset="8">
      col-8
    </a-col>
  </a-row>
  <a-row>
    <a-col :span="6" :offset="6">
      col-6 col-offset-6
    </a-col>
    <a-col :span="6" :offset="6">
      col-6 col-offset-6
    </a-col>
  </a-row>
  <a-row>
    <a-col :span="12" :offset="6">
      col-12 col-offset-6
    </a-col>
  </a-row>
</template>
```

### Space间距

> 设置组件之间的间距。

基本使用

> 通过size属性可以控制组件之间的间距，size可以使用small | middle | large | number,前三个都是默认设定好的，number的单位是px

```
<template>
  <div>
    <a-space size="middle">
      <a-button type="primary">Primary</a-button>
      <a-button>Default</a-button>
      <a-button type="dashed">Dashed</a-button>
      <a-button type="link">Link</a-button>
    </a-space>
  </div>
</template>
<script>
export default {
};
</script>
```



## 数据输入（Data Entry)

### Form表单

> 表单是用来数据采集的容器，也可以视为一个对象。
>
> 表单包含三个部分：表单标签， 表单域， 表单按钮。
>
> 具有数据收集、校验和提交功能的表单，包含复选框、单选框、输入框、下拉选择框等元素。

#### 基本使用

基本结构是：

```
<a-form-model>
    <a-form-model-item label="Activity name">
      <a-input/>
    </a-form-model-item>
    <a-form-model-item">
      <a-button type="primary" @click="onSubmit">
        Create
      </a-button>
    </a-form-model-item>
  </a-form-model>
```

实际案例：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201102204613464.png" alt="image-20201102204613464" style="zoom:80%;" />

```
<template>
  <a-form-model :label-col="labelCol" :wrapper-col="wrapperCol">
    <a-form-model-item label="Activity name">
      <a-input v-model="form.name" />
    </a-form-model-item>
    <a-form-model-item label="Activity zone">
      <a-select v-model="form.region" placeholder="please select your zone">
        <a-select-option value="shanghai">
          Zone one
        </a-select-option>
        <a-select-option value="beijing">
          Zone two
        </a-select-option>
      </a-select>
    </a-form-model-item>
    <a-form-model-item :wrapper-col="{ span: 14, offset: 4 }">
      <a-button type="primary" @click="onSubmit">
        Create
      </a-button>
      <a-button style="margin-left: 10px;">
        Cancel
      </a-button>
    </a-form-model-item>
  </a-form-model>
</template>
<script>
export default {
  data() {
    return {
      labelCol: { span: 4 },
      wrapperCol: { span: 14 },
      form: {
        name: '',
      },
    }
  },
  methods: {
    onSubmit() {
      console.log('submit!', this.form)
    },
  },
}
</script>
```

点击按钮输出：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201102210413999.png" alt="image-20201102210413999" style="zoom: 80%;" />

#### 表单排列方式：

- 水平(Horizontal)排列：标签和表单控件水平排列；（默认）
- 垂直(Vertical)排列：标签和表单控件上下垂直排列；
- 行内(Inline)排列：表单项水平行内排列。

使用：

​	通过在a-form-model标签绑定后layout属性，比如

```
 <a-form-model layout="horizontal"></a-form-model>
```

实际案例：

```
<template>
  <a-form-model :layout="form.layout" :model="form" v-bind="formItemLayout">
    <a-form-model-item label="Form Layout">
      <a-radio-group v-model="form.layout">
        <a-radio-button value="horizontal">
          Horizontal
        </a-radio-button>
        <a-radio-button value="vertical">
          Vertical
        </a-radio-button>
        <a-radio-button value="inline">
          Inline
        </a-radio-button>
      </a-radio-group>
    </a-form-model-item>
    <a-form-model-item label="Field A">
      <a-input v-model="form.fieldA" placeholder="input placeholder" />
    </a-form-model-item>
    <a-form-model-item label="Field B">
      <a-input v-model="form.fieldB" placeholder="input placeholder" />
    </a-form-model-item>
    <a-form-model-item :wrapper-col="buttonItemLayout.wrapperCol">
      <a-button type="primary">
        Submit
      </a-button>
    </a-form-model-item>
  </a-form-model>
</template>
<script>
export default {
  data() {
    return {
      form: {
        layout: 'horizontal',
        fieldA: '',
        fieldB: '',
      },
    };
  },
  computed: {
    formItemLayout() {
      const { layout } = this.form;
      return layout === 'horizontal'
        ? {
            labelCol: { span: 4 },
            wrapperCol: { span: 14 },
          }
        : {};
    },
    buttonItemLayout() {
      const { layout } = this.form;
      return layout === 'horizontal'
        ? {
            wrapperCol: { span: 14, offset: 4 },
          }
        : {};
    },
  },
};
</script>
```

实际效果：

<img src="C:\Users\web\Downloads\chrome-capture (6).gif" alt="chrome-capture (6)" style="zoom:80%;" />

注意：当layout="vertical"时，不能再设定:label={span:4},因为label默认占一行，也就是span:24,这样才能实行垂直排布，但是：warpper-col可以设置，

还有inline布局,可以根据span：24来思考

#### 表单域

> 表单一定会包含表单域，表单域可以是输入控件，标准表单域，标签，下拉菜单，文本域等。

##### a-input(输入框)

> 基本使用：

```
<template>
  <a-input v-model:value="value" placeholder="Basic usage" />
</template>
<script>
export default {
  data() {
    return {
      value: '',
    };
  },
};
</script>
```

效果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201103151047750.png" alt="image-20201103151047750" style="zoom:80%;" />

> 带有搜索按钮的输入框，搜索按钮绑定search事件，`会默认把输入框的value以参数形式传递`，`按回车键也可以触发search`

```
<template>
  <div>
    <a-input-search
      v-model:value="value"
      placeholder="input search text"
      style="width: 200px"
      @search="onSearch"
    />
    <br /><br />
    <a-input-search
      v-model:value="value"
      placeholder="input search text"
      enter-button
      @search="onSearch"
    />
    <br /><br />
    <a-input-search
      v-model:value="value"
      placeholder="input search text"
      enter-button="Search"
      size="large"
      @search="onSearch"
    />
    <br /><br />
    <a-input-search
      v-model:value="value"
      placeholder="input search text"
      size="large"
      @search="onSearch"
    >
      <template v-slot:enterButton>
        <a-button>
          Custom
        </a-button>
      </template>
    </a-input-search>
  </div>
</template>

<script>
export default {
  data() {
    return {
      value: '',
    };
  },
  methods: {
    onSearch(value) {
      console.log('use value', value);
      console.log('or use this.value', this.value);
    },
  },
};
</script>
```

效果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201103154647294.png" alt="image-20201103154647294" style="zoom:80%;" />

##### a-textarea（文本框）

基本使用：

> allowclear属性就是出出现一个按钮，一键清空输入

```
<template>
  <div>
    <div style="margin: 24px 0" />
    <a-textarea
      v-model="value1"
      allowClear
      :value="value1"
      placeholder="Autosize height with minimum and maximum number of lines"
      :autoSize="{ minRows: 2, maxRows: 5 }"
    />
  </div>
</template>
<script>
export default {
  data() {
    return {
      value1: '',
    };
  },
};
</script>
```

效果：

![image-20201103152126505](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201103152126505.png)

##### a-select（下拉框）

基本使用：

> 如果要显示placeholder的内容，那值下拉框的初始值需要设置为undefined

```
<template>
  <div>
    <a-select
      v-model="value"
      :value="value"
      style="width: 120px"
      @change="handleChange"
      placeholder="请选择"
    >
      <a-select-option value="jack">
        Jack
      </a-select-option>
      <a-select-option value="lucy">
        Lucy
      </a-select-option>
      <a-select-option value="disabled" disabled>
        Disabled
      </a-select-option>
      <a-select-option value="Yiminghe">
        yiminghe
      </a-select-option>
    </a-select>
  </div>
</template>
<script>
export default {
  data() {
    return {
      value: undefined,
    }
  },
  methods: {
    handleChange(value) {
      console.log(`selected ${value}`)
    },
  },
}
</script>
```

效果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201103165632844.png" alt="image-20201103165632844" style="zoom:80%;" />

##### a-data-picker（时间选择框）

##### a-switch(开关)

##### Slider（滑动输入条）

##### a-checkbox-group&a-checkbox（多选框）

##### a-radio-group&a-radio（单选框）

### 表单数据校验

> Form 组件提供了表单验证的功能，只需要通过 `rules` 属性传入约定的验证规则，并将 `FormItem` 的 `prop` 属性设置为需校验的字段名即可。
>

实例：

<img src="C:\Users\web\Downloads\chrome-capture (7).gif" alt="chrome-capture (7)" style="zoom:67%;" />

```
<template>
  <!-- ref绑定该表单,model是表单数据对象,,有些函数,比如resetFields所必需的,如果不需要使用这些
       函数可以省略,rules绑定检验规则,v-bind={
        labelCol: { span: 4 },
      }相当于:labelCol:{span:4}
  -->
  <a-form-model ref="ruleForm" :model="ruleForm" :rules="rules" v-bind="layout">
    <!-- has-feedback这个属性会在输入框后面加上一些提示图标
         label指明label名称,autocomplete="on",表示输入框会默认提示你之前的提交记录
         prop是为了让检验规则对应每个输入框
     -->
    <a-form-model-item has-feedback label="Password" prop="pass">
      <a-input v-model="ruleForm.pass" type="password" autocomplete="on" />
    </a-form-model-item>
    <a-form-model-item has-feedback label="Age" prop="age">
      <a-input v-model.number="ruleForm.age" />
    </a-form-model-item>
    <a-form-model-item :wrapper-col="{ span: 14, offset: 4 }">
      <a-button type="primary" @click="submitForm('ruleForm')">
        Submit
      </a-button>
      <a-button style="margin-left: 10px" @click="resetForm('ruleForm')">
        Reset
      </a-button>
    </a-form-model-item>
  </a-form-model>
</template>
<script>
export default {
  data() {
    let checkPending;
    //校验方法，定义在data()函数中，结果付给callback参数返回
    let checkAge = (rule, value, callback) => {
      clearTimeout(checkPending);
      if (!value) {
        return callback(new Error('Please input the age'));
      }
      checkPending = setTimeout(() => {
        if (!Number.isInteger(value)) {
          callback(new Error('Please input digits'));
        } else {
          if (value < 18) {
            callback(new Error('Age must be greater than 18'));
          } else {
            callback();
          }
        }
      }, 1000);
    };
    let validatePass = (rule, value, callback) => {
      if (value === '') {
        callback(new Error('Please input the password'));
      } else {
        if (this.ruleForm.checkPass !== '') {
          this.$refs.ruleForm.validateField('checkPass');
        }
        callback();
      }
    };
    return {
      ruleForm: {
        pass: '',
        age: '18',
      },
      // rules定义的是检验规则，validator跟的是自定义检验方法，方法要定义在data()函数中，trigger表示触发校验的事件
      rules: {
        pass: [{ validator: validatePass, trigger: 'change' }],
        age: [{ validator: checkAge, trigger: 'change' }],
      },
      layout: {
        labelCol: { span: 4 },
        wrapperCol: { span: 14 },
      },
    };
  },
  methods: {
    submitForm(formName) {
      // 如果form表格里面的数据通过检验，valid则为true，否则为false
      this.$refs[formName].validate(valid => {
        if (valid) {
          // alert('submit!');
          console.log(this.ruleForm);
          
        } else {
          console.log('error submit!!');
          return false;
        }
      });
    },
    resetForm(formName) {
      // resetFields函数可以回复绑定给model的数据初始值
      this.$refs[formName].resetFields();
    },
  },
};
</script>
```

**主要思路：创建设定rules规则，并且绑定给form,在利用ref绑定form，由于每个form中自带validate函数，并且参数valid能够根据校验是否通过设为true或false,利用这个我们就能控制数据是否提交**



## 导航Navigation

### 导航菜单Menu

基本结构：

```
     <template>
       <a-menu>
         <a-menu-item>菜单项</a-menu-item>
         <a-sub-menu title="子菜单">
           <a-menu-item>子菜单项</a-menu-item>
         </a-sub-menu>
       </a-menu>
     </template>
```

基本使用：

<img src="C:\Users\web\Downloads\chrome-capture (8).gif" alt="chrome-capture (8)" style="zoom:67%;" />

```
<template>
  <div class="asider">
    <a-layout-sider :collapsible="false">
      <a-menu
        style="width: 100%"
        :inlineCollapsed="false"
        mode="inline"
        :selectedKeys="[this.$route.path]"
        @click="handleClick"
      >
        <a-menu-item-group key="g1">
          <template slot="title">
            <span>用户管理</span>
          </template>
          <a-menu-item key="/createAdmin">
            新建管理员
          </a-menu-item>
          <a-menu-item key="/manage">
            用户列表
          </a-menu-item>
        </a-menu-item-group>
      </a-menu>
    </a-layout-sider>
  </div>
</template>
<script>
export default {
  name: 'sider',
  data() {
    return {
      theme: 'dark',
      current:'2'
    }
  },
  methods: {
    handleClick(e) {
      this.current=e.key
      if (e.key == '/createAdmin' && this.$route.path != '/createAdmin') {
        this.$router.replace('/createAdmin')
      } else if (e.key == '/manage' && this.$route.path != '/manage') {
        this.$router.replace('/manage')
      }
    },
  },
}
</script>
<style scoped>
.asider {
  width: 200px;
  height: 859px;
}
</style>
```

为了实现刷新后菜单选中不会被默认值重改，而是跟随页面，我使用了:selectedKeys="[this.$route.path]"，菜单的key不仅仅可以是数字，还可以是字符串

## 数据展示Data Display

### 表格Table

**基本用法一**

> 用data-source绑定表格要显示的数据，数据格式是数组，包含对象[{},{}],每个对象是一列，然后通过title设置标题，data-index把对应列的数据绑定起来
>
> slot-scope="text, record"，使用这句话可以获取本行数据的信息，record就是本行数据

```
<template>
  <a-table :data-source="data">
    <a-table-column title="创建日期" data-index="creaedate" />
    <a-table-column title="账款单号" data-index="sn"> </a-table-column>
    <a-table-column title="操作">
      <template slot-scope="text, record">
        <span>
          <a @click="deleteBtn(record)">Delete</a>
        </span>
      </template>
    </a-table-column>
  </a-table>
</template>
<script>
const data = [
  {
  //每个数据都需要一个key值，而且必须唯一，key值我们可以手动添加，或者通过rowkey来设定
    key: '1',
    creaedate: '10月1日',
    sn: '123',
  },
  {
    key: '2',
    creaedate: '10月2日',
    sn: '1234',
  },
  {
    key: '3',
    creaedate: '10月2日',
    sn: '12233',
  },
]
export default {
  data() {
    return {
      data,
    }
  },
  methods: {
    deleteBtn(record) {
      for (let index in this.data) {
        if (this.data[index].key == record.key) {
          this.data.splice(index, 1)
        }
      }
    },
  },
}
</script>
```

效果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201103102940273.png" alt="image-20201103102940273" style="zoom:80%;" />

基本用法二(推荐使用）：

> 原理和第一种是一样的，只不过第一种实在template中配置表头，而用法二是通过columns来绑定数据，数据按照一定格式编写，然后再转换成表头，
>
> 表头标题可以通过slots来自定义内容，dataIndex是定义表头的名称，下面data中的数据是按行来渲染的，而且会以属性名和表头的dataIndex来进行匹配，
>
> 而不是依据顺序的，比如我们第一列的表头的dataIndex为'name',那么就会渲染下面data数据中属性名为name的数据项
>
> 这个用法不可以直接在列插入东西，需要 在columns中配置好scopedSlots，然后再用slot=""的形式插入，具体用法看以下代码
>
> slot-scope="text, record"，使用这句话可以获取本行数据的信息，record就是本行数据

```
<template>
	//record代表一整个数据项，rowKey就是在数据项缺少Key属性的时候用以唯一标识每个数据项的,pagination控制是否显示分页器
  <a-table :columns="columns" :data-source="data" :rowKey="record => record.id :pagination="true"">
    <!-- 自定义标题 -->
    <span slot="customTitle"><a-icon type="smile-o" /> Text</span>
    <!-- 自定义表格内容 -->
    <template slot="action" slot-scope="text, record">
      <a href="#">{{ record.name }}</a>
    </template>
  </a-table>
</template>
<script>
const columns = [
  {
    // 这时候title就不能写了，不然会覆盖自定义标题内容
    // title: 'Name',
    dataIndex: 'name',
    //表头插槽，可以自定义表头内容
    slots: { title: 'customTitle' },
  },
  {
    title: 'Age',
    dataIndex: 'age',
  },
  {
    title: 'Action',
    //表格内容插槽
    scopedSlots: { customRender: 'action' },
  },
]
const data = [
  {
    //key: '1',
    id:1,
    name: 'John Brown',
    age: 32,
  },
  {
    //key: '2',
    id:2,
    name: 'Jim Green',
    age: 42,
  },
  {
  	如果数据是从网络请求过来的，没有带有Key值，我们可以添加上key值，或者在定义表格的标签用rowkey来定义（推荐），注意rowkey选取的值必须每个数据项都唯一
    //key: '3',
    id:3
    name: 'Joe Black',
    age: 32,
  },
]
export default {
  data() {
    return {
      data,
      columns,
    }
  },
}
</script>
```

效果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201204103605527.png" alt="image-20201204103605527" style="zoom:67%;" />

# ECharts

## 简介

ECharts是一个使用Javascript实现的开源可视化库，兼容性强，底层依赖矢量图形库ZRender,提供直观，交互丰富，可高度个性化定制的数据可视化图表。

> 官网地址：https://echarts.apache.org/zh/index.html

## ECharts的基本使用

### 普通使用（html)

- 步骤1：引入echarts.js文件

  ```
  <script src="./lib//echarts.min.js"></script>
  ```

- 步骤2：准备一个呈现图表的盒子

  ```
  <div style="width: 600px; height: 400px"></div>
  ```

- 步骤3：初始化echarts实例对象

  ```
   var mCharts = echarts.init(document.querySelector('div'))
  ```

- 步骤4：准备配置项

  ```
   var option = {
          xAxis: {
            type: 'category',
            data: ['小明', '小红', '小王'],
          },
          yAxis: {
            type: 'value',
          },
          series: [
            {
              name: '语文',
              type: 'bar',
              data: [70, 92, 87],
            },
          ],
        }
  ```

- 步骤5：将配置项设置给echarts实例对象

  ```
  mCharts.setOption(option)
  ```

  <img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201113205251133.png" alt="image-20201113205251133" style="zoom:80%;" />

所有代码：

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <!-- 步骤一：引入echarts.js文件 -->
    <script src="./lib//echarts.min.js"></script>
  </head>
  <body>
    <!-- 步骤二：准备一个呈现图表的盒子 -->
    <div style="width: 600px; height: 400px"></div>
    <!-- 步骤3:初始化echarts实例对象 -->
    <!-- 参数为dom，决定图表最终呈现的位置 -->
    <script>
      var mCharts = echarts.init(document.querySelector('div'))
      //步骤4：准备配置项
      var option = {
        title: {
          text: '成绩',//配置表标题
          link: 'http://www.baidu.com',//配置标题链接
        },
        xAxis: {
          type: 'category', //类目轴
          data: ['小明', '小红', '小王'],
        },
        yAxis: {
          type: 'value', //数值轴
        },
        series: [
          {
            name: '语文',
            type: 'bar', //bar代表柱形图，line代表折线图，pie代表饼状图
            data: [70, 92, 87],
          },
        ],
      }
      // 步骤5:将配置项设置给echarts实例对象
      mCharts.setOption(option)
    </script>
  </body>
</html>

```

效果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201113210001155.png" alt="image-20201113210001155" style="zoom:80%;" />



### 在框架使用（vue)

方案一：

- 在public文件夹下的index.html中引入Echarts链接

  ![image-20201119223212567](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201119223212567.png)

  链接代码：

  ```
  <script src="./static/lib/echarts.min.js"></script>
  ```

- 在main.js中全局注册，实际上不注册也可以直接使用(直接使用echarts也行)

  ![image-20201119223435100](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201119223435100.png)

  代码：

  ```
  Vue.prototype.$echarts = window.echarts
  ```

- 在组件中使用：

  1. 第一步定义容器：

     ![image-20201119223845735](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201119223845735.png)

     代码：

     ```
     <template>
       <div class="com-container">
         <div class="com-chart" ref="seller_ref"></div>
       </div>
     </template>
     ```

  2. 初始化echartInstance对象：

     先在data定义该对象echartInstance：null,然后初始化图表

     ```
      initChart () {
      	//初始化图表
           this.chartInstane = this.$echarts.init(this.$refs.trend_ref, 'chalk')
           //图表配置
           let initOption = {
              xAxis: {
               type: 'category',
             },
             yAxis: {
               type: 'value',
             },
             series:[
             	{
     			type:'bar'
     		}
     	   ]
           //应用配置
           this.chartInstane.setOption(initOption)
         },
     ```

     `注意：如果使用百分比，那是相对于容器的宽高`

  3. 获取数据

     代码：（具体问题具体分析）

     ```
     async getData () {
     	//定义X轴数据
           this.allData.xData = ['小明', '小红', '小王'],
           //定义y轴数据
           this.allData.yData =  [70, 92, 87], 
           this.updateChart()
         },
     ```

  4. 更新图表

     代码：

     ```
     updateChart () {
           //图例的数据
           let legendArr = this.allData.yData
           let dataOption = {
             legend: {
               data: legendArr,
             },
             xAxis: {
               data: this.allData.xData,
             },
             series: [
             	{
             		data:this.allData.yData
             	}
             ]
           }
           //重新应用配置
           this.chartInstane.setOption(dataOption)
         },
     ```

  5. 当浏览器的大小发生变化的时候，会调用的方法，来完成屏幕的适配

     代码：

     ```
      screenAdapter () {
           this.titleFontSize = (this.$refs.trend_ref.offsetWidth / 100) * 3.6
           let adapterOption = {
             legend: {
               itemWidth: this.titleFontSize,
               itemHeight: this.titleFontSize,
               textStyle: {
                 fontSize: this.titleFontSize / 2,
               },
             },
           }
           this.chartInstane.setOption(adapterOption)
           this.chartInstane.resize()
         },
     ```

  6. 在mounted中依次调用上述方法：

     代码：

     ```
       mounted () {
       	//初始化图表
         this.initChart()
         //获取数据
         this.getData()
         //自适应
         this.screenAdapter()
         window.addEventListener('resize', this.screenAdapter)
       },
     ```

  7. 效果：

     <img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201113210001155.png" alt="image-20201113210001155" style="zoom:80%;" />

方案二：

1. **安装echarts依赖**

   ```
   npm install echarts -S
   ```

2. **全局引入Echarts**

   ```
   // 引入echarts
   import echarts from 'echarts'
   Vue.prototype.$echarts = echarts
   ```

3. **在组件中使用**

   ```
   <template>
     <div id="app">
       <div id="myChart" :style="{width: '300px', height: '300px'}"></div>
     </div>
   </template>
   <script>
   export default {
     mounted(){
        console.log(document.getElementById('myChart'));
       this.drawLine();
     },
     methods: {
       drawLine(){
           // 基于准备好的dom，初始化echarts实例
           let myChart = this.$echarts.init(document.getElementById('myChart'))
           // 绘制图表
           myChart.setOption({
               title: { text: '在Vue中使用echarts' },
               tooltip: {},
               xAxis: {
                 type: 'category',
                   data: ["衬衫","羊毛衫","雪纺衫","裤子","高跟鞋","袜子"]
               },
               yAxis: {
                 type: 'value'
               },
               series: [{
                   name: '销量',
                   type: 'bar',
                   data: [5, 20, 36, 10, 10, 20]
               }]
           });
       }
     }
   }
   </script>
   ```

   效果图：

   <img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201204143600467.png" alt="image-20201204143600467" style="zoom:80%;" />

   

4. 按需引入，由于全局引入会将所有的echarts图表打包，会导致项目体积过大在

   ```
   // 引入基本模板
   let echarts = require('echarts/lib/echarts')
   // 引入柱状图组件
   require('echarts/lib/chart/bar')
   // 引入提示框和title组件
   require('echarts/lib/component/tooltip')
   require('echarts/lib/component/title')
   ```

   使用 require 而不是 import

   `注意：`由于Echarts需要调用函数来进行注册和配置图表，我们一般加载页面就会初始化图表，如果我们需要从网络中拿到数据，这时候Echarts就无法拿到数据，因为初始化只会在页面第一次加载时配置数据，

   ​		 所以我们必须采取一些方案，让拿到新数据后的echarts重新配置，也就是调用一些函数

   方案一：如果是在同一个组件使用的，比如上方的例子，我们可以在拿到通过网络请求后从新数据后，我们可以在网络请求函数的后面在调用以下myChart.setOption来重新配置echarts,上面的例子就是基于这个

   ​			方案

   方案二：如果我们是把echarts封装在另一个组件中的，比如这样

   ​		![image-20201204144819876](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201204144819876.png)

   我们可以采用v-if的方式，让封装的组件有数据就才初始化，这样就不要重新配置，而且也能拿到最新数据

   方案三：使用watch来进行监听数据的变化，如果数据发生变化，我们重新配置echarts

   ```
   //数据自动刷新，必然需要一个监听机制告诉Echarts重新设置数据
       watch: {
         //观察option的变化
         echarts1_option: {
           handler(newVal, oldVal) {
             if (this.myChart) {
               if (newVal) {
                 this.myChart.setOption(newVal);
               } else {
                 this.myChart.setOption(oldVal);
               }
             } else {
               this.init();
             }
           },
           deep: true //对象内部属性的监听，关键。
         }
       },
   ```

## ECharts常用图表 

### 图表主题 

**内置主题**

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114162205092.png" alt="image-20201114162205092" style="zoom: 67%;" />

**自定义主题 **

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114163903505.png" alt="image-20201114163903505" style="zoom: 67%;" />

实例：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="lib/echarts.min.js"></script>
  <script src="theme/itcast.js"></script>//这是自定义主题
</head>
<body>
  <div style="width: 600px;height:400px"></div>
  <script>
    // 1.在线编辑主题 https://www.echartsjs.com/theme-builder/
    // 2.下载主题的js文件
    // 3.在html中导入js文件
    // 4.在init方法中指明主题的名称
    var mCharts = echarts.init(document.querySelector("div"), 'itcast')
    var xDataArr = ['张三', '李四', '王五', '闰土', '小明', '茅台', '二妞', '大强']
    var yDataArr = [88, 92, 63, 77, 94, 80, 72, 86]
    var option = {
      xAxis: {
        type: 'category',
        data: xDataArr
      },
      yAxis: {
        type: 'value'
      },
      series: [
        {
          type: 'bar',
          data: yDataArr,
          markPoint: {
            data: [
              {
                type: 'max', name: '最大值'
              },
              {
                type: 'min', name: '最小值'
              }
            ]
          },
          markLine: {
            data: [
              {
                type: 'average', name: '平均值'
              }
            ]
          },
          label: {
            show: true,
            rotate: 60
          },
          barWidth: '30%'
        }
      ]
    };
    mCharts.setOption(option)
  </script>
</body>

</html>
```

效果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114164018164.png" alt="image-20201114164018164" style="zoom:67%;" />

### 调色盘

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114172024342.png" alt="image-20201114172024342" style="zoom: 50%;" />

就近原则

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114173908240.png" alt="image-20201114173908240" style="zoom: 67%;" />

也可以使用这样的形式使用：

```
 	itemStyle: {
              barBorderRadius: [0, 33, 33, 0],
              //指明不同百分比之下颜色的值
              color: new this.$echarts.graphic.LinearGradient(0, 0, 1, 0, [
                //百分之0状态之下的颜色值
                {
                  offset: 0,
                  color: '#5052EE',
                },
                //百分之100状态之下的颜色值
                {
                  offset: 1,
                  color: '#AB6EE5',
                },
              ]),
            },
```

### 样式

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114212758267.png" alt="image-20201114212758267" style="zoom: 50%;" />

实例：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="lib/echarts.min.js"></script>
</head>
<body>
  <div style="width: 600px;height:400px"></div>
  <script>
    var mCharts = echarts.init(document.querySelector("div"))
    var option = {
      title: {
        text: '饼图的测试',
        textStyle: { // 控制标题的文字样式
          color: 'blue'
        }
      },
      series: [
        {
          type: 'pie',
          data: [{
            value: 11231,
            name: "淘宝",
            itemStyle: { // 控制淘宝这一区域的样式
              color: 'yellow'
            },
            label: {
              color: 'green'
            },
            emphasis: {
              itemStyle: { // 控制淘宝这一区域的样式
                color: 'pink'
              },
              label: {
                color: 'black'
              }
            }
          },
          {
            value: 22673,
            name: "京东"
          },
          {
            value: 6123,
            name: "唯品会",
          },
          {
            value: 8989,
            name: "1号店"
          },
          {
            value: 6700,
            name: "聚美优品"
          }]
        }
      ]
    }
    mCharts.setOption(option)
  </script>
</body>
</html>
```

效果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114213043780.png" alt="image-20201114213043780" style="zoom:67%;" />

### 图表自适应

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114213719122.png" alt="image-20201114213719122" style="zoom:50%;" />

实例：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="lib/echarts.min.js"></script>
</head>
<body>
  <div style="height:400px;border: 1px solid red"></div>
  <script>
    var mCharts = echarts.init(document.querySelector("div"))
    var xDataArr = ['张三', '李四', '王五', '闰土', '小明', '茅台', '二妞', '大强']
    var yDataArr = [88, 92, 63, 77, 94, 80, 72, 86]
    var option = {
      xAxis: {
        type: 'category',
        data: xDataArr
      },
      yAxis: {
        type: 'value'
      },
      series: [
        {
          type: 'bar',
          data: yDataArr,
          markPoint: {
            data: [
              {
                type: 'max', name: '最大值'
              },
              {
                type: 'min', name: '最小值'
              }
            ]
          },
          markLine: {
            data: [
              {
                type: 'average', name: '平均值'
              }
            ]
          },
          label: {
            show: true,
            rotate: 60
          },
          barWidth: '30%'
        }
      ]
    }
    mCharts.setOption(option)
    // 监听window窗口大小变化的事件
    window.onresize = function(){
      // 调用echarts实例对象的resize方法
      mCharts.resize()
    }
  </script>
</body>
</html>
```

### 动画

#### 加载动画

**ECharts已经内置好了加载数据的动画，我们只需要在合适的时机显示或者隐藏即可**

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114214942580.png" alt="image-20201114214942580" style="zoom:50%;" />

#### 增量动画

实例：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="lib/echarts.min.js"></script>
</head>
<body>
  <div style="width: 600px;height:400px"></div>
  <button id="modify">修改数据</button>
  <button id="add">增加数据</button>
  <script>
    var mCharts = echarts.init(document.querySelector("div"))
    var xDataArr = ['张三', '李四', '王五', '闰土', '小明', '茅台', '二妞', '大强']
    var yDataArr = [88, 92, 63, 77, 94, 80, 72, 86]
    var option = {
      xAxis: {
        type: 'category',
        data: xDataArr
      },
      yAxis: {
        type: 'value'
      },
      series: [
        {
          type: 'bar',
          data: yDataArr,
          markPoint: {
            data: [
              {
                type: 'max', name: '最大值'
              },
              {
                type: 'min', name: '最小值'
              }
            ]
          },
          markLine: {
            data: [
              {
                type: 'average', name: '平均值'
              }
            ]
          },
          label: {
            show: true,
            rotate: 60
          },
          barWidth: '30%'
        }
      ]
    }
    mCharts.setOption(option)
    var btnModify = document.querySelector('#modify')
    btnModify.onclick = function () {
      var newYDataArr = [68, 32, 99, 77, 94, 80, 72, 86]
      // setOption 可以设置多次
      // 新的option 和 旧的option
      // 新旧option的关系并不是相互覆盖的关系, 是相互整合的关系
      // 我们在设置新的option的时候, 只需要考虑到变化的部分就可以
      var option = {
        series: [
          {
            data: newYDataArr
          }
        ]
      }
      mCharts.setOption(option)
    }
    var btnAdd = document.querySelector('#add')
    btnAdd.onclick = function(){
      xDataArr.push('小明')
      yDataArr.push(90)
      var option = {
        xAxis: {
          data: xDataArr
        },
        series: [
          {
            data: yDataArr
          }
        ]
      }
      mCharts.setOption(option)
    }
  </script>
</body>
</html>
```

#### 动画配置

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114221412978.png" alt="image-20201114221412978" style="zoom: 50%;" />

实例：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="lib/echarts.min.js"></script>
</head>
<body>
  <div style="width: 600px;height:400px"></div>
  <script>
    var mCharts = echarts.init(document.querySelector("div"))
    var xDataArr = ['张三', '李四', '王五', '闰土', '小明', '茅台', '二妞', '大强']
    var yDataArr = [88, 92, 63, 77, 94, 80, 72, 86]
    var option = {
      animation: true,  // 控制动画是否开启
      // animationDuration: 7000, // 动画的时长, 它是以毫秒为单位
      animationDuration: function(arg){
        console.log(arg)
        return 2000 * arg
      },
      animationEasing: 'bounceOut', // 缓动动画 linear bounceOut
      animationThreshold: 7, // 动画元素的阈值
      xAxis: {
        type: 'category',
        data: xDataArr
      },
      yAxis: {
        type: 'value'
      },
      series: [
        {
          type: 'bar',
          data: yDataArr,
          markPoint: {
            data: [
              {
                type: 'max', name: '最大值'
              },
              {
                type: 'min', name: '最小值'
              }
            ]
          },
          markLine: {
            data: [
              {
                type: 'average', name: '平均值'
              }
            ]
          },
          label: {
            show: true,
            rotate: 60
          },
          barWidth: '30%'
        }
      ]
    };
    mCharts.setOption(option)
  </script>
</body>
</html>
```

### 全局echarts对象

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201115145708344.png" alt="image-20201115145708344" style="zoom:67%;" />

- **init方法**

  初始化ECharts实例对象

  使用主题

  ```
   var mCharts = echarts.init(document.querySelector("div"),'light')
  ```

- **registerTheme方法**

  注册主题

  ```
   <script src="theme/itcast.js"></script>
      // 1.在线编辑主题 https://www.echartsjs.com/theme-builder/
      // 2.下载主题的js文件
      // 3.在html中导入js文件
      // 4.在init方法中指明主题的名称
   var mCharts = echarts.init(document.querySelector("div"), 'itcast')
  ```

- **registerMap方法**

  <img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114222903944.png" alt="image-20201114222903944" style="zoom:50%;" />

- **connect方法**

  <img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114223207289.png" alt="image-20201114223207289" style="zoom:50%;" />

综合实例：

```
     <!DOCTYPE html>
     <html lang="en">
     <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <meta http-equiv="X-UA-Compatible" content="ie=edge">
       <title>Document</title>
       <script src="lib/echarts.min.js"></script>
       <script src="theme/itcast.js"></script>
       <script src="lib/jquery.min.js"></script>
     </head>
     <body>
       <div style="width: 600px;height:400px;border: 1px solid red"></div>
       <div style="width: 600px;height:400px;border: 1px solid green" id="div1"></div>
       <script>
         var mCharts = echarts.init(document.querySelector("div"), 'itcast')
         var xDataArr = ['张三', '李四', '王五', '闰土', '小明', '茅台', '二妞', '大强']
         var yDataArr = [88, 92, 63, 77, 94, 80, 72, 86]
         var option = {
           toolbox: {
             feature: {
               saveAsImage: {}
             }
           },
           xAxis: {
             type: 'category',
             data: xDataArr
           },
           yAxis: {
             type: 'value'
           },
           series: [
             {
               type: 'bar',
               data: yDataArr,
               markPoint: {
                 data: [
                   {
                     type: 'max', name: '最大值'
                   },
                   {
                     type: 'min', name: '最小值'
                   }
                 ]
               },
               markLine: {
                 data: [
                   {
                     type: 'average', name: '平均值'
                   }
                 ]
               },
               label: {
                 show: true,
                 rotate: 60
               },
               barWidth: '30%'
             }
           ]
         }
         mCharts.setOption(option)
         var mCharts2 = echarts.init(document.querySelector('#div1'))
         $.get('json/map/china.json', function(ret){
           echarts.registerMap('aa', ret)
           var option2 = {
             geo: {
               type: 'map',
               map: 'aa'
             }
           }
           mCharts2.setOption(option2)
           // echarts.connect([mCharts, mCharts2]) // 将柱状图和地图关联起来
         })
       </script>
     </body>
     </html>
```

### echartsInstance对象

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201115145652990.png" alt="image-20201115145652990" style="zoom:67%;" />

- **setOption方法**

  设置或修改图表实例的配置项以及数据

  多次调用setOption方法

  ​	合并新的配置和旧的配置

  ​	增量动画

  ```
   mCharts.setOption(newoption)
  ```

- **resize方法**

  重新计算和绘制图表

  一般和window对象的resize事件结合使用

  ```
  // 监听window窗口大小变化的事件
      window.onresize = function(){
        // console.log('window.onresize...')
        // 调用echarts实例对象的resize方法
        mCharts.resize()
      }
  ```

- on\off方法

  <img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114225604870.png" alt="image-20201114225604870" style="zoom:50%;" />

- **dispatchAction方法**

  触发某些行为

  使用代码模拟用户的行为

- **clear方法**

  清空当前实例，会移除实例中所有的组件和图表

  清空之后可以再次setOption

- **dispose方法**

  销毁实例

  实例：

  ```
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="lib/echarts.min.js"></script>
    <script src="lib/jquery.min.js"></script>
  </head>
  <body>
    <div style="width: 600px;height:400px"></div>
    <button id="btn1">触发行为</button>
    <button id="btn2">clear</button>
    <button id="btn3">setOption</button>
    <button id="btn4">dispose</button>
    <script>
      var mCharts = echarts.init(document.querySelector("div"))
      var pieData = [
        {
          value: 11231,
          name: "淘宝",
        },
        {
          value: 22673,
          name: "京东"
        },
        {
          value: 6123,
          name: "唯品会"
        },
        {
          value: 8989,
          name: "1号店"
        },
        {
          value: 6700,
          name: "聚美优品"
        }
      ]
      var option = {
        legend: {
          data: ['淘宝', '京东', '唯品会', '1号店', '聚美优品']
        },
        tooltip: {
          show: true
        },
        series: [
          {
            type: 'pie',
            data: pieData
          }
        ]
      }
      mCharts.setOption(option)
      mCharts.on('click', function (arg) {
        console.log(arg)
        console.log('click...')
      }) // 对事件进行监听
      mCharts.off('click') // 解绑click的事件
      //对点击legend进行监听
      mCharts.on('legendselectchanged', function (arg) {
        console.log(arg)
        console.log('legendselectchanged')
      })
      $('#btn1').click(function () {
        // 模拟用户的行为
        mCharts.dispatchAction({
          type: 'highlight',
          seriesIndex: 0, // 系列的索引
          dataIndex: 1 // 数据的索引
        })
        mCharts.dispatchAction({
          type: 'showTip',
          seriesIndex: 0,
          dataIndex: 2
        })
      })
      $('#btn2').click(function () {
        // 清空图表的实例
        mCharts.clear()
      })
      $('#btn3').click(function () {
        // 重新设置option
        mCharts.setOption(option)
      })
      $('#btn4').click(function () {
        // 销毁mCharts
        mCharts.dispose()
      })
    </script>
  </body>
  </html>
  ```

### 通用配置

> 通用配置指的就是任何图表都能使用的配置

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201113223752590.png" alt="image-20201113223752590" style="zoom:67%;" />

#### 通用配置title

> 配置图的标题

- **文字样式**

  textStyle

- **标题边框**

  borderWidth、borderColor、borderRadius

- **标题位置**

  left、top、right、bottom

  实际代码：

  ```
  title: {
            text: '成绩展示',
            textStyle: {
              color: 'red',
            },
            borderWidth: 5,
            borderColor: 'blue',
            borderRadius: 5,
            left: 100,
            top: 10,
          },
  ```

  效果：<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201113224609443.png" alt="image-20201113224609443" style="zoom:80%;" />

#### 通用配置tooltip

> 提示框组件，用于配置鼠标滑过或点击图表时的显示框

- 触发类型：trigger

  item、axis

- 触发时机：triggerOn

  mouseover(默认)、click

- 格式化:formatter

  字符串模板、回调函数

  实际代码：

  ```
   tooltip: {
            // trigger: 'item',
            trigger: 'axis',
            triggerOn: 'click',
            // formatter:'{b}的成绩是{c}'
            formatter: function (arg) {
              console.log(arg)
              return arg[0].name + '的分数是：' + arg[0].data
            },
          },
  ```

  效果：

  ![image-20201113231408096](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201113231408096.png)

#### 通用配置toolbox

> ECharts提供的工具栏

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201113235400381.png" alt="image-20201113235400381" style="zoom:50%;" />

实例：

```
 toolbox: {
          feature: {
            saveAsImage: {}, //导出图片
            dataView: {}, //数据视图
            restore: {}, //重置
            dataZoom: {}, //区域缩放
            magicType: {
              type: ['bar', 'line'],
            },//动态图表类型的切换
          },
        },
```

效果：

![image-20201113235439804](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201113235439804.png)

#### 通用配置legend

> 图例，用于筛选系列，需要和series配合使用

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114000553774.png" alt="image-20201114000553774" style="zoom: 50%;" />

实例：

```
  legend: {
          data: ['语文成绩', '数学成绩'],
          left:'5%',
          bottom: '5%',//位置控制
          orient:'vertical',//图例摆放方向
          itemWidth:30,//设置每个图例的宽度
          itemHeight:30,//设置每个图例的高度
           textStyle: {
              fontSize:16   //设置字体大小
           },
           itemGap:20,  //,每个图例之间的间隔大小
        },
```

效果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114000657550.png" alt="image-20201114000657550" style="zoom:67%;" />

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201117225707704.png" alt="image-20201117225707704" style="zoom: 33%;" />

### 直角坐标系中的常用配置

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114123620196.png" alt="image-20201114123620196" style="zoom:50%;" />

- **网格grid**

  <img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114123856154.png" alt="image-20201114123856154" style="zoom:50%;" />

  实例：

  ```
   grid: { // 坐标轴容器
          show: true, // 是否可见
          borderWidth: 10, // 边框的宽度
          borderColor: 'red', // 边框的颜色
          left: 120, // 边框的位置
          top: 120,
          width: 300, // 图的大小
          height: 150
        },
  ```

  效果：

  ![image-20201114123804928](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114123804928.png)

  

- **坐标轴axis**

- <img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114125451089.png" alt="image-20201114125451089" style="zoom:50%;" />

- **区域缩放dataZoom**

   

  

### 柱状图（bar)

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201113223514597.png" alt="image-20201113223514597" style="zoom: 50%;" />

  <img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201113210741206.png" alt="image-20201113210741206" style="zoom: 50%;" />



使用实例：

```
    <!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="./lib/echarts.min.js"></script>
  </head>
  <body>
    <div style="width: 600px; height: 400px"></div>
    <script>
      var mCharts = echarts.init(document.querySelector('div'))
      var xDataArr = ['张三','李四','王五','闰土','小明','茅台','二妞','大强'] // 准备x轴数据
      var yDataArr = [88, 92, 63, 77, 94, 80, 72, 86] // 为x轴每一个元素指明数据
      var option = {
        xAxis: {
          type: 'category',
          data: xDataArr,
        },
        yAxis: {
          type: 'value',
        },
        series: [
          {
            name: '语文成绩',
            type: 'bar',
            //显示最大最小值
            markPoint: {
              data: [
                { type: 'max', name: '最大值' },
                { type: 'min', name: '最小值' },
              ],
            },
            //显示平均值
            markLine: {
              data: [
                {
                  type: 'average',
                  name: '平均值',
                },
              ],
            },
            //柱条数据设置
            label: {
              //是否显示数值
              show: true,
              //数值旋转角度
              rotate: 60,
              //显示位置，默认为inside，柱体中部
              position: 'inside',
            },
            //柱宽度设置
            barWidth:'30%',
            data: yDataArr,
          },
        ],
      }
      mCharts.setOption(option)
    </script>
  </body>
</html>
```

效果图：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201113223231389.png" alt="image-20201113223231389" style="zoom:80%;" />

### 折线图 (line)

> 折线图常用来分析数据随时间的变化趋势

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114001346970.png" alt="image-20201114001346970" style="zoom: 50%;" />![image-20201114004335575](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114004335575.png)

​			<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114112815077.png" alt="image-20201114112815077" style="zoom:50%;" />

实例：

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="./lib/echarts.min.js"></script>
  </head>
  <body>
    <div style="width: 600px; height: 400px"></div>
    <script>
      var mCharts = echarts.init(document.querySelector('div'))
      var xDataArr = ['1月','2月','3月','4月','5月','6月','7月','8月','9月','10月','11月','12月']
      var yDataArr = [3000,2800,900,1000,800,700,1400,1300,900,1000,800,600]
      var option = {
        xAxis: {
          type: 'category',
          data: xDataArr,
           boundaryGap: false, //数值位置
        },
        yAxis: {
          type: 'value',
          scale: true, //缩放
        },
        series: [
          {
            name: '康师傅销量',
            data: yDataArr,
            type: 'line',
            //最大值，最小值
            markPoint: {
              data: [
                {
                  type: 'max',
                },
                {
                  type: 'min',
                },
              ],
            },
            //平均值
            markLine: {
              data: [
                {
                  type: 'average',
                },
              ],
            },
            markArea: {
              data: [
                [{ xAxis: '1月' }, { xAxis: '2月' }],
                [{ xAxis: '5月' }, { xAxis: '8月' }],
              ],
            },
            smooth: true, //线条是否顺滑
            lineStyle: {
              color: 'green',
              type: 'dotted', //solid dotted  dashed
            }, //线条样式
            areaStyle: {
              color: 'pink',
            },
          },
        ],
      }
      mCharts.setOption(option)
    </script>
  </body>
</html>
```

效果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114004646489.png" alt="image-20201114004646489" style="zoom: 80%;" />



### 散点图(scatter)

> 散点图可以帮助我们推断出不同维度数据之间的相关性

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114121331575.png" alt="image-20201114121331575" style="zoom:50%;" />

​    <img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114123052313.png" alt="image-20201114123052313" style="zoom: 50%;" />

实例：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="lib/echarts.min.js"></script>
</head>

<body>
  <div style="width: 600px;height:400px"></div>
  <script>
    //1. ECharts最基本的代码结构
    //2. x轴和y轴数据 二维数组 [ [身高,体重],...   ]
    //3. 将type的值设置为scatter, x轴和y轴的type都是value
         var data=[ { "gender": "male", "height": 171.4, "weight": 70 }, { "gender": "male", "height": 185.4, "weight": 81.8 }, { "gender": "male", "height": 185.4, "weight": 84.1 }, { "gender": "male", "height": 188, "weight": 90.5 }, { "gender": "male", "height": 188, "weight": 91.4 }, { "gender": "male", "height": 182.9, "weight": 89.1 }, { "gender": "male", "height": 176.5, "weight": 85 }, { "gender": "male", "height": 175.3, "weight": 69.1 }, { "gender": "male", "height": 175.3, "weight": 73.6 }, { "gender": "male", "height": 188, "weight": 80.5 }, { "gender": "male", "height": 188, "weight": 82.7 }, { "gender": "male", "height": 175.3, "weight": 86.4 }, { "gender": "male", "height": 170.5, "weight": 67.7 }, { "gender": "male", "height": 179.1, "weight": 92.7 }, { "gender": "male", "height": 177.8, "weight": 93.6 }, { "gender": "male", "height": 175.3, "weight": 70.9 }, { "gender": "male", "height": 182.9, "weight": 75 }, { "gender": "male", "height": 170.8, "weight": 93.2 }, { "gender": "male", "height": 188, "weight": 93.2 }, { "gender": "male", "height": 180.3, "weight": 77.7 }, { "gender": "male", "height": 177.8, "weight": 61.4 }, { "gender": "male", "height": 185.4, "weight": 94.1 }, { "gender": "male", "height": 168.9, "weight": 75 }, { "gender": "male", "height": 185.4, "weight": 83.6 }, { "gender": "male", "height": 180.3, "weight": 85.5 }, { "gender": "male", "height": 174, "weight": 73.9 }, { "gender": "male", "height": 167.6, "weight": 66.8 }, { "gender": "male", "height": 182.9, "weight": 87.3 }, { "gender": "male", "height": 160, "weight": 72.3 }, { "gender": "male", "height": 180.3, "weight": 88.6 }, { "gender": "male", "height": 167.6, "weight": 75.5 }, { "gender": "male", "height": 186.7, "weight": 101.4 }, { "gender": "male", "height": 175.3, "weight": 91.1 }, { "gender": "male", "height": 175.3, "weight": 67.3 }, { "gender": "male", "height": 175.9, "weight": 77.7 }, { "gender": "male", "height": 175.3, "weight": 81.8 }, { "gender": "male", "height": 179.1, "weight": 75.5 }, { "gender": "male", "height": 181.6, "weight": 84.5 }, { "gender": "male", "height": 177.8, "weight": 76.6 }, { "gender": "male", "height": 182.9, "weight": 85 }, { "gender": "male", "height": 177.8, "weight": 102.5 }, { "gender": "male", "height": 184.2, "weight": 77.3 }, { "gender": "male", "height": 179.1, "weight": 71.8 }, { "gender": "male", "height": 176.5, "weight": 87.9 }, { "gender": "male", "height": 188, "weight": 94.3 }, { "gender": "male", "height": 174, "weight": 70.9 }, { "gender": "male", "height": 167.6, "weight": 64.5 }, { "gender": "male", "height": 170.2, "weight": 77.3 }, { "gender": "male", "height": 167.6, "weight": 72.3 }, { "gender": "male", "height": 188, "weight": 87.3 }, { "gender": "male", "height": 174, "weight": 80 }, { "gender": "male", "height": 176.5, "weight": 82.3 }, { "gender": "male", "height": 180.3, "weight": 73.6 }, { "gender": "male", "height": 167.6, "weight": 74.1 }, { "gender": "male", "height": 188, "weight": 85.9 }, { "gender": "male", "height": 180.3, "weight": 73.2 }, { "gender": "male", "height": 167.6, "weight": 76.3 }, { "gender": "male", "height": 183, "weight": 65.9 }, { "gender": "male", "height": 183, "weight": 90.9 }, { "gender": "male", "height": 179.1, "weight": 89.1 }, { "gender": "male", "height": 170.2, "weight": 62.3 }, { "gender": "male", "height": 177.8, "weight": 82.7 }, { "gender": "male", "height": 179.1, "weight": 79.1 }, { "gender": "male", "height": 190.5, "weight": 98.2 }, { "gender": "male", "height": 177.8, "weight": 84.1 }, { "gender": "male", "height": 180.3, "weight": 83.2 }, { "gender": "male", "height": 180.3, "weight": 83.2 }]
    var axisData = []
    //处理数据
    for( var i=0;i<data.length;i++) {
      var height = data[i].height
      var weight = data[i].weight
      var newArr = [height, weight]
      axisData.push(newArr)
    }
    var mCharts = echarts.init(document.querySelector("div"))
    var option = {
      xAxis: {
        type: 'value',
        scale: true  //缩放
      },
      yAxis: {
        type: 'value',
        scale: true  //缩放
      },
      series: [
        {
          type: 'scatter', // 指明图表的类型为散点图
          data: axisData
        }
      ]
    }
    mCharts.setOption(option)
  </script>
</body>
</html>
```

效果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114121331575.png" alt="image-20201114121331575" style="zoom:50%;" />

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114122720672.png" alt="image-20201114122720672" style="zoom:50%;" />

使用实例：

 series: [

​    {

​     // type: 'scatter',

​     type: 'effectScatter', // 指明图表为带涟漪动画的散点图

​     showEffectOn: 'emphasis', // 出现涟漪动画的时机 render emphasis

​     rippleEffect: {

​      scale: 10 // 涟漪动画时, 散点的缩放比例

​     },

​     data: axisData,

​     // symbolSize: 30

​     symbolSize: function (arg) { // 控制散点的大小

​      // console.log(arg)

​      var height = arg[0] / 100

​      var weight = arg[1]

​      // bmi = 体重kg / (身高m*身高m)  大于28,就代表肥胖

​      var bmi = weight / (height * height)

​      if (bmi > 28) {

​       return 20

​      }

​      return 5

​     },

​     itemStyle: { // 控制散点的样式

​      color: function (arg) {

​       // console.log(arg)

​       var height = arg.data[0] / 100

​       var weight = arg.data[1]

​       // bmi = 体重kg / (身高m*身高m)  大于28,就代表肥胖

​       var bmi = weight / (height * height)

​       if (bmi > 28) {

​        return 'red'

​       }

​       return 'green'

​      }

​     }

​    }

   ]

效果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114122822480.png" alt="image-20201114122822480" style="zoom:67%;" />

### 饼图(pie)

> 饼图可以很好地帮助用户快速了解不同分类地数据地占比情况

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114131131748.png" alt="image-20201114131131748" style="zoom:50%;" /> 

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114132957477.png" alt="image-20201114132957477" style="zoom:50%;" />

实例：

```
   <!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
    <script src="lib/echarts.min.js"></script>
  </head>

  <body>
    <div style="width: 600px; height: 400px"></div>
    <script>
      //1. ECharts最基本的代码结构
      //2. 准备数据[{name:???, value:??? },{}]
      //   淘宝: 11231  京东: 22673  唯品会: 6123  1号店: 8989   聚美优品: 6700
      //3. 将type的值设置为pie
      var mCharts = echarts.init(document.querySelector('div'))
      // pieData就是需要设置给饼图的数据, 数组,数组中包含一个又一个的对象, 每一个对象中, 需要有name和value
      var pieData = [{ name: '淘宝',value: 11231,},{ name: '京东',value: 22673,},{name: '唯品会',value: 6123, },{name: '1号店',value: 8989,}]
      var option = {
        series: [
          {
            type: 'pie',
            data: pieData,
            label: {
              // 饼图文字的显示
              show: true, // 显示文字
              //formatter: 'hehe' // 决定文字显示的内容
              formatter: function (arg) {
                // console.log(arg)
                return (
                  arg.name + '平台' + arg.value + '元\n' + arg.percent + '%'
                )
              },
            },
            // radius: 20 // 饼图的半径
            // radius: '20%' // 百分比参照的是宽度和高度中较小的那一部分的一半来进行百分比设置
            // radius: ['50%', '75%'] // 第0个元素代表的是內圆的半径 第1个元素外圆的半径
            //roseType: 'radius', // 南丁格尔图 饼图的每一个区域的半径是不同的
             selectedMode: 'single' // 选中的效果,能够将选中的区域偏离圆点一小段距离
            //selectedMode: 'multiple',
            selectedOffset: 30,
          },
        ],
      }
      mCharts.setOption(option)
    </script>
  </body>
</html>

```

效果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114132344688.png" alt="image-20201114132344688" style="zoom:67%;" />



### 地图(map)

> 地图主要可以帮助我们从宏观的角度快速看出不同地理位置上数据的差异

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114150727166.png" alt="image-20201114150727166" style="zoom:50%;" />

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114152233134.png" alt="image-20201114152233134" style="zoom:50%;" />

实例：

```
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
    <script src="lib/echarts.min.js"></script>
    <script src="lib/jquery.min.js"></script>
  </head>
  <body>
    <div style="width: 600px; height: 400px; border: 1px solid #f00"></div>

    <script>
      //1. ECharts最基本的代码结构
      //2. 准备中国地图的矢量数据
      //3. 使用Ajax获取矢量地图数据
      //4. 在Ajax的回调函数中注册地图矢量数据 echarts.registerMap('chinaMap', 矢量地图数据)
      //5. 配置geo的type为'map', map为'chinaMap'
      var mCharts = echarts.init(document.querySelector('div'))
      $.get('json/map/china.json', function (ret) {
        // ret 就是中国的各个省份的矢量地图数据
        echarts.registerMap('chinaMap', ret)
        var option = {
          geo: {
            type: 'map',
            map: 'chinaMap', // chinaMap需要和registerMap中的第一个参数保持一致
            roam: true, // 设置允许缩放以及拖动的效果
            label: {
              show: true, // 展示标签
            },
            zoom: 1, // 设置初始化的缩放比例
            // center: [87.617733, 43.792818] // 设置地图中心点的坐标
            top:'5%',
            bottom:'5%',
            itemStyle: {
              areaColor: '#2E72BF',//地图背景颜色
              borderColor:'#333'  //不同省份之间边界线的颜色
            }
          },
        }
        mCharts.setOption(option)
      })
    </script>
  </body>
</html>
```

效果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114150914138.png" alt="image-20201114150914138" style="zoom: 80%;" />

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114153807773.png" alt="image-20201114153807773" style="zoom:50%;" />

实例：

```
<script>
      //1. 显示基本的中国地图
      //2. 将空气质量的数据设置给series下的对象
      //3. 将series下的数据和geo关联起来
      //4. 配置visualMap
      var airData = [
        { name: '北京', value: 39.92 },
        { name: '天津', value: 39.13 },
        { name: '上海', value: 31.22 },
        { name: '重庆', value: 66 },
        { name: '河北', value: 147 },
        { name: '河南', value: 113 },
        { name: '云南', value: 25.04 },
        { name: '辽宁', value: 50 },
        { name: '黑龙江', value: 114 },
        { name: '湖南', value: 175 },
        { name: '安徽', value: 117 },
        { name: '山东', value: 92 },
        { name: '新疆', value: 84 },
        { name: '江苏', value: 67 },
        { name: '浙江', value: 84 },
        { name: '江西', value: 96 },
        { name: '湖北', value: 273 },
        { name: '广西', value: 59 },
        { name: '甘肃', value: 99 },
        { name: '山西', value: 39 },
        { name: '内蒙古', value: 58 },
        { name: '陕西', value: 61 },
        { name: '吉林', value: 51 },
        { name: '福建', value: 29 },
        { name: '贵州', value: 71 },
        { name: '广东', value: 38 },
        { name: '青海', value: 57 },
        { name: '西藏', value: 24 },
        { name: '四川', value: 58 },
        { name: '宁夏', value: 52 },
        { name: '海南', value: 54 },
        { name: '台湾', value: 88 },
        { name: '香港', value: 66 },
        { name: '澳门', value: 77 },
        { name: '南海诸岛', value: 55 },
      ]
      var mCharts = echarts.init(document.querySelector('div'))
      $.get('json/map/china.json', function (ret) {
        // ret 就是中国的各个省份的矢量地图数据
        echarts.registerMap('chinaMap', ret)
        var option = {
          geo: {
            type: 'map',
            map: 'chinaMap', // chinaMap需要和registerMap中的第一个参数保持一致
            roam: true, // 设置允许缩放以及拖动的效果
            label: {
              show: true, // 展示标签
            },
          },
          series: [
            {
              data: airData,
              geoIndex: 0, // 将空气质量的数据和第0个geo配置关联在一起
              type: 'map',
            },
          ],
          visualMap: {
            min: 0,
            max: 300,
            inRange: {
              color: ['yellow', 'red'], // 控制颜色渐变的范围
            },
            calculable: true, // 出现滑块
          },
        }
        mCharts.setOption(option)
      })
    </script>
```

效果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114153937576.png" alt="image-20201114153937576" style="zoom:67%;" />

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114154212762.png" alt="image-20201114154212762" style="zoom:50%;" />

实例：

```
<body>
  <div style="width: 600px;height:400px;border: 1px solid #f00"></div>
  <script>
    //1. 给series下增加一个新的对象
    //2. 准备数据散点数据  , 配置给series下的另外一个对象
    //3. 配置series下的新对象的type值为effectScatter
    //4. 指明散点图的坐标系统为geo
    //5. 调整涟漪动画效果
    var airData = [
      { name: '北京', value: 39.92 },
      { name: '天津', value: 39.13 },
      { name: '上海', value: 31.22 },
      { name: '重庆', value: 66 },
      { name: '河北', value: 147 },
      { name: '河南', value: 113 },
      { name: '云南', value: 25.04 },
      { name: '辽宁', value: 50 },
      { name: '黑龙江', value: 114 },
      { name: '湖南', value: 175 },
      { name: '安徽', value: 117 },
      { name: '山东', value: 92 },
      { name: '新疆', value: 84 },
      { name: '江苏', value: 67 },
      { name: '浙江', value: 84 },
      { name: '江西', value: 96 },
      { name: '湖北', value: 273 },
      { name: '广西', value: 59 },
      { name: '甘肃', value: 99 },
      { name: '山西', value: 39 },
      { name: '内蒙古', value: 58 },
      { name: '陕西', value: 61 },
      { name: '吉林', value: 51 },
      { name: '福建', value: 29 },
      { name: '贵州', value: 71 },
      { name: '广东', value: 38 },
      { name: '青海', value: 57 },
      { name: '西藏', value: 24 },
      { name: '四川', value: 58 },
      { name: '宁夏', value: 52 },
      { name: '海南', value: 54 },
      { name: '台湾', value: 88 },
      { name: '香港', value: 66 },
      { name: '澳门', value: 77 },
      { name: '南海诸岛', value: 55 }
    ]
    var scatterData = [
      {
        value: [117.283042, 31.86119]
      }
    ]
    var mCharts = echarts.init(document.querySelector("div"))
    $.get('json/map/china.json', function (ret) {
      // ret 就是中国的各个省份的矢量地图数据
      console.log(ret)
      echarts.registerMap('chinaMap', ret)
      var option = {
        geo: {
          type: 'map',
          map: 'chinaMap', // chinaMap需要和registerMap中的第一个参数保持一致
          roam: true, // 设置允许缩放以及拖动的效果
          label: {
            show: true // 展示标签
          }
        },
        series: [
          {
            data: airData,
            geoIndex: 0, // 将空气质量的数据和第0个geo配置关联在一起
            type: 'map'
          },
          {
            data: scatterData, // 配置散点的坐标数据
            type: 'effectScatter',
            coordinateSystem: 'geo', // 指明散点使用的坐标系统  geo的坐标系统
            rippleEffect: {
              scale: 10 ,// 设置涟漪动画的缩放比例
              brushType:'stroke'//设置涟漪动画的样式
            }
          }
        ],
        visualMap: {
          min: 0,
          max: 300,
          inRange: {
            color: ['white', 'red'] // 控制颜色渐变的范围
          },
          calculable: true // 出现滑块
        }
      }
      mCharts.setOption(option)
    })
  </script>
</body>

```

### 雷达图(ladar)

> 雷达图可以用来分析多个维度的数据与标准数据的对比情况

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114155417444.png" alt="image-20201114155417444" style="zoom:50%;" />

实例：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="lib/echarts.min.js"></script>
</head>

<body>
  <div style="width: 600px;height:400px"></div>
  <script>
    //1. ECharts最基本的代码结构
    //2. 定义各个维度的最大值, 通过radar属性配置
    //   易用性,功能,拍照,跑分,续航, 每个维度的最大值都是100
    //3. 准备产品数据, 设置给series下的data
    //   华为手机1: 80, 90, 80, 82, 90
    //   中兴手机1: 70, 82, 75, 70, 78
    //4. 将type的值设置为radar
    var mCharts = echarts.init(document.querySelector("div"))
    // 各个维度的最大值
    var dataMax = [{name: '易用性',max: 100},{name: '功能',max: 100},{name: '拍照',max: 100},{name: '跑分',max: 100},{name: '续航',max: 100}]
    var option = {
      radar: { 
        indicator: dataMax, // 配置各个维度的最大值
        shape: 'polygon' // 配置雷达图最外层的图形 circle polygon
      },
      series: [
        {
          type: 'radar', // radar 此图表时一个雷达图
          label: { // 设置标签的样式
            show: true // 显示数值
          },
          areaStyle: {}, // 将每一个产品的雷达图形成阴影的面积
          data: [
            {
              name: '华为手机1',
              value: [80, 90, 80, 82, 90]
            },
            {
              name: '中兴手机1',
              value: [70, 82, 75, 70, 78]
            }
          ]
        }
      ]
    }
    mCharts.setOption(option)
  </script>
</body>
</html>
```

### 仪表盘图(gaupe)

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114160237761.png" alt="image-20201114160237761" style="zoom:50%;" />

实例：

```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="lib/echarts.min.js"></script>
</head>
<body>
  <div style="width: 600px;height:400px"></div>
  <script>
    //1. ECharts最基本的代码结构
    //2. 准备数据, 设置给series下的data
    //3. 将type的值设置为gauge
    var mCharts = echarts.init(document.querySelector("div"))
    var option = {
      series: [
        {
          type: 'gauge',
          data: [
            {
              value: 97,
              itemStyle: { // 指针的样式
                color: 'pink' // 指针的颜色
              }
            }, // 每一个对象就代表一个指针
            {
              value: 85,
              itemStyle: {
                color: 'green'
              }
            }
          ],
          min: 50 // min max 控制仪表盘数值范围
        }
      ]
    }
    mCharts.setOption(option)
  </script>
</body>
</html>
```

效果：

<img src="C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201114160458791.png" alt="image-20201114160458791" style="zoom:67%;" />

# Sass

## 简介

Sass 是一个 CSS 预处理器。

Sass 是 CSS 扩展语言，可以帮助我们减少 CSS 重复的代码，节省开发时间。

Sass 完全兼容所有版本的 CSS。

Sass 扩展了 CSS3，增加了规则、变量、混入、选择器、继承、内置函数等等特性。

Sass 生成良好格式化的 CSS 代码，易于组织和维护。

Sass 文件后缀为 **.scss**。

## 在Vue中使用Sass

### 安装环境

```
npm install -D sass-loader node-sass
```

### 基本使用

现在，除了能够 `import 'style.scss'`，我们还可以在 Vue 组件中使用 SCSS：

```
<style lang="scss">
/* 在这里撰写 SCSS */
</style>
```

1. Sass 变量使用 **$** 符号：

   ```
   $myFont: Helvetica, sans-serif;
   $myColor: red;
   $myFontSize: 18px;
   $myWidth: 680px;
   body {
     font-family: $myFont;
     font-size: $myFontSize;
     color: $myColor;
   }
   #container {
     width: $myWidth;
   }
   ```

2. Sass作用域

   Sass 变量的作用域只能在当前的层级上有效果，如下所示 h1 的样式为它内部定义的 green，p 标签则是为 red。

   ```
   $myColor: red;
   h1 {
     $myColor: green;   // 只在 h1 里头有用，局部作用域
     color: $myColor;
   }
   p {
     color: $myColor;
   }
   ```

   将以上代码转换为 CSS 代码，如下所示：

   ```
   h1 {
     color: green;
   }
   p {
     color: red;
   }
   ```

3. Sass嵌套规则与属性（和Less语法一致）

   Sass 代码：

   ```
   nav {
     ul {
       margin: 0;
       padding: 0;
       list-style: none;
     }
     li {
       display: inline-block;
     }
     a {
       display: block;
       padding: 6px 12px;
       text-decoration: none;
     }
   }
   ```

   将以上代码转换为 CSS 代码，如下所示：

   ```
   nav ul {
     margin: 0;
     padding: 0;
     list-style: none;
   }
   nav li {
     display: inline-block;
   }
   nav a {
     display: block;
     padding: 6px 12px;
     text-decoration: none;
   }
   ```

4. Sass嵌套属性

   很多 CSS 属性都有同样的前缀，例如：font-family, font-size 和 font-weight ， text-align, text-transform 和 text-overflow。

   在 Sass 中，我们可以使用嵌套属性来编写它们：

   Sass代码：

   ```
   font: {
     family: Helvetica, sans-serif;
     size: 18px;
     weight: bold;
   }
   text: {
     align: center;
     transform: lowercase;
     overflow: hidden;
   }
   ```

   将以上代码转换为 CSS 代码，如下所示：

   ```
   font-family: Helvetica, sans-serif;
   font-size: 18px;
   font-weight: bold;
   
   text-align: center;
   text-transform: lowercase;
   text-overflow: hidden;
   ```

   

# React

## 简介

> React 是一个用于构建用户界面的 JAVASCRIPT 库。
>
> React 主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。
>
> React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。
>
> React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。

**React 特点**

- **1.声明式设计** −React采用声明范式，可以轻松描述应用。
- **2.高效** −React通过对DOM的模拟，最大限度地减少与DOM的交互。
- **3.灵活** −React可以与已知的库或框架很好地配合。
- **4.JSX** − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。
- **5.组件** − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。
- **6.单向响应的数据流** − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。

## React的基本使用

首先要导入相关js库文件(react.js, react-dom.js, babel.min.js)，要按这个顺序来导入

第一个实例：

```
     <!DOCTYPE html>
     <html lang="en">
       <head>
         <meta charset="UTF-8" />
         <meta name="viewport" content="width=device-width, initial-scale=1.0" />
         <title>Helloworld</title>
       </head>
       <body>
         <!-- 准备好一个容器 -->
         <div id="test"></div>
         <!-- 引入react核心库 -->
         <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
         <!-- 引入react-dom 用于支持react操作dom -->
         <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
         <!-- 引入babel 用于将jsx转为js -->
         <script src="https://unpkg.com/babel-standalone@6.15.0/babel.min.js"></script>
         <!-- 此处的type一定要写成text/babel -->
         <script type="text/babel">
           //1、创建虚拟dom元素对象
           var vDOM = <h1>Hello React</h1> //此处一定不要写引号，因为不是字符串
           //2、将虚拟DOM渲染到页面真实DOM容器中
           // ReactDOM.render(vDOM,document.getElementById("test"))
         </script>
       </body>
     </html>
```

![image-20210202231228310](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20210202231228310.png)

###  JSX的理解和使用

1). 理解
			全称: JavaScript XML
			react定义的一种类似于XML的JS扩展语法: XML+JS
			作用: 用来创建react虚拟DOM(元素)对象

2). 编码相关
	* js中直接可以套标签, 但标签要套js需要放在{}中
	* 在解析显示js数组时, 会自动遍历显示
	* 把数据的数组转换为标签的数组: 
		var liArr = dataArr.map(function(item, index){
			return <li key={index}>{item}</li>
	* }

jsx语法规则：
					1.定义虚拟DOM时，不要写引号。
					2.标签中混入JS表达式时要用{}。
					3.样式的类名指定不要用class，要用className。
					4.内联样式，要用style={{key:value}}的形式去写。
					5.只有一个根标签
					6.标签必须闭合
					7.标签首字母
							(1).若小写字母开头，则将该标签转为html中同名元素，若html中无该标签对应的同名元素，则报错。
							(2).若大写字母开头，react就去渲染对应的组件，若组件没有定义，则报错。

### 1.4. 几个重要概念理解

### 模块与组件

1. 模块:

  	     理解: 向外提供特定功能的js程序, 一般就是一个js文件
  	     为什么: js代码更多更复杂
  	     作用: 复用js, 简化js的编写, 提高js运行效率
2. 组件: 
	理解: 用来实现特定功能效果的代码集合(html/css/js)

  	     为什么: 一个界面的功能太复杂了
  	     作用: 复用编码, 简化项目界面编码, 提高运行效率
### 模块化与组件化

         1. 模块化:
              当应用的js都以模块来编写的, 这个应用就是一个模块化的应用
         2. 组件化:
              当应用是以多组件的方式实现功能, 这上应用就是一个组件化的应用


## react组件化开发

### 基本理解和使用

1). 自定义的标签: 组件类(函数)/标签
	  2). 创建组件类

 **方式1: 无状态函数(简单组件, 推荐使用)**

```
 	function MyComponent1(props) {
    		 return <h1>自定义组件标题11111</h1>
     }
```

  实例：

```
     <!DOCTYPE html>
     <html lang="en">
     <head>
       <meta charset="UTF-8" />
       <meta name="viewport" content="width=device-width, initial-scale=1.0" />
       <title>Helloworld</title>
     </head>
     <body>
       <!-- 准备好一个容器 -->
       <div id="test"></div>
       <!-- 引入react核心库 -->
       <script src="../commonjs/react.development.js"></script>
       <!-- 引入react-dom 用于支持react操作dom -->
       <script src="../commonjs/react-dom.development.js"></script>
       <!-- 引入babel 用于将jsx转为js -->
       <script src="../commonjs/babel.min.js"></script>
       <!-- 此处的type一定要写成text/babel -->
       <script type="text/babel">
         //1、创建函数式组件
         function MyComponent() {
           return <h2>我是用函数定义的组件（适用于【简单组件】的定义</h2>
         }
         //2、渲染组件到页面中
         ReactDOM.render(<MyComponent/>, document.getElementById("test"))
         // 执行了ReactDOM.render(<MyComponent/>)......之后，发生了什么？
         //     1、React解析组件标签，找到了MyCommonent组件
         //     2、发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM,随后呈现在页面中
       </script>
     </body>
     </html>
```

**方式2: ES6类语法(复杂组件, 推荐使用)**

```
     class MyComponent3 extends React.Component {
    		 render () {
    			 return <h1>自定义组件标题33333</h1>
     	}
     }
```

实例：

```
     <!DOCTYPE html>
     <html lang="en">
     <head>
       <meta charset="UTF-8" />
       <meta name="viewport" content="width=device-width, initial-scale=1.0" />
       <title>Helloworld</title>
     </head>
     <body>
       <!-- 准备好一个容器 -->
       <div id="test"></div>
       <!-- 引入react核心库 -->
       <script src="../commonjs/react.development.js"></script>
       <!-- 引入react-dom 用于支持react操作dom -->
       <script src="../commonjs/react-dom.development.js"></script>
       <!-- 引入babel 用于将jsx转为js -->
       <script src="../commonjs/babel.min.js"></script>
       <!-- 此处的type一定要写成text/babel -->
       <script type="text/babel">
         //1、创建类式组件
         class MyComponent extends React.Component {
           render() {
             //render是放在哪里的？ -MyComponent的原型对象上，供实例使用
             //render中的this是谁？ -MyComponent的实例对象
             console.log('render中的this:',this);
             return <h2>我是用类定义的组件（适用于【复杂组件】的定义</h2>
           }
         }
         //2、渲染组件到页面中
         ReactDOM.render(<MyComponent />, document.getElementById("test"))
         // 执行了ReactDOM.render(<MyComponent/>)......之后，发生了什么？
         //     1、React解析组件标签，找到了MyCommonent组件
         //     2、发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM,随后呈现在页面中
       </script>
     </body>
     </html>
```

### 组件的3大属性

#### state

> state是组件对象最重要的属性，值是对象(可以包含多个key-value的组合)

1. 组件被称为"状态机", 页面的显示是根据组件的state属性的数据来显示
2. 初始化指定:
    constructor() {
      super()
      this.state = {
        stateName1 : stateValue1,
        stateName2 : stateValue2
      }
    }
3. 读取显示: 
    this.state.stateName1
4. 更新状态-->更新界面 : 
    this.setState({stateName1 : newValue})

```
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>state</title>
</head>
<body>
	<!-- 准备好一个“容器” -->
	<div id="test"></div>
	<!-- 引入react核心库 -->
	<script type="text/javascript" src="../commonjs/react.development.js"></script>
	<!-- 引入react-dom，用于支持react操作DOM -->
	<script type="text/javascript" src="../commonjs/react-dom.development.js"></script>
	<!-- 引入babel，用于将jsx转为js -->
	<script type="text/javascript" src="../commonjs/babel.min.js"></script>
	<script type="text/babel">
		//1.创建组件
		class Weather extends React.Component{
			//构造器调用几次？ ———— 1次
			constructor(props){
				console.log('constructor');
				super(props)
				//初始化状态
				this.state = {isHot:false,wind:'微风'}
				//解决changeWeather中this指向问题
				this.changeWeather = this.changeWeather.bind(this)
			}

			//render调用几次？ ———— 1+n次 1是初始化的那次 n是状态更新的次数
			render(){
				console.log('render');
				//读取状态
				const {isHot,wind} = this.state
				return <h1 onClick={this.changeWeather}>今天天气很{isHot ? '炎热' : '凉爽'}，{wind}</h1>
			}

			//changeWeather调用几次？ ———— 点几次调几次
			changeWeather(){
				//changeWeather放在哪里？ ———— Weather的原型对象上，供实例使用
				//由于changeWeather是作为onClick的回调，所以不是通过实例调用的，是直接调用
				//类中的方法默认开启了局部的严格模式，所以changeWeather中的this为undefined
				
				console.log('changeWeather');
				//获取原来的isHot值
				const isHot = this.state.isHot
				//严重注意：状态必须通过setState进行更新,且更新是一种合并，不是替换。
				this.setState({isHot:!isHot})
				console.log(this.state.isHot);

				//严重注意：状态(state)不可直接更改，下面这行就是直接更改！！！
				//this.state.isHot = !isHot //这是错误的写法
			}
		}
		//2.渲染组件到页面
		ReactDOM.render(<Weather/>,document.getElementById('test'))		
	</script>
</body>
</html>
```

ES6简化版

```
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>state简写方式</title>
</head>
<body>
	<!-- 准备好一个“容器” -->
	<div id="test"></div>
	<!-- 引入react核心库 -->
	<script type="text/javascript" src="../js/react.development.js"></script>
	<!-- 引入react-dom，用于支持react操作DOM -->
	<script type="text/javascript" src="../js/react-dom.development.js"></script>
	<!-- 引入babel，用于将jsx转为js -->
	<script type="text/javascript" src="../js/babel.min.js"></script>
	<script type="text/babel">
		//1.创建组件
		class Weather extends React.Component{
			//初始化状态
			state = {isHot:false,wind:'微风'}
			render(){
				const {isHot,wind} = this.state
				return <h1 onClick={this.changeWeather}>今天天气很{isHot ? '炎热' : '凉爽'}，{wind}</h1>
			}

			//自定义方法————要用赋值语句的形式+箭头函数
			changeWeather = ()=>{
				const isHot = this.state.isHot
				this.setState({isHot:!isHot})
			}
		}
		//2.渲染组件到页面
		ReactDOM.render(<Weather/>,document.getElementById('test'))	
	</script>
</body>
</html>
```



#### props

所有组件标签的属性的集合对象
给标签指定属性, 保存外部数据(可能是一个function)
在组件内部读取属性: this.props.propertyName
作用: 从目标组件外部向组件内部传递数据
对props中的属性值进行类型限制和必要性限制
	Person.propTypes = {
		name: React.PropTypes.string.isRequired,
		age: React.PropTypes.number.isRequired
	}
扩展属性: 将对象的所有属性通过props传递
    <Person {...person}/>

#### refs

	组件内包含ref属性的标签元素的集合对象
	给操作目标标签指定ref属性, 打一个标识
	在组件内部获得标签对象: this.refs.refName(只是得到了标签元素对象)
	作用: 找到组件内部的真实dom元素对象, 进而操作它

### 2.3. 组件中的事件处理

	1. 给标签添加属性: onXxx={this.eventHandler}
	2. 在组件中添加事件处理方法
	    eventHandler(event) {
	                
	    }
	3. 使自定义方法中的this为组件对象
	  	在constructor()中bind(this)
	  	使用箭头函数定义方法(ES6模块化编码时才能使用)
	4. 事件监听
		绑定事件监听
			事件名
			回调函数
		触发事件
			用户对对应的界面做对应的操作
			编码

### 2.4. 组件的组合使用

	1)拆分组件: 拆分界面,抽取组件
	2)实现静态组件: 使用组件实现静态页面效果
	3)实现动态组件
		①　动态显示初始化数据
		②　交互功能(从绑定事件监听开始)

### 2.5. 组件收集表单数据

	受控组件
	非受控组件

### 2.6. 组件的生命周期

	1. 组件的三个生命周期状态:
		Mount：插入真实 DOM
		Update：被重新渲染
		Unmount：被移出真实 DOM
	2. 生命周期流程:
		* 第一次初始化显示: ReactDOM.render(<Xxx/>, containDom)
			constructor()
			componentWillMount() : 将要插入回调
			render() : 用于插入虚拟DOM回调
			componentDidMount() : 已经插入回调
		* 每次更新state: this.setState({})
		    componentWillReceiveProps(): 接收父组件新的属性
		    componentWillUpdate() : 将要更新回调
		    render() : 更新(重新渲染)
		    componentDidUpdate() : 已经更新回调
		* 删除组件: ReactDOM.unmountComponentAtNode(div): 移除组件
			componentWillUnmount() : 组件将要被移除回调
	3. 常用的方法
		render(): 必须重写, 返回一个自定义的虚拟DOM
	  	constructor(): 初始化状态, 绑定this(可以箭头函数代替)
	  	componentDidMount() : 只执行一次, 已经在dom树中, 适合启动/设置一些监听

![组件生命周期](http://i.imgur.com/h5khD9F.png)


### 2.7. 虚拟DOM与DOM diff算法

### 1). 虚拟DOM是什么?

	一个虚拟DOM(元素)是一个一般的js对象, 准确的说是一个对象树(倒立的)
	虚拟DOM保存了真实DOM的层次关系和一些基本属性，与真实DOM一一对应
	如果只是更新虚拟DOM, 页面是不会重绘的

### 2). Virtual DOM 算法的基本步骤

	用JS对象树表示DOM树的结构；然后用这个树构建一个真正的DOM树插到文档当中
	当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异
	把差异应用到真实DOM树上，视图就更新了

### 3). 进一步理解

    Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。
    可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。

![](http://i.imgur.com/psaZdqN.png)


## 2.8. 命令式编程与声明式编程

声明式编程
	只关注做什么, 而不关注怎么做(流程),  类似于填空题
命令式编程
	要关注做什么和怎么做(流程), 类似于问答题

var arr = [1, 3, 5, 7]
// 需求: 得到一个新的数组, 数组中每个元素都比arr中对应的元素大10: [11, 13, 15, 17]
// 命令式编程
var arr2 = []
for(var i =0;i<arr.length;i++) {
	arr2.push(arr[i]+10)
}
console.log(arr2)
// 声明式编程
var arr3 = arr.map(function(item){
	return item +10
})
// 声明式编程是建立命令式编程的基础上

// 数组中常见声明式方法
	map() / forEach() / find() / findIndex()



# WebSocket

## 简介

WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。

WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。

在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。

现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。

HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。

## 基本使用

客户端：

​		普通使用：

​		**Vue中使用：**

​		**下载插件socket.io-client:**

```
		npm install socket.io-client  //推荐3.0.3版本
```

​		**在main.js中注册**

```
		import { io } from 'socket.io-client'
		//设置io连接配置，并且连接
         	const socket = io('http://localhost:5000',
            {	
            	//禁止默认自动断开重连
              reconnection:false
            }
          );
          //把socket对象与Vue的原型绑定，这样就可以在其他组件引用了
   		Vue.prototype.$socket = socket
```

​		**在其他组件就可以使用了：**

```
		//发送事件
		  this.$socket.emit('login', this.msgRecords)
		//接收消息
		  this.sockets.on('broadcast', (data) => {
      		console.log(data)
          })
```

**服务器端：**

​	**服务器端使用，下载socket.io这个插件（当然也有其他插件）**

```
	npm i --save socket.io@3.0.3
```

**服务器使用最基本代码：**

```
     var app = require('express')()
     var http = require('http').Server(app)
    	var io = require('socket.io')(http, {
    	//由于socket.io使用的并不是ws协议，而是经过一些处理的，所以默认不允许跨域，需要以下配置来允许跨域
       cors: {
         origin: "*",
         methods: ["GET", "POST"]
       }
     })
     io.on('connection', function (socket) {
      console.log('连接成功')
     })
     http.listen(5000, function () {
       console.log('listening on *:5000')
     })
```

**进阶功能：**

**监听连接成功：**

```
     //连接成功
     io.on('connect', function (socket) {
         console.log(‘连接成功')
       })
```

`这里的参数socket是当前连接成功的网络连接`

**发送消息：**

```
     io.on('connect', function (socket) {
     //sendevent是发送的事件，第二参数是数据，客户端对应要监听该事件才能接收该数据
         socket.emit('sendevent', '发送数据')
         console.log('成功注册了' + data)
       })
```

因为这里是使用socket.on，所以只会发送给这个刚连接成功的连接（socket是一个网络连接)

**接收消息：**

```
      socket.on('chat', function (data) {
         console.log(data)   //data就是接收的数据
         })
```

**广播信息：**

```
      // 对除当前socket连接的其他所有socket连接发消息
       function broadcastExceptSelf(socket) {
         console.log('广播')
         socket.broadcast.emit('broadcast', '广播消息')//broadcast广播事件，客户端按普通的监听该事件就行了，
       }
```

广播实际上就是每个socket都单播的实现

# Git

## 第一章：快速入门

### 什么是Git

Git是一个分布式的版本控制软件。

- 软件，类似于QQ、office、dota等安装到电脑上才能使用的工具。
- 版本控制，类似于毕业论文、写文案、视频剪辑等，需要反复修改和保留原历史数据。
- 分布式
  - 文件夹拷贝
  - 本地版本控制
  - 集中式版本控制
  - 分布式版本控制

### 为什么要做版本控制

因为在很多情况下，我们无论是写论文，写文档，写程序，写网页都几乎不可能是一次性完成的，都要进行多次修改，甚至多个版本，各种改进，试想一下你写做PPT没有ctrl+z这些撤销修改的功能会有多恶心。写文档需要office，写程序和网页也必须得有我们专属的工具啦，它的功能非常强大，而且非常有必要，可以通过几行代码就把你的代码分享出去，几行代码就把别人的代码克隆下来。

### 安装

1. 浏览器输入：https://git-scm.com/download，根据自己电脑系统下载相应的安装包，

2. 点击下载好的安装包安装这个软件

   ![在这里插入图片描述](https://img-blog.csdn.net/20181012192902122?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncXFkeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

3. 一直点击next，直到出现install，点击install，安装完成后点击finish：

   ![在这里插入图片描述](https://img-blog.csdn.net/20181012194134259?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncXFkeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

4. 安装好后在桌面界面点击鼠标右键，会出现如下界面

   ![在这里插入图片描述](https://img-blog.csdn.net/20181012194653451?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncXFkeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

5. 检查git是否安装OK

   ​	![在这里插入图片描述](https://img-blog.csdn.net/20181012195409372?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1YW5ncXFkeQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

   弹出上图所示界面就说明安装成功啦！！

### 环境配置

### 基本命令

想让git对一个目录进行版本控制需要以下步骤：

1. 进入要管理的文件夹

2. 执行初始化命令

   ```
   git init
   ```

3. 管理目录下的文件状态

   ```
   git status
   注：新增的文件和修改过后的文件都是红色
   ```

4. 管理指定文件

   ```
   注：添加单个文件
   git add 文件名
   注：添加所有文件
   git add .
   ```

5. 个人信息配置：用户名、邮箱【一次即可】

   ```
   git config --global user.eamil 'you@example.com'
   git config --global user.name 'youname'
   ```

6. 生成版本

   ```
   git commit -m '描述信息'
   ```

7. 查看版本记录

   ```
   git log
   ```

8. 回滚至之前的版本

   ```
   git log
   git reset --hard 版本号
   ```

9. 回滚至之后的版本

   ```
   git reflog
   git reset --hard 版本号
   ```

**小总结：**

```
     git init
     git add
     git commit
     git log
     git reflog
     git reset -hard 版本号
```

![image-20201014165041112](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201014165041112.png)

补充：git checkout

作用：假如你修改了代码，但是并没有git add，如果你想取消这部分修改，可以使用git checkout查看修改的文件

​		git checkout 也有切换分支的功能

![image-20201014165247276](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201014165247276.png)

之后在git checkout -- src/App.vue     

`注意：--两边都是有一个空格的`

如果想把所有修改过的文件都还原，使用git checkout .

## 第二章：分支开发

### 分支

分支可以给使用者提供多个环境开发，意味着尼刻意把你的工作从开发主线上分离开来，以免避免影响开发主线，最后合并就好了。

![image-20201014171605808](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201014171605808.png)

### 命令

- 查看分支

  ```
  git branch
  ```

- 创建分支

  ```
  git branch 分支名称
  ```

- 切换分支

  ```
  git checkout 分支名称
  ```

- 分支合并（可能产生冲突）

  ```
  git merge 要合并的分支
  注意：切换分支再合并
  ```

- 删除分支

  ```
  git branch -d分支名称
  ```

大概流程：

![image-20201014175020882](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201014175020882.png)

## 线上协作

### 案例演示

**工作环境**

![image-20201014181018451](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201014181018451.png)



1. 首先，注册github账号，并创建远程仓库，然后再执行命令，将代码上传到github.

![image-20201014180652406](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201014180652406.png)

```
	1、给远程仓库起别名
		git remote add origin 远程仓库地址
	2、向远程推送代码
		git push -u origin 分支
```

2、初次再公司新电脑

```
	1、克隆远程仓库代码
		git clone 远程仓库地址（内部已经git remote add origin远程仓库地址）
	2、向远程推送代码
		git push -u origin 分支
```

在公司下载完代码后，继续开发

```
	1、切换到dev分支进行开发
		git checkout dev
	2、把master分支合并到dev[仅一次]
		git merge master
	3、修改代码
	4、提交代码
		git add .
		git commit -m 'xx'
		git push origin dev
```

下班后回到家继续写代码

```
	1、切换到dev分支进行开发
		git checkout dev
	2、拉代码
		git merge master
	3、继续开发
	4、提交代码
		git add .
		git commit -m 'xxx'
		git push origin dev
```

到公司继续开发

```
	1、切换到dev分支进行开发
		git checkout dev
	2、拉最新代码（不必再clone,只需要通过pull获取最新代码即可）
		git merge master
	3、继续开发
	4、提交代码
		git add .
		git commit -m 'xxxx'
		git push origin dev
```

开发完毕，上线

```
	1、将dev分支合并到master，进行上线
		git checkout master
		git merge dev
		git push origin master
	2、把dev分支也推送到远程
		git checkout dev
		git merge master
		git push origin dev
```

在公司约妹子忘记提交代码

```
	1、拉代码
		git pull origin dev
	2、继续开发
		
	3、提交代码
		git add .
		git commit -m 'xxxxx'
	注：忘记push了
```

回家继续写代码

```
	1、代码，发现在公司写的代码忘记提交了。。。
		git pull origin dev
	2、继续开发其他功能
	3、把dev分支也推送到远程
		git add .
		git commit -m 'xx'
		git push origin dev
```

到公司继续写代码

```
	1、拉代码，把晚上在家写的代码拉到本地（有合并、可能产生冲突）
		git pull origin dev
	2、如果有冲突，手动解决冲突
	3、继续开发其他功能
	4、把dev分支推送到远程
		git add .
		git commit -m 'xx'
		git push origin dev
```

其他命令

```
	git pull origin dev
	等价于
	git fetch origin dev
	git merge origin/dev
```

![image-20201014183130914](C:\Users\web\AppData\Roaming\Typora\typora-user-images\image-20201014183130914.png)

记录图形展示

```
	git log --graph 
```



### rebase

rebase的作用？s

