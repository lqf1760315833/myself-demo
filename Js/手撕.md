### 1. Promise

```javascript
Class Promise {
    constructor(executor) {
        this.status = 'pending'
        this.value = undefined
        this.reason = undefined
        this.onResolvedCallbacks = []
        this.onRejectedCallbacks = []
       	let resolve = value => {
       	    if(this.status === 'pending') {
      	        this.status = 'fulfilled'
     	        this.value = value
            	this.onResolvedCallbacks.forEach(fn=>fn())
   	        }
       	}
       	let reject = reason => {
       	    if(this.status === 'pending') {
       	        this.status = 'rejected'
       	        this.reason = reason
                this.onRejectedCallbacks.forEach(fn=>fn())
       	    }
       	}
    }
    try {
        executor(resolve, reject)
    } catch(err) {
        reject(err)
    }
}
then(onFulfilled, onRejected) {
    // 防止值穿透，加 return
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : val => val
    onRejected = typeof onRejected === 'function' ? onRejected : err => {throw err}
    
    // 简易版本
    if (this.state === 'fulfilled') {
      onFulfilled(this.value);
    };
    if (this.state === 'rejected') {
      onRejected(this.reason);
    };
    // 当状态state为pending时
    if (this.state === 'pending') {
      // onFulfilled传入到成功数组
      this.onResolvedCallbacks.push(()=>{
        onFulfilled(this.value);
      })
      // onRejected传入到失败数组
      this.onRejectedCallbacks.push(()=>{
        onRejected(this.reason);
      })
    }
	
    // 源码版本
    let promise2
    if(this.status === 'fulfilled') {
        promise2 = new Promise((resolve, reject) => {
            setTimeout(() => {
                try{
                    let x = onFulfilled(this.val)
                    resolvePromise(promise2, x, resolve, reject)
                } catch(e) {
                    reject(e)
                }
            })
        }, 0)
    }
    if(this.status === 'rejected') {
        promise2 = new Promise((resolve, reject) => {
            setTimeout(() => {
                try{
                    let x = onRejected(this.reason)
                    resolvePromise(promise2, x, resolve, reject)
                } catch(e) {
                    reject(e)
                }
            }, 0)
        })
    }
    if(this.status === 'pending') {
		promise2 = new Promise((resolve, reject) => {
            this.onResolvedCallbacks.push(() => {
                setTimeout(() => {
                    try{
                        let x = onFulfilled(this.reason)
                        resolvePromise(promise2, x, resolve, reject)
                    } catch(e) {
                        reject(e)
                    }
            	}, 0)
            })
            this.onRejectedCallbacks.push(() => {
                setTimeout(() => {
                    try{
                        let x = onRejected(this.reason)
                        resolvePromise(promise2, x, resolve, reject)
                    } catch(e) {
                        reject(e)
                    }
                }, 0)
            })
        })
    }
    return promise2
}

// resolve 方法 reject 同理
Promise.resolve = function(val) {
    return new Promise((resolve, reject)=>{resolve(val)})
}
// race 方法
Promise.race = function(promises) {
    return new Promise((resolve, reject) => {
        for(let i = 0; i < promises.length; i++) {
            promises[i].then(resolve, reject)
        }
    })
}
// all 方法
Promise.all = function(promises) {
    let arr = [], i = 0
    function processData(index, data) {
        arr[index] = data
        i++
        if(i === promises.length) {
            resolve(arr)
        }
    }
    return new Promise((reslove, reject) => {
        for(let i = 0; i < promises.length; i++) {
            promises[i].then(data => {
                processData(i, data)
            }, reject)
        }
    })
}

function resolvePromise(promise2,x,resolve,reject){
    if(promise2 === x){//不能自己等待自己完成
        return reject(new TypeError('循环引用'));
    };
    // x是除了null以外的对象或者函数
    if(x !=null && (typeof x === 'object' || typeof x === 'function')){
        let called;//防止成功后调用失败
        try{//防止取then是出现异常  object.defineProperty
            let then = x.then;//取x的then方法 {then:{}}
            if(typeof then === 'function'){//如果then是函数就认为他是promise
                //call第一个参数是this，后面的是成功的回调和失败的回调
                then.call(x,y => {//如果Y是promise就继续递归promise
                    if(called) return;
                    called = true;
                    resolvePromise(promise2,y,resolve,reject)
                },r => { //只要失败了就失败了
                    if(called) return;
                    called = true;
                    reject(r);  
                });
            }else{//then是一个普通对象，就直接成功即可
                resolve(x);
            }
        }catch (e){
            if(called) return;
            called = true;
            reject(e)
        }
    }else{ // x = 123 x就是一个普通值 作为下个then成功的参数
        resolve(x)
    }
}
```

### 2. new 的模拟实现

```javascript
let newMethod = function(Parent, ...rest) {
    // 以构造器的 prototype 属性为原型，创建新对象
    let child = Object.create(Parent.prototype)
    // 将 this 和调用参数传给构造器执行
    let result = Parent.call(child, rest)
    // 如果构造器没有手动返回对象，就返回第一部的对象
    return typeof result === 'object' ? result : child
}
```

### 3. indexOf 

```javascript
function indexOf(str, val){
    var strLen = str.length, valLen = val.length
    for(var i = 0; i < strLen; i++){
        var matchLen = i + valLen
        var matchStr = str.slice(i, matchLen)
        if(matchLen > strLen){
            return -1
        }
        if(matchStr === val){
            return i
        }
    }
    return -1
}
```

### 4. call、apply、bind

```javascript
Function.prototype.call = function(context, ...args) {
    if(typeof this !== 'function') return 
    context = context || window
    const fnSymbol = Symbol('fn')
    context[fnSymbol] = this // this 即为调用的方法
    context[fnSymbol](...args)
    delete context[fnSymbol]
}

Function.prototype.apply = function(context, argArr) {
    context = context || window
    const fnSymbol = Symbol('fn')
    context[fnSymbol] = this
    context[fnSymbol](...argsArr)
    delete context[fnSymbol]
}

Function.prototype.bind = function(context, ...args) {
    context = context || window
    let _this = this
    return function F() {
    	// 处理函数使用new的情况
    	if (this instanceof F) {
      		return new _this(...arg, ...arguments)
    	} else {
      		return _this.apply(context, arg.concat(...arguments))
    	}
  	}
}
```

### 5. 防抖、节流

```javascript
// 防抖
const debounce = (fn, delay) => {
    let timer
    return () => {
        if(timer) clearTimeout(timer)
        timer = setTimeout(fn, delay)
    }
}

// 节流
const throttle = (fn, delay) => {
    let time
    return () => {
        let now = Date.now()
        if(!time) time = now
        if(now - time >= delay) {
            fn()
            time = null
        } 
    }
}
```

### 6. 实现AJAX

```javascript
let xhr = new XMLHttpRequest()
xhr.open(method, url, async--true)
xhr.send(data)
xhr.onreadystatechange = () => {
    if(xhr.readyStatus === 4 && xhr.status === 200) {
        console.log(xhr.responseText)
    }
}
```

### 7. 实现双向数据绑定

```javascript
let obj = {}
let input = document.getElementById('input')
let span = document.getElementById('span')
// 数据劫持
Object.defineProperty(obj, 'text', {
    configurable: true,
    enumerable: true,
    get() {console.log('获得数据了')},
    set(newVal) {
        console.log('数据更新了')
        input.value = newVal
        span.innerHtml = newVal
    }
})

// 输入监听
input.addEventListener('keyup', function(e) {
    obj.text = e.target.value
})
```

### 8. 懒加载

```javascript
let img = document.querySelectorAll('img')
// 可视区高度
let clientHeight = window.innerHeight || document.documentElement.clientHeight ||document.body.clientHeight
function lazyLoad(){
    let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop
    for(let i = 0; i < imgs.length; i++){
		// 图片在可视区冒出的高度
        let x = clientHeight + scrollTop - imgs[i].offsetTop
        // 图片在可视区内
        if(x > 0 && x < clientHeight + imgs[i].height) {
            imgs[i].src = imgs[i].getAttribute('data')
        }
    }
}
addEventListener('scroll', lazyLoad) // setInterval(lazyLoad, 1000)
```

### 9. 实现简单路由

```javascript
// hash 路由
class Route{
    construtor(){
        // 路由储存对象
        this.routes = {}
        // 当前 hash
        this.currentHash = ''
        // 绑定this，避免指向改变
        this.freshRoute = this.freshRoute.bind(this)
        // 监听
        window.addEventListener('load', this.freshRoute, false)
        window.addEventListener('hashChange', this.freshRoute, false)
    }
    // 存储
    storeRoute(path, cb) {
        this.routes[path] = cb || function(){}
    }
    // 更新
    freshRoute() {
        this.currentHash = location.hash.slice(1) || '/'
        this.route[this.currentHash]()
    }
}
```

### 10. 实现一个基本的Event Bus

```javascript
// 组件通信，一个触发与监听的过程
class EventEmitter {
  constructor () {
    // 存储事件
    this.events = this.events || new Map()
  }
  // 监听事件
  addListener (type, fn) {
    if (!this.events.get(type)) {
      this.events.set(type, fn)
    }
  }
  // 触发事件
  emit (type) {
    let handle = this.events.get(type)
    handle.apply(this, [...arguments].slice(1))
  }
}
// 测试
let emitter = new EventEmitter()
// 监听事件
emitter.addListener('ages', age => {
  console.log(age)
})
// 触发事件
emitter.emit('ages', 18)  // 18
```

### 11. 判断对象数据类型

**不推荐检测基本类型，call 会对第一个参数进行装箱操作，导致基本类型包装类型无区分**

```javascript
const istype = type => target => `[object ${type}]` === Object.prototype.toString.call(target)
console.log(istype('Array')([])) // true

// 上式等价于 *闭包*
function istype(type) {
    return function(target) {
        return `[object ${type}]` === Object.prototype.toString.call(target)
    }
}
```

### 12. 斐波那契数列

```javascript
let fibonacci = function(n) {
    if(n < 1) throw new Error('参数有误')
    if(n === 1 || n === 2) return 1
    return fibonacci(n - 1) + fibonacci(n - 2)
}
const memory = function(fn) {
    let obj = {}
    return functuon(){
        if(obj[n] === undefined) obj[n] = fn(n)
        return obj[n]
    }
}
fibonacci = memory(fibonacci)
```

### 13. 实现 instanceof

```javascript
const selfInstanceof = function(left, right) {
    let proto = Object.getPrototypeOf(left)
    while(true) {
        if(proto === null) return false
        if(proto === right.prototype) return true
        proto = Object.getPrototypeOf(proto)
    }
}
```

### 14. 单例模式

```javascript
var SingleTon = function(name) {this.name = name}
SingleTon.prototype.getName = function(){return this.name}
SingleTon.prototype.getInstance = function(name){
    if(!this.instance) this.instance = new SingleTon(name)
    return this.instance
}
var a = SingleTon,getInstance('111')
var b = SingleTon,getInstance('222')
alert(a === b) // true
```

### 15. 发布者订阅模式

```javascript
class EventEmitter {
    constructor(){ this.subs = {} }
    // 注册事件
    on(event, cb) {
        (this.subs[event] || (this.subs[event] = [])).push(cb)
    }
    // 触发事件
    trigger(event, ...args) {
        this.subs[event] && 
            this.subs[event].forEach(cb => {
            cb(...args)
        })
    }
    // 只触发一次的事件
    once(event, onceCb) {
        const cb = (...args) => {
            onceCb(...args)
            this.off(event, onceCb)
        }
        this.on(event, cb)
    }
    //注销事件
    off(event, offCb) {
        if(!this.subs[event]){
            let index = this.subs[event].findIndex(cb => cb === offCb)
            this.subs[event].splice(index, 1)
            if(!this.subs[event].length) delete this.subs[event]
        }
    }
}
```

### 16. 实现 Object.assign 

```javascript
const isComplectDataType = obj => (typeof obj === 'object' || typeof obj === 'function') && obj !== null

const selfAssign = function(target, ...source) {
    if(target ==null) throw TypeError('Cannot convert undefined or null to object')
    return source.reduce((acc, cur) => {
        isComplexDataType(acc) || (acc = new Object(acc))
        if(cur == null) return acc
        [...Object.keys(cur), ...Object.getOwnPropertySymbols(cur)]
            .forEach(key => {acc[key] = cur[key]})
        return acc
    }, target)
}
```

### 17. 实现 Class 语法

```javascript
function inherit(subType, superType) {
    // 寄生组合式继承，完成实例和实例之间的继承
    // subType.prototype = 空对象   空对象.prototype = superType.prototyoe
    subType.prototype = Object.create(superType.prototype, {
        constructor: {
            enumerable: false,
            configurable: true,
            writable: true,
            value: subType
        }
    })
    // 从父类中继承静态方法和属性
    Object.setPrototypeOf(subType, superType)
}
```

### 18. 实现 filter 

```javascript
function selfFilter(fn, context) {
    if(typeof fn !== 'function') { throw new TypeError(`${fn} is not a function`)}
    let arr = this, temp = []
    for(let i = 0; i < arr.length; i++) {
        let result = fn.call(context, arr[i], i, arr)
        if(result) temp.push(arr[i])
    }
    return temp
}
Array.prototype.selfFilter = selfFilter
```

### 19. 实现 map

```javascript
const selfMap = function(fn, context) {
    let arr = Array.prototype.slice.call(this)
    let mappedArr = []
    for(let i = 0; i < arr.length; i++) {
        // 判断稀疏数组
        if(!arr.hasOwnProperty(i)) continue
        mappedArr[i] = fn.call(context, arr[i], i, this)
    }
    return mappedArr
}
const selfMap = function(fn, context) {
    let arr = Array.prototype.slice.call(this)
    return arr.reduce((pre, cur, index) => {
        return [...pre, fn.call(context, cur, index, this)]
    }, [])
}
Array.prototype.selfMap = selfMap
```

### 20. 函数柯里化**

```javascript
function curry(fn) {
    if(fn.length <= 1) return fn
    const generator = (...args) => {
        if(fn.length === args.lenhth) {
            return fn(...args)
        } else return (...args2) => {
            return generator(...args, ...args2)
        }
    }
    return generator
}
```

### 21. 实现 Reduce

```javascript
Array.prototype.selfReduce = function(cb, initialValue) {
    const array = this
    let acc = initialValue || array[0]
    const startIndex = initialValue ? 0: 1
    for(let i = startIndex; i < array.length; i++) {
        const cur = array[i]
        // 上一次的返回值 prev 当前值 cur 索引 index 数组对象 array
        acc = cb(acc, cur, i, array)
    }
    return acc
}
```

### 22. 深拷贝

- JSON 方法

  - JSON.parse(JSON.stringify(origin))
    - undefined、fuction、symbol 和一些对象会被忽略

- 递归思想

  - 如果有循环引用，加入 (weak)map 查找
  - 如果有 Symbol
    - Object.getOwnPropertySymbols：查找 Symbol 并优先遍历
    - Reflect.ownKeys：直接调用 forEach 进行赋值

  ```javascript
  function deepClone(source) {
      if(!(typeof source === 'object' && obj !== null)) return source // 非对象返回自身
      const targetObj = source.constructor === Array ? []: {} // Array.isArray(source)
      for(let key in source) {
          if(source.hasOwnProperty(key)) { // Object.prototype.hasOwnProperty.call(source, key)
              if(source[key] && source[key] === 'object') {
                  targetObj[key] = source[key].constructor === Array ? []: {}
                  targetObj[key] = deepClone(source[key])
              } else {
                  targetObj[key] = source[key]
              }
          }
      }
      return targetObj
  }
  ```

### 23. setTimeout 输出

- 改变循环体

  - 将此部分转移到外部，根据 按值传递 特性改造

- 自执行函数

  ```javascript
  (function(j) {
          setTimeout(function() {
              console.log(new Date, j);
          }, 1000 * j);  // 这里修改 0~4 的定时器时间
      })(i);
  ```

- Promise

  ```javascript
  const tasks = []; // 这里存放异步操作的 Promise
  const output = (i) => new Promise((resolve) => {
      setTimeout(() => {
          console.log(new Date, i);
          resolve(); // 必须要加
      }, 1000 * i);
  });
  // 生成全部的异步操作
  for (var i = 0; i < 5; i++) {
      tasks.push(output(i));
  }
  // 异步操作完成之后，输出最后的 i
  Promise.all(tasks).then(() => {
      setTimeout(() => {
          console.log(new Date, i);
      }, 1000);
  });
  ```

### 24. 创建对象

1. 工厂模式

   - 没有解决对象识别的问题，即知道对象的类型

   ```javascript
   function Person(name) {
       var o = new Object();
       o.name = name;
       o.getName = function () {
           console.log(this.name);
       };
       return o;
   }
   var person1 = Person('kevin') // 工厂模式
   
   var person1 = new Person('kevin'); // 寄生构造函数模式
   console.log(person1 instanceof Person) // false
   console.log(person1 instanceof Object)  // true
   ```

2. 构造函数模式

   - 每个方法都会在实例上重新创建

   ```javascript
   function Person(name) {
       this.name = name;
       this.getName = function () {
           console.log(this.name);
       };
   }
   ```

3. 原型模式

   - 直接在 prototype 上添加内容

   - 问题：共享引用类型

     ```javascript
     // 方便的写法
     Fun.prototype = {}
     // 需要添加 constructor
     Object.defineProperty(Person.prototype, "constructor", {
         enumerable: false,
         value: Person
     })
     ```

4. 组合模式

   - 构造函数定义实例属性，原型模式定义方法和共享的属性

   - 使用最广泛，共享私有兼得

   ```javascript
   function Person(name) {
       this.name = name;
   }
   
   Person.prototype = {
       constructor: Person,
       getName: function () {
           console.log(this.name);
       }
   };
   
   var person1 = new Person("jolly");
   ```

### 25. 继承

1. 原型链继承

   - Child.prototype = new Parent()
   - 引用类型属性被所有实例共享
   - Child 不能向 Parent 传参0

2. 构造函数

   - 避免引用类型被所有实例共享
   - 可以向 Parent 传参
   - 方法在构造函数中定义，每次创建实例都会创建一遍方法

   ```javascript
   function Parent (name) {
       this.name = name;}
   function Child (name) {
       Parent.call(this, name);}
   var child1 = new Child('kevin');
   console.log(child1.name); // kevin
   var child2 = new Child('daisy');
   console.log(child2.name); // daisy
   ```

3. 组合继承（最常用）

   - 比较耗内存

   ```javascript
   function Parent(name) {
       this.name = name
       this.sum = function(){
           alert(this.name)
       }
   }
   Parent.prototype.age = 18
   
   function Child(name) {
       Parent.call(this, name) // 借用构造函数模式
   }
   
   Child.prototype = new Parent() // 原型链继承
   Child.prototype.constructor = Child
   var child = new Child('guys')
   console.log(child.name) // 'guys'继承了构造函数属性
   console.log(child.age) // 继承了父类原型的属性
   ```
   
4. 原型式继承

   ```javascript
   function content(obj) {
       function F(){}
       F.prototype = obj
       return new F()
   }
   var sup = new Parent()
   var sup1 = content(sup)
   ```

5. 寄生式继承

6. 寄生组合式继承（常用）

   ```javascript
   function content(obj) {
       function F(){}
       F.prototype = obj
       return new F()
   } // content 就是 F 实例的另种表示法
   var con = content(Parent.prototype) // con(F) 实例原型继承了父类函数的原型属性
   function Sub(){Parent.call(this)} // 继承了父类构造函数属性
   Sub.prototype = con // 继承了 con 实例
   con.constructor = Sub // 修复实例
   var sub1 = new Sub() // 继承了构造函数属性，父类实例，con 的函数属性
   ```








